// Code generated by http://github.com/gojuno/minimock (v3.3.13). DO NOT EDIT.

package mock

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	mm_artifactv1alpha "github.com/instill-ai/protogen-go/artifact/artifact/v1alpha"
	grpc "google.golang.org/grpc"
)

// ArtifactPublicServiceClientMock implements artifactv1alpha.ArtifactPublicServiceClient
type ArtifactPublicServiceClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateCatalog          func(ctx context.Context, in *mm_artifactv1alpha.CreateCatalogRequest, opts ...grpc.CallOption) (cp1 *mm_artifactv1alpha.CreateCatalogResponse, err error)
	inspectFuncCreateCatalog   func(ctx context.Context, in *mm_artifactv1alpha.CreateCatalogRequest, opts ...grpc.CallOption)
	afterCreateCatalogCounter  uint64
	beforeCreateCatalogCounter uint64
	CreateCatalogMock          mArtifactPublicServiceClientMockCreateCatalog

	funcCreateConversation          func(ctx context.Context, in *mm_artifactv1alpha.CreateConversationRequest, opts ...grpc.CallOption) (cp1 *mm_artifactv1alpha.CreateConversationResponse, err error)
	inspectFuncCreateConversation   func(ctx context.Context, in *mm_artifactv1alpha.CreateConversationRequest, opts ...grpc.CallOption)
	afterCreateConversationCounter  uint64
	beforeCreateConversationCounter uint64
	CreateConversationMock          mArtifactPublicServiceClientMockCreateConversation

	funcCreateMessage          func(ctx context.Context, in *mm_artifactv1alpha.CreateMessageRequest, opts ...grpc.CallOption) (cp1 *mm_artifactv1alpha.CreateMessageResponse, err error)
	inspectFuncCreateMessage   func(ctx context.Context, in *mm_artifactv1alpha.CreateMessageRequest, opts ...grpc.CallOption)
	afterCreateMessageCounter  uint64
	beforeCreateMessageCounter uint64
	CreateMessageMock          mArtifactPublicServiceClientMockCreateMessage

	funcDeleteCatalog          func(ctx context.Context, in *mm_artifactv1alpha.DeleteCatalogRequest, opts ...grpc.CallOption) (dp1 *mm_artifactv1alpha.DeleteCatalogResponse, err error)
	inspectFuncDeleteCatalog   func(ctx context.Context, in *mm_artifactv1alpha.DeleteCatalogRequest, opts ...grpc.CallOption)
	afterDeleteCatalogCounter  uint64
	beforeDeleteCatalogCounter uint64
	DeleteCatalogMock          mArtifactPublicServiceClientMockDeleteCatalog

	funcDeleteCatalogFile          func(ctx context.Context, in *mm_artifactv1alpha.DeleteCatalogFileRequest, opts ...grpc.CallOption) (dp1 *mm_artifactv1alpha.DeleteCatalogFileResponse, err error)
	inspectFuncDeleteCatalogFile   func(ctx context.Context, in *mm_artifactv1alpha.DeleteCatalogFileRequest, opts ...grpc.CallOption)
	afterDeleteCatalogFileCounter  uint64
	beforeDeleteCatalogFileCounter uint64
	DeleteCatalogFileMock          mArtifactPublicServiceClientMockDeleteCatalogFile

	funcDeleteConversation          func(ctx context.Context, in *mm_artifactv1alpha.DeleteConversationRequest, opts ...grpc.CallOption) (dp1 *mm_artifactv1alpha.DeleteConversationResponse, err error)
	inspectFuncDeleteConversation   func(ctx context.Context, in *mm_artifactv1alpha.DeleteConversationRequest, opts ...grpc.CallOption)
	afterDeleteConversationCounter  uint64
	beforeDeleteConversationCounter uint64
	DeleteConversationMock          mArtifactPublicServiceClientMockDeleteConversation

	funcDeleteMessage          func(ctx context.Context, in *mm_artifactv1alpha.DeleteMessageRequest, opts ...grpc.CallOption) (dp1 *mm_artifactv1alpha.DeleteMessageResponse, err error)
	inspectFuncDeleteMessage   func(ctx context.Context, in *mm_artifactv1alpha.DeleteMessageRequest, opts ...grpc.CallOption)
	afterDeleteMessageCounter  uint64
	beforeDeleteMessageCounter uint64
	DeleteMessageMock          mArtifactPublicServiceClientMockDeleteMessage

	funcGetFileCatalog          func(ctx context.Context, in *mm_artifactv1alpha.GetFileCatalogRequest, opts ...grpc.CallOption) (gp1 *mm_artifactv1alpha.GetFileCatalogResponse, err error)
	inspectFuncGetFileCatalog   func(ctx context.Context, in *mm_artifactv1alpha.GetFileCatalogRequest, opts ...grpc.CallOption)
	afterGetFileCatalogCounter  uint64
	beforeGetFileCatalogCounter uint64
	GetFileCatalogMock          mArtifactPublicServiceClientMockGetFileCatalog

	funcGetSourceFile          func(ctx context.Context, in *mm_artifactv1alpha.GetSourceFileRequest, opts ...grpc.CallOption) (gp1 *mm_artifactv1alpha.GetSourceFileResponse, err error)
	inspectFuncGetSourceFile   func(ctx context.Context, in *mm_artifactv1alpha.GetSourceFileRequest, opts ...grpc.CallOption)
	afterGetSourceFileCounter  uint64
	beforeGetSourceFileCounter uint64
	GetSourceFileMock          mArtifactPublicServiceClientMockGetSourceFile

	funcListCatalogFiles          func(ctx context.Context, in *mm_artifactv1alpha.ListCatalogFilesRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.ListCatalogFilesResponse, err error)
	inspectFuncListCatalogFiles   func(ctx context.Context, in *mm_artifactv1alpha.ListCatalogFilesRequest, opts ...grpc.CallOption)
	afterListCatalogFilesCounter  uint64
	beforeListCatalogFilesCounter uint64
	ListCatalogFilesMock          mArtifactPublicServiceClientMockListCatalogFiles

	funcListCatalogs          func(ctx context.Context, in *mm_artifactv1alpha.ListCatalogsRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.ListCatalogsResponse, err error)
	inspectFuncListCatalogs   func(ctx context.Context, in *mm_artifactv1alpha.ListCatalogsRequest, opts ...grpc.CallOption)
	afterListCatalogsCounter  uint64
	beforeListCatalogsCounter uint64
	ListCatalogsMock          mArtifactPublicServiceClientMockListCatalogs

	funcListChunks          func(ctx context.Context, in *mm_artifactv1alpha.ListChunksRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.ListChunksResponse, err error)
	inspectFuncListChunks   func(ctx context.Context, in *mm_artifactv1alpha.ListChunksRequest, opts ...grpc.CallOption)
	afterListChunksCounter  uint64
	beforeListChunksCounter uint64
	ListChunksMock          mArtifactPublicServiceClientMockListChunks

	funcListConversations          func(ctx context.Context, in *mm_artifactv1alpha.ListConversationsRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.ListConversationsResponse, err error)
	inspectFuncListConversations   func(ctx context.Context, in *mm_artifactv1alpha.ListConversationsRequest, opts ...grpc.CallOption)
	afterListConversationsCounter  uint64
	beforeListConversationsCounter uint64
	ListConversationsMock          mArtifactPublicServiceClientMockListConversations

	funcListMessages          func(ctx context.Context, in *mm_artifactv1alpha.ListMessagesRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.ListMessagesResponse, err error)
	inspectFuncListMessages   func(ctx context.Context, in *mm_artifactv1alpha.ListMessagesRequest, opts ...grpc.CallOption)
	afterListMessagesCounter  uint64
	beforeListMessagesCounter uint64
	ListMessagesMock          mArtifactPublicServiceClientMockListMessages

	funcLiveness          func(ctx context.Context, in *mm_artifactv1alpha.LivenessRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.LivenessResponse, err error)
	inspectFuncLiveness   func(ctx context.Context, in *mm_artifactv1alpha.LivenessRequest, opts ...grpc.CallOption)
	afterLivenessCounter  uint64
	beforeLivenessCounter uint64
	LivenessMock          mArtifactPublicServiceClientMockLiveness

	funcProcessCatalogFiles          func(ctx context.Context, in *mm_artifactv1alpha.ProcessCatalogFilesRequest, opts ...grpc.CallOption) (pp1 *mm_artifactv1alpha.ProcessCatalogFilesResponse, err error)
	inspectFuncProcessCatalogFiles   func(ctx context.Context, in *mm_artifactv1alpha.ProcessCatalogFilesRequest, opts ...grpc.CallOption)
	afterProcessCatalogFilesCounter  uint64
	beforeProcessCatalogFilesCounter uint64
	ProcessCatalogFilesMock          mArtifactPublicServiceClientMockProcessCatalogFiles

	funcQuestionAnswering          func(ctx context.Context, in *mm_artifactv1alpha.QuestionAnsweringRequest, opts ...grpc.CallOption) (qp1 *mm_artifactv1alpha.QuestionAnsweringResponse, err error)
	inspectFuncQuestionAnswering   func(ctx context.Context, in *mm_artifactv1alpha.QuestionAnsweringRequest, opts ...grpc.CallOption)
	afterQuestionAnsweringCounter  uint64
	beforeQuestionAnsweringCounter uint64
	QuestionAnsweringMock          mArtifactPublicServiceClientMockQuestionAnswering

	funcReadiness          func(ctx context.Context, in *mm_artifactv1alpha.ReadinessRequest, opts ...grpc.CallOption) (rp1 *mm_artifactv1alpha.ReadinessResponse, err error)
	inspectFuncReadiness   func(ctx context.Context, in *mm_artifactv1alpha.ReadinessRequest, opts ...grpc.CallOption)
	afterReadinessCounter  uint64
	beforeReadinessCounter uint64
	ReadinessMock          mArtifactPublicServiceClientMockReadiness

	funcSimilarityChunksSearch          func(ctx context.Context, in *mm_artifactv1alpha.SimilarityChunksSearchRequest, opts ...grpc.CallOption) (sp1 *mm_artifactv1alpha.SimilarityChunksSearchResponse, err error)
	inspectFuncSimilarityChunksSearch   func(ctx context.Context, in *mm_artifactv1alpha.SimilarityChunksSearchRequest, opts ...grpc.CallOption)
	afterSimilarityChunksSearchCounter  uint64
	beforeSimilarityChunksSearchCounter uint64
	SimilarityChunksSearchMock          mArtifactPublicServiceClientMockSimilarityChunksSearch

	funcUpdateCatalog          func(ctx context.Context, in *mm_artifactv1alpha.UpdateCatalogRequest, opts ...grpc.CallOption) (up1 *mm_artifactv1alpha.UpdateCatalogResponse, err error)
	inspectFuncUpdateCatalog   func(ctx context.Context, in *mm_artifactv1alpha.UpdateCatalogRequest, opts ...grpc.CallOption)
	afterUpdateCatalogCounter  uint64
	beforeUpdateCatalogCounter uint64
	UpdateCatalogMock          mArtifactPublicServiceClientMockUpdateCatalog

	funcUpdateChunk          func(ctx context.Context, in *mm_artifactv1alpha.UpdateChunkRequest, opts ...grpc.CallOption) (up1 *mm_artifactv1alpha.UpdateChunkResponse, err error)
	inspectFuncUpdateChunk   func(ctx context.Context, in *mm_artifactv1alpha.UpdateChunkRequest, opts ...grpc.CallOption)
	afterUpdateChunkCounter  uint64
	beforeUpdateChunkCounter uint64
	UpdateChunkMock          mArtifactPublicServiceClientMockUpdateChunk

	funcUpdateConversation          func(ctx context.Context, in *mm_artifactv1alpha.UpdateConversationRequest, opts ...grpc.CallOption) (up1 *mm_artifactv1alpha.UpdateConversationResponse, err error)
	inspectFuncUpdateConversation   func(ctx context.Context, in *mm_artifactv1alpha.UpdateConversationRequest, opts ...grpc.CallOption)
	afterUpdateConversationCounter  uint64
	beforeUpdateConversationCounter uint64
	UpdateConversationMock          mArtifactPublicServiceClientMockUpdateConversation

	funcUpdateMessage          func(ctx context.Context, in *mm_artifactv1alpha.UpdateMessageRequest, opts ...grpc.CallOption) (up1 *mm_artifactv1alpha.UpdateMessageResponse, err error)
	inspectFuncUpdateMessage   func(ctx context.Context, in *mm_artifactv1alpha.UpdateMessageRequest, opts ...grpc.CallOption)
	afterUpdateMessageCounter  uint64
	beforeUpdateMessageCounter uint64
	UpdateMessageMock          mArtifactPublicServiceClientMockUpdateMessage

	funcUploadCatalogFile          func(ctx context.Context, in *mm_artifactv1alpha.UploadCatalogFileRequest, opts ...grpc.CallOption) (up1 *mm_artifactv1alpha.UploadCatalogFileResponse, err error)
	inspectFuncUploadCatalogFile   func(ctx context.Context, in *mm_artifactv1alpha.UploadCatalogFileRequest, opts ...grpc.CallOption)
	afterUploadCatalogFileCounter  uint64
	beforeUploadCatalogFileCounter uint64
	UploadCatalogFileMock          mArtifactPublicServiceClientMockUploadCatalogFile
}

// NewArtifactPublicServiceClientMock returns a mock for artifactv1alpha.ArtifactPublicServiceClient
func NewArtifactPublicServiceClientMock(t minimock.Tester) *ArtifactPublicServiceClientMock {
	m := &ArtifactPublicServiceClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateCatalogMock = mArtifactPublicServiceClientMockCreateCatalog{mock: m}
	m.CreateCatalogMock.callArgs = []*ArtifactPublicServiceClientMockCreateCatalogParams{}

	m.CreateConversationMock = mArtifactPublicServiceClientMockCreateConversation{mock: m}
	m.CreateConversationMock.callArgs = []*ArtifactPublicServiceClientMockCreateConversationParams{}

	m.CreateMessageMock = mArtifactPublicServiceClientMockCreateMessage{mock: m}
	m.CreateMessageMock.callArgs = []*ArtifactPublicServiceClientMockCreateMessageParams{}

	m.DeleteCatalogMock = mArtifactPublicServiceClientMockDeleteCatalog{mock: m}
	m.DeleteCatalogMock.callArgs = []*ArtifactPublicServiceClientMockDeleteCatalogParams{}

	m.DeleteCatalogFileMock = mArtifactPublicServiceClientMockDeleteCatalogFile{mock: m}
	m.DeleteCatalogFileMock.callArgs = []*ArtifactPublicServiceClientMockDeleteCatalogFileParams{}

	m.DeleteConversationMock = mArtifactPublicServiceClientMockDeleteConversation{mock: m}
	m.DeleteConversationMock.callArgs = []*ArtifactPublicServiceClientMockDeleteConversationParams{}

	m.DeleteMessageMock = mArtifactPublicServiceClientMockDeleteMessage{mock: m}
	m.DeleteMessageMock.callArgs = []*ArtifactPublicServiceClientMockDeleteMessageParams{}

	m.GetFileCatalogMock = mArtifactPublicServiceClientMockGetFileCatalog{mock: m}
	m.GetFileCatalogMock.callArgs = []*ArtifactPublicServiceClientMockGetFileCatalogParams{}

	m.GetSourceFileMock = mArtifactPublicServiceClientMockGetSourceFile{mock: m}
	m.GetSourceFileMock.callArgs = []*ArtifactPublicServiceClientMockGetSourceFileParams{}

	m.ListCatalogFilesMock = mArtifactPublicServiceClientMockListCatalogFiles{mock: m}
	m.ListCatalogFilesMock.callArgs = []*ArtifactPublicServiceClientMockListCatalogFilesParams{}

	m.ListCatalogsMock = mArtifactPublicServiceClientMockListCatalogs{mock: m}
	m.ListCatalogsMock.callArgs = []*ArtifactPublicServiceClientMockListCatalogsParams{}

	m.ListChunksMock = mArtifactPublicServiceClientMockListChunks{mock: m}
	m.ListChunksMock.callArgs = []*ArtifactPublicServiceClientMockListChunksParams{}

	m.ListConversationsMock = mArtifactPublicServiceClientMockListConversations{mock: m}
	m.ListConversationsMock.callArgs = []*ArtifactPublicServiceClientMockListConversationsParams{}

	m.ListMessagesMock = mArtifactPublicServiceClientMockListMessages{mock: m}
	m.ListMessagesMock.callArgs = []*ArtifactPublicServiceClientMockListMessagesParams{}

	m.LivenessMock = mArtifactPublicServiceClientMockLiveness{mock: m}
	m.LivenessMock.callArgs = []*ArtifactPublicServiceClientMockLivenessParams{}

	m.ProcessCatalogFilesMock = mArtifactPublicServiceClientMockProcessCatalogFiles{mock: m}
	m.ProcessCatalogFilesMock.callArgs = []*ArtifactPublicServiceClientMockProcessCatalogFilesParams{}

	m.QuestionAnsweringMock = mArtifactPublicServiceClientMockQuestionAnswering{mock: m}
	m.QuestionAnsweringMock.callArgs = []*ArtifactPublicServiceClientMockQuestionAnsweringParams{}

	m.ReadinessMock = mArtifactPublicServiceClientMockReadiness{mock: m}
	m.ReadinessMock.callArgs = []*ArtifactPublicServiceClientMockReadinessParams{}

	m.SimilarityChunksSearchMock = mArtifactPublicServiceClientMockSimilarityChunksSearch{mock: m}
	m.SimilarityChunksSearchMock.callArgs = []*ArtifactPublicServiceClientMockSimilarityChunksSearchParams{}

	m.UpdateCatalogMock = mArtifactPublicServiceClientMockUpdateCatalog{mock: m}
	m.UpdateCatalogMock.callArgs = []*ArtifactPublicServiceClientMockUpdateCatalogParams{}

	m.UpdateChunkMock = mArtifactPublicServiceClientMockUpdateChunk{mock: m}
	m.UpdateChunkMock.callArgs = []*ArtifactPublicServiceClientMockUpdateChunkParams{}

	m.UpdateConversationMock = mArtifactPublicServiceClientMockUpdateConversation{mock: m}
	m.UpdateConversationMock.callArgs = []*ArtifactPublicServiceClientMockUpdateConversationParams{}

	m.UpdateMessageMock = mArtifactPublicServiceClientMockUpdateMessage{mock: m}
	m.UpdateMessageMock.callArgs = []*ArtifactPublicServiceClientMockUpdateMessageParams{}

	m.UploadCatalogFileMock = mArtifactPublicServiceClientMockUploadCatalogFile{mock: m}
	m.UploadCatalogFileMock.callArgs = []*ArtifactPublicServiceClientMockUploadCatalogFileParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mArtifactPublicServiceClientMockCreateCatalog struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockCreateCatalogExpectation
	expectations       []*ArtifactPublicServiceClientMockCreateCatalogExpectation

	callArgs []*ArtifactPublicServiceClientMockCreateCatalogParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ArtifactPublicServiceClientMockCreateCatalogExpectation specifies expectation struct of the ArtifactPublicServiceClient.CreateCatalog
type ArtifactPublicServiceClientMockCreateCatalogExpectation struct {
	mock      *ArtifactPublicServiceClientMock
	params    *ArtifactPublicServiceClientMockCreateCatalogParams
	paramPtrs *ArtifactPublicServiceClientMockCreateCatalogParamPtrs
	results   *ArtifactPublicServiceClientMockCreateCatalogResults
	Counter   uint64
}

// ArtifactPublicServiceClientMockCreateCatalogParams contains parameters of the ArtifactPublicServiceClient.CreateCatalog
type ArtifactPublicServiceClientMockCreateCatalogParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.CreateCatalogRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockCreateCatalogParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.CreateCatalog
type ArtifactPublicServiceClientMockCreateCatalogParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.CreateCatalogRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockCreateCatalogResults contains results of the ArtifactPublicServiceClient.CreateCatalog
type ArtifactPublicServiceClientMockCreateCatalogResults struct {
	cp1 *mm_artifactv1alpha.CreateCatalogResponse
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateCatalog *mArtifactPublicServiceClientMockCreateCatalog) Optional() *mArtifactPublicServiceClientMockCreateCatalog {
	mmCreateCatalog.optional = true
	return mmCreateCatalog
}

// Expect sets up expected params for ArtifactPublicServiceClient.CreateCatalog
func (mmCreateCatalog *mArtifactPublicServiceClientMockCreateCatalog) Expect(ctx context.Context, in *mm_artifactv1alpha.CreateCatalogRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockCreateCatalog {
	if mmCreateCatalog.mock.funcCreateCatalog != nil {
		mmCreateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateCatalog mock is already set by Set")
	}

	if mmCreateCatalog.defaultExpectation == nil {
		mmCreateCatalog.defaultExpectation = &ArtifactPublicServiceClientMockCreateCatalogExpectation{}
	}

	if mmCreateCatalog.defaultExpectation.paramPtrs != nil {
		mmCreateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateCatalog mock is already set by ExpectParams functions")
	}

	mmCreateCatalog.defaultExpectation.params = &ArtifactPublicServiceClientMockCreateCatalogParams{ctx, in, opts}
	for _, e := range mmCreateCatalog.expectations {
		if minimock.Equal(e.params, mmCreateCatalog.defaultExpectation.params) {
			mmCreateCatalog.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateCatalog.defaultExpectation.params)
		}
	}

	return mmCreateCatalog
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.CreateCatalog
func (mmCreateCatalog *mArtifactPublicServiceClientMockCreateCatalog) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockCreateCatalog {
	if mmCreateCatalog.mock.funcCreateCatalog != nil {
		mmCreateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateCatalog mock is already set by Set")
	}

	if mmCreateCatalog.defaultExpectation == nil {
		mmCreateCatalog.defaultExpectation = &ArtifactPublicServiceClientMockCreateCatalogExpectation{}
	}

	if mmCreateCatalog.defaultExpectation.params != nil {
		mmCreateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateCatalog mock is already set by Expect")
	}

	if mmCreateCatalog.defaultExpectation.paramPtrs == nil {
		mmCreateCatalog.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockCreateCatalogParamPtrs{}
	}
	mmCreateCatalog.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateCatalog
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.CreateCatalog
func (mmCreateCatalog *mArtifactPublicServiceClientMockCreateCatalog) ExpectInParam2(in *mm_artifactv1alpha.CreateCatalogRequest) *mArtifactPublicServiceClientMockCreateCatalog {
	if mmCreateCatalog.mock.funcCreateCatalog != nil {
		mmCreateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateCatalog mock is already set by Set")
	}

	if mmCreateCatalog.defaultExpectation == nil {
		mmCreateCatalog.defaultExpectation = &ArtifactPublicServiceClientMockCreateCatalogExpectation{}
	}

	if mmCreateCatalog.defaultExpectation.params != nil {
		mmCreateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateCatalog mock is already set by Expect")
	}

	if mmCreateCatalog.defaultExpectation.paramPtrs == nil {
		mmCreateCatalog.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockCreateCatalogParamPtrs{}
	}
	mmCreateCatalog.defaultExpectation.paramPtrs.in = &in

	return mmCreateCatalog
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.CreateCatalog
func (mmCreateCatalog *mArtifactPublicServiceClientMockCreateCatalog) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockCreateCatalog {
	if mmCreateCatalog.mock.funcCreateCatalog != nil {
		mmCreateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateCatalog mock is already set by Set")
	}

	if mmCreateCatalog.defaultExpectation == nil {
		mmCreateCatalog.defaultExpectation = &ArtifactPublicServiceClientMockCreateCatalogExpectation{}
	}

	if mmCreateCatalog.defaultExpectation.params != nil {
		mmCreateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateCatalog mock is already set by Expect")
	}

	if mmCreateCatalog.defaultExpectation.paramPtrs == nil {
		mmCreateCatalog.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockCreateCatalogParamPtrs{}
	}
	mmCreateCatalog.defaultExpectation.paramPtrs.opts = &opts

	return mmCreateCatalog
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.CreateCatalog
func (mmCreateCatalog *mArtifactPublicServiceClientMockCreateCatalog) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.CreateCatalogRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockCreateCatalog {
	if mmCreateCatalog.mock.inspectFuncCreateCatalog != nil {
		mmCreateCatalog.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.CreateCatalog")
	}

	mmCreateCatalog.mock.inspectFuncCreateCatalog = f

	return mmCreateCatalog
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.CreateCatalog
func (mmCreateCatalog *mArtifactPublicServiceClientMockCreateCatalog) Return(cp1 *mm_artifactv1alpha.CreateCatalogResponse, err error) *ArtifactPublicServiceClientMock {
	if mmCreateCatalog.mock.funcCreateCatalog != nil {
		mmCreateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateCatalog mock is already set by Set")
	}

	if mmCreateCatalog.defaultExpectation == nil {
		mmCreateCatalog.defaultExpectation = &ArtifactPublicServiceClientMockCreateCatalogExpectation{mock: mmCreateCatalog.mock}
	}
	mmCreateCatalog.defaultExpectation.results = &ArtifactPublicServiceClientMockCreateCatalogResults{cp1, err}
	return mmCreateCatalog.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.CreateCatalog method
func (mmCreateCatalog *mArtifactPublicServiceClientMockCreateCatalog) Set(f func(ctx context.Context, in *mm_artifactv1alpha.CreateCatalogRequest, opts ...grpc.CallOption) (cp1 *mm_artifactv1alpha.CreateCatalogResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmCreateCatalog.defaultExpectation != nil {
		mmCreateCatalog.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.CreateCatalog method")
	}

	if len(mmCreateCatalog.expectations) > 0 {
		mmCreateCatalog.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.CreateCatalog method")
	}

	mmCreateCatalog.mock.funcCreateCatalog = f
	return mmCreateCatalog.mock
}

// When sets expectation for the ArtifactPublicServiceClient.CreateCatalog which will trigger the result defined by the following
// Then helper
func (mmCreateCatalog *mArtifactPublicServiceClientMockCreateCatalog) When(ctx context.Context, in *mm_artifactv1alpha.CreateCatalogRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockCreateCatalogExpectation {
	if mmCreateCatalog.mock.funcCreateCatalog != nil {
		mmCreateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateCatalog mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockCreateCatalogExpectation{
		mock:   mmCreateCatalog.mock,
		params: &ArtifactPublicServiceClientMockCreateCatalogParams{ctx, in, opts},
	}
	mmCreateCatalog.expectations = append(mmCreateCatalog.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.CreateCatalog return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockCreateCatalogExpectation) Then(cp1 *mm_artifactv1alpha.CreateCatalogResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockCreateCatalogResults{cp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.CreateCatalog should be invoked
func (mmCreateCatalog *mArtifactPublicServiceClientMockCreateCatalog) Times(n uint64) *mArtifactPublicServiceClientMockCreateCatalog {
	if n == 0 {
		mmCreateCatalog.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.CreateCatalog mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateCatalog.expectedInvocations, n)
	return mmCreateCatalog
}

func (mmCreateCatalog *mArtifactPublicServiceClientMockCreateCatalog) invocationsDone() bool {
	if len(mmCreateCatalog.expectations) == 0 && mmCreateCatalog.defaultExpectation == nil && mmCreateCatalog.mock.funcCreateCatalog == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateCatalog.mock.afterCreateCatalogCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateCatalog.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateCatalog implements artifactv1alpha.ArtifactPublicServiceClient
func (mmCreateCatalog *ArtifactPublicServiceClientMock) CreateCatalog(ctx context.Context, in *mm_artifactv1alpha.CreateCatalogRequest, opts ...grpc.CallOption) (cp1 *mm_artifactv1alpha.CreateCatalogResponse, err error) {
	mm_atomic.AddUint64(&mmCreateCatalog.beforeCreateCatalogCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateCatalog.afterCreateCatalogCounter, 1)

	if mmCreateCatalog.inspectFuncCreateCatalog != nil {
		mmCreateCatalog.inspectFuncCreateCatalog(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockCreateCatalogParams{ctx, in, opts}

	// Record call args
	mmCreateCatalog.CreateCatalogMock.mutex.Lock()
	mmCreateCatalog.CreateCatalogMock.callArgs = append(mmCreateCatalog.CreateCatalogMock.callArgs, &mm_params)
	mmCreateCatalog.CreateCatalogMock.mutex.Unlock()

	for _, e := range mmCreateCatalog.CreateCatalogMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmCreateCatalog.CreateCatalogMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateCatalog.CreateCatalogMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateCatalog.CreateCatalogMock.defaultExpectation.params
		mm_want_ptrs := mmCreateCatalog.CreateCatalogMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockCreateCatalogParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateCatalog.t.Errorf("ArtifactPublicServiceClientMock.CreateCatalog got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmCreateCatalog.t.Errorf("ArtifactPublicServiceClientMock.CreateCatalog got unexpected parameter in, want: %#v, got: %#v%s\n", *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmCreateCatalog.t.Errorf("ArtifactPublicServiceClientMock.CreateCatalog got unexpected parameter opts, want: %#v, got: %#v%s\n", *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateCatalog.t.Errorf("ArtifactPublicServiceClientMock.CreateCatalog got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateCatalog.CreateCatalogMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateCatalog.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.CreateCatalog")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmCreateCatalog.funcCreateCatalog != nil {
		return mmCreateCatalog.funcCreateCatalog(ctx, in, opts...)
	}
	mmCreateCatalog.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.CreateCatalog. %v %v %v", ctx, in, opts)
	return
}

// CreateCatalogAfterCounter returns a count of finished ArtifactPublicServiceClientMock.CreateCatalog invocations
func (mmCreateCatalog *ArtifactPublicServiceClientMock) CreateCatalogAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateCatalog.afterCreateCatalogCounter)
}

// CreateCatalogBeforeCounter returns a count of ArtifactPublicServiceClientMock.CreateCatalog invocations
func (mmCreateCatalog *ArtifactPublicServiceClientMock) CreateCatalogBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateCatalog.beforeCreateCatalogCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.CreateCatalog.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateCatalog *mArtifactPublicServiceClientMockCreateCatalog) Calls() []*ArtifactPublicServiceClientMockCreateCatalogParams {
	mmCreateCatalog.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockCreateCatalogParams, len(mmCreateCatalog.callArgs))
	copy(argCopy, mmCreateCatalog.callArgs)

	mmCreateCatalog.mutex.RUnlock()

	return argCopy
}

// MinimockCreateCatalogDone returns true if the count of the CreateCatalog invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockCreateCatalogDone() bool {
	if m.CreateCatalogMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateCatalogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateCatalogMock.invocationsDone()
}

// MinimockCreateCatalogInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockCreateCatalogInspect() {
	for _, e := range m.CreateCatalogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.CreateCatalog with params: %#v", *e.params)
		}
	}

	afterCreateCatalogCounter := mm_atomic.LoadUint64(&m.afterCreateCatalogCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateCatalogMock.defaultExpectation != nil && afterCreateCatalogCounter < 1 {
		if m.CreateCatalogMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ArtifactPublicServiceClientMock.CreateCatalog")
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.CreateCatalog with params: %#v", *m.CreateCatalogMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateCatalog != nil && afterCreateCatalogCounter < 1 {
		m.t.Error("Expected call to ArtifactPublicServiceClientMock.CreateCatalog")
	}

	if !m.CreateCatalogMock.invocationsDone() && afterCreateCatalogCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.CreateCatalog but found %d calls",
			mm_atomic.LoadUint64(&m.CreateCatalogMock.expectedInvocations), afterCreateCatalogCounter)
	}
}

type mArtifactPublicServiceClientMockCreateConversation struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockCreateConversationExpectation
	expectations       []*ArtifactPublicServiceClientMockCreateConversationExpectation

	callArgs []*ArtifactPublicServiceClientMockCreateConversationParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ArtifactPublicServiceClientMockCreateConversationExpectation specifies expectation struct of the ArtifactPublicServiceClient.CreateConversation
type ArtifactPublicServiceClientMockCreateConversationExpectation struct {
	mock      *ArtifactPublicServiceClientMock
	params    *ArtifactPublicServiceClientMockCreateConversationParams
	paramPtrs *ArtifactPublicServiceClientMockCreateConversationParamPtrs
	results   *ArtifactPublicServiceClientMockCreateConversationResults
	Counter   uint64
}

// ArtifactPublicServiceClientMockCreateConversationParams contains parameters of the ArtifactPublicServiceClient.CreateConversation
type ArtifactPublicServiceClientMockCreateConversationParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.CreateConversationRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockCreateConversationParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.CreateConversation
type ArtifactPublicServiceClientMockCreateConversationParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.CreateConversationRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockCreateConversationResults contains results of the ArtifactPublicServiceClient.CreateConversation
type ArtifactPublicServiceClientMockCreateConversationResults struct {
	cp1 *mm_artifactv1alpha.CreateConversationResponse
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateConversation *mArtifactPublicServiceClientMockCreateConversation) Optional() *mArtifactPublicServiceClientMockCreateConversation {
	mmCreateConversation.optional = true
	return mmCreateConversation
}

// Expect sets up expected params for ArtifactPublicServiceClient.CreateConversation
func (mmCreateConversation *mArtifactPublicServiceClientMockCreateConversation) Expect(ctx context.Context, in *mm_artifactv1alpha.CreateConversationRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockCreateConversation {
	if mmCreateConversation.mock.funcCreateConversation != nil {
		mmCreateConversation.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateConversation mock is already set by Set")
	}

	if mmCreateConversation.defaultExpectation == nil {
		mmCreateConversation.defaultExpectation = &ArtifactPublicServiceClientMockCreateConversationExpectation{}
	}

	if mmCreateConversation.defaultExpectation.paramPtrs != nil {
		mmCreateConversation.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateConversation mock is already set by ExpectParams functions")
	}

	mmCreateConversation.defaultExpectation.params = &ArtifactPublicServiceClientMockCreateConversationParams{ctx, in, opts}
	for _, e := range mmCreateConversation.expectations {
		if minimock.Equal(e.params, mmCreateConversation.defaultExpectation.params) {
			mmCreateConversation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateConversation.defaultExpectation.params)
		}
	}

	return mmCreateConversation
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.CreateConversation
func (mmCreateConversation *mArtifactPublicServiceClientMockCreateConversation) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockCreateConversation {
	if mmCreateConversation.mock.funcCreateConversation != nil {
		mmCreateConversation.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateConversation mock is already set by Set")
	}

	if mmCreateConversation.defaultExpectation == nil {
		mmCreateConversation.defaultExpectation = &ArtifactPublicServiceClientMockCreateConversationExpectation{}
	}

	if mmCreateConversation.defaultExpectation.params != nil {
		mmCreateConversation.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateConversation mock is already set by Expect")
	}

	if mmCreateConversation.defaultExpectation.paramPtrs == nil {
		mmCreateConversation.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockCreateConversationParamPtrs{}
	}
	mmCreateConversation.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateConversation
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.CreateConversation
func (mmCreateConversation *mArtifactPublicServiceClientMockCreateConversation) ExpectInParam2(in *mm_artifactv1alpha.CreateConversationRequest) *mArtifactPublicServiceClientMockCreateConversation {
	if mmCreateConversation.mock.funcCreateConversation != nil {
		mmCreateConversation.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateConversation mock is already set by Set")
	}

	if mmCreateConversation.defaultExpectation == nil {
		mmCreateConversation.defaultExpectation = &ArtifactPublicServiceClientMockCreateConversationExpectation{}
	}

	if mmCreateConversation.defaultExpectation.params != nil {
		mmCreateConversation.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateConversation mock is already set by Expect")
	}

	if mmCreateConversation.defaultExpectation.paramPtrs == nil {
		mmCreateConversation.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockCreateConversationParamPtrs{}
	}
	mmCreateConversation.defaultExpectation.paramPtrs.in = &in

	return mmCreateConversation
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.CreateConversation
func (mmCreateConversation *mArtifactPublicServiceClientMockCreateConversation) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockCreateConversation {
	if mmCreateConversation.mock.funcCreateConversation != nil {
		mmCreateConversation.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateConversation mock is already set by Set")
	}

	if mmCreateConversation.defaultExpectation == nil {
		mmCreateConversation.defaultExpectation = &ArtifactPublicServiceClientMockCreateConversationExpectation{}
	}

	if mmCreateConversation.defaultExpectation.params != nil {
		mmCreateConversation.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateConversation mock is already set by Expect")
	}

	if mmCreateConversation.defaultExpectation.paramPtrs == nil {
		mmCreateConversation.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockCreateConversationParamPtrs{}
	}
	mmCreateConversation.defaultExpectation.paramPtrs.opts = &opts

	return mmCreateConversation
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.CreateConversation
func (mmCreateConversation *mArtifactPublicServiceClientMockCreateConversation) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.CreateConversationRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockCreateConversation {
	if mmCreateConversation.mock.inspectFuncCreateConversation != nil {
		mmCreateConversation.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.CreateConversation")
	}

	mmCreateConversation.mock.inspectFuncCreateConversation = f

	return mmCreateConversation
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.CreateConversation
func (mmCreateConversation *mArtifactPublicServiceClientMockCreateConversation) Return(cp1 *mm_artifactv1alpha.CreateConversationResponse, err error) *ArtifactPublicServiceClientMock {
	if mmCreateConversation.mock.funcCreateConversation != nil {
		mmCreateConversation.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateConversation mock is already set by Set")
	}

	if mmCreateConversation.defaultExpectation == nil {
		mmCreateConversation.defaultExpectation = &ArtifactPublicServiceClientMockCreateConversationExpectation{mock: mmCreateConversation.mock}
	}
	mmCreateConversation.defaultExpectation.results = &ArtifactPublicServiceClientMockCreateConversationResults{cp1, err}
	return mmCreateConversation.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.CreateConversation method
func (mmCreateConversation *mArtifactPublicServiceClientMockCreateConversation) Set(f func(ctx context.Context, in *mm_artifactv1alpha.CreateConversationRequest, opts ...grpc.CallOption) (cp1 *mm_artifactv1alpha.CreateConversationResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmCreateConversation.defaultExpectation != nil {
		mmCreateConversation.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.CreateConversation method")
	}

	if len(mmCreateConversation.expectations) > 0 {
		mmCreateConversation.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.CreateConversation method")
	}

	mmCreateConversation.mock.funcCreateConversation = f
	return mmCreateConversation.mock
}

// When sets expectation for the ArtifactPublicServiceClient.CreateConversation which will trigger the result defined by the following
// Then helper
func (mmCreateConversation *mArtifactPublicServiceClientMockCreateConversation) When(ctx context.Context, in *mm_artifactv1alpha.CreateConversationRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockCreateConversationExpectation {
	if mmCreateConversation.mock.funcCreateConversation != nil {
		mmCreateConversation.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateConversation mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockCreateConversationExpectation{
		mock:   mmCreateConversation.mock,
		params: &ArtifactPublicServiceClientMockCreateConversationParams{ctx, in, opts},
	}
	mmCreateConversation.expectations = append(mmCreateConversation.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.CreateConversation return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockCreateConversationExpectation) Then(cp1 *mm_artifactv1alpha.CreateConversationResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockCreateConversationResults{cp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.CreateConversation should be invoked
func (mmCreateConversation *mArtifactPublicServiceClientMockCreateConversation) Times(n uint64) *mArtifactPublicServiceClientMockCreateConversation {
	if n == 0 {
		mmCreateConversation.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.CreateConversation mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateConversation.expectedInvocations, n)
	return mmCreateConversation
}

func (mmCreateConversation *mArtifactPublicServiceClientMockCreateConversation) invocationsDone() bool {
	if len(mmCreateConversation.expectations) == 0 && mmCreateConversation.defaultExpectation == nil && mmCreateConversation.mock.funcCreateConversation == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateConversation.mock.afterCreateConversationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateConversation.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateConversation implements artifactv1alpha.ArtifactPublicServiceClient
func (mmCreateConversation *ArtifactPublicServiceClientMock) CreateConversation(ctx context.Context, in *mm_artifactv1alpha.CreateConversationRequest, opts ...grpc.CallOption) (cp1 *mm_artifactv1alpha.CreateConversationResponse, err error) {
	mm_atomic.AddUint64(&mmCreateConversation.beforeCreateConversationCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateConversation.afterCreateConversationCounter, 1)

	if mmCreateConversation.inspectFuncCreateConversation != nil {
		mmCreateConversation.inspectFuncCreateConversation(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockCreateConversationParams{ctx, in, opts}

	// Record call args
	mmCreateConversation.CreateConversationMock.mutex.Lock()
	mmCreateConversation.CreateConversationMock.callArgs = append(mmCreateConversation.CreateConversationMock.callArgs, &mm_params)
	mmCreateConversation.CreateConversationMock.mutex.Unlock()

	for _, e := range mmCreateConversation.CreateConversationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmCreateConversation.CreateConversationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateConversation.CreateConversationMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateConversation.CreateConversationMock.defaultExpectation.params
		mm_want_ptrs := mmCreateConversation.CreateConversationMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockCreateConversationParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateConversation.t.Errorf("ArtifactPublicServiceClientMock.CreateConversation got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmCreateConversation.t.Errorf("ArtifactPublicServiceClientMock.CreateConversation got unexpected parameter in, want: %#v, got: %#v%s\n", *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmCreateConversation.t.Errorf("ArtifactPublicServiceClientMock.CreateConversation got unexpected parameter opts, want: %#v, got: %#v%s\n", *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateConversation.t.Errorf("ArtifactPublicServiceClientMock.CreateConversation got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateConversation.CreateConversationMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateConversation.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.CreateConversation")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmCreateConversation.funcCreateConversation != nil {
		return mmCreateConversation.funcCreateConversation(ctx, in, opts...)
	}
	mmCreateConversation.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.CreateConversation. %v %v %v", ctx, in, opts)
	return
}

// CreateConversationAfterCounter returns a count of finished ArtifactPublicServiceClientMock.CreateConversation invocations
func (mmCreateConversation *ArtifactPublicServiceClientMock) CreateConversationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateConversation.afterCreateConversationCounter)
}

// CreateConversationBeforeCounter returns a count of ArtifactPublicServiceClientMock.CreateConversation invocations
func (mmCreateConversation *ArtifactPublicServiceClientMock) CreateConversationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateConversation.beforeCreateConversationCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.CreateConversation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateConversation *mArtifactPublicServiceClientMockCreateConversation) Calls() []*ArtifactPublicServiceClientMockCreateConversationParams {
	mmCreateConversation.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockCreateConversationParams, len(mmCreateConversation.callArgs))
	copy(argCopy, mmCreateConversation.callArgs)

	mmCreateConversation.mutex.RUnlock()

	return argCopy
}

// MinimockCreateConversationDone returns true if the count of the CreateConversation invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockCreateConversationDone() bool {
	if m.CreateConversationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateConversationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateConversationMock.invocationsDone()
}

// MinimockCreateConversationInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockCreateConversationInspect() {
	for _, e := range m.CreateConversationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.CreateConversation with params: %#v", *e.params)
		}
	}

	afterCreateConversationCounter := mm_atomic.LoadUint64(&m.afterCreateConversationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateConversationMock.defaultExpectation != nil && afterCreateConversationCounter < 1 {
		if m.CreateConversationMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ArtifactPublicServiceClientMock.CreateConversation")
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.CreateConversation with params: %#v", *m.CreateConversationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateConversation != nil && afterCreateConversationCounter < 1 {
		m.t.Error("Expected call to ArtifactPublicServiceClientMock.CreateConversation")
	}

	if !m.CreateConversationMock.invocationsDone() && afterCreateConversationCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.CreateConversation but found %d calls",
			mm_atomic.LoadUint64(&m.CreateConversationMock.expectedInvocations), afterCreateConversationCounter)
	}
}

type mArtifactPublicServiceClientMockCreateMessage struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockCreateMessageExpectation
	expectations       []*ArtifactPublicServiceClientMockCreateMessageExpectation

	callArgs []*ArtifactPublicServiceClientMockCreateMessageParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ArtifactPublicServiceClientMockCreateMessageExpectation specifies expectation struct of the ArtifactPublicServiceClient.CreateMessage
type ArtifactPublicServiceClientMockCreateMessageExpectation struct {
	mock      *ArtifactPublicServiceClientMock
	params    *ArtifactPublicServiceClientMockCreateMessageParams
	paramPtrs *ArtifactPublicServiceClientMockCreateMessageParamPtrs
	results   *ArtifactPublicServiceClientMockCreateMessageResults
	Counter   uint64
}

// ArtifactPublicServiceClientMockCreateMessageParams contains parameters of the ArtifactPublicServiceClient.CreateMessage
type ArtifactPublicServiceClientMockCreateMessageParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.CreateMessageRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockCreateMessageParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.CreateMessage
type ArtifactPublicServiceClientMockCreateMessageParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.CreateMessageRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockCreateMessageResults contains results of the ArtifactPublicServiceClient.CreateMessage
type ArtifactPublicServiceClientMockCreateMessageResults struct {
	cp1 *mm_artifactv1alpha.CreateMessageResponse
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateMessage *mArtifactPublicServiceClientMockCreateMessage) Optional() *mArtifactPublicServiceClientMockCreateMessage {
	mmCreateMessage.optional = true
	return mmCreateMessage
}

// Expect sets up expected params for ArtifactPublicServiceClient.CreateMessage
func (mmCreateMessage *mArtifactPublicServiceClientMockCreateMessage) Expect(ctx context.Context, in *mm_artifactv1alpha.CreateMessageRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockCreateMessage {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateMessage mock is already set by Set")
	}

	if mmCreateMessage.defaultExpectation == nil {
		mmCreateMessage.defaultExpectation = &ArtifactPublicServiceClientMockCreateMessageExpectation{}
	}

	if mmCreateMessage.defaultExpectation.paramPtrs != nil {
		mmCreateMessage.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateMessage mock is already set by ExpectParams functions")
	}

	mmCreateMessage.defaultExpectation.params = &ArtifactPublicServiceClientMockCreateMessageParams{ctx, in, opts}
	for _, e := range mmCreateMessage.expectations {
		if minimock.Equal(e.params, mmCreateMessage.defaultExpectation.params) {
			mmCreateMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateMessage.defaultExpectation.params)
		}
	}

	return mmCreateMessage
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.CreateMessage
func (mmCreateMessage *mArtifactPublicServiceClientMockCreateMessage) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockCreateMessage {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateMessage mock is already set by Set")
	}

	if mmCreateMessage.defaultExpectation == nil {
		mmCreateMessage.defaultExpectation = &ArtifactPublicServiceClientMockCreateMessageExpectation{}
	}

	if mmCreateMessage.defaultExpectation.params != nil {
		mmCreateMessage.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateMessage mock is already set by Expect")
	}

	if mmCreateMessage.defaultExpectation.paramPtrs == nil {
		mmCreateMessage.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockCreateMessageParamPtrs{}
	}
	mmCreateMessage.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateMessage
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.CreateMessage
func (mmCreateMessage *mArtifactPublicServiceClientMockCreateMessage) ExpectInParam2(in *mm_artifactv1alpha.CreateMessageRequest) *mArtifactPublicServiceClientMockCreateMessage {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateMessage mock is already set by Set")
	}

	if mmCreateMessage.defaultExpectation == nil {
		mmCreateMessage.defaultExpectation = &ArtifactPublicServiceClientMockCreateMessageExpectation{}
	}

	if mmCreateMessage.defaultExpectation.params != nil {
		mmCreateMessage.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateMessage mock is already set by Expect")
	}

	if mmCreateMessage.defaultExpectation.paramPtrs == nil {
		mmCreateMessage.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockCreateMessageParamPtrs{}
	}
	mmCreateMessage.defaultExpectation.paramPtrs.in = &in

	return mmCreateMessage
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.CreateMessage
func (mmCreateMessage *mArtifactPublicServiceClientMockCreateMessage) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockCreateMessage {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateMessage mock is already set by Set")
	}

	if mmCreateMessage.defaultExpectation == nil {
		mmCreateMessage.defaultExpectation = &ArtifactPublicServiceClientMockCreateMessageExpectation{}
	}

	if mmCreateMessage.defaultExpectation.params != nil {
		mmCreateMessage.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateMessage mock is already set by Expect")
	}

	if mmCreateMessage.defaultExpectation.paramPtrs == nil {
		mmCreateMessage.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockCreateMessageParamPtrs{}
	}
	mmCreateMessage.defaultExpectation.paramPtrs.opts = &opts

	return mmCreateMessage
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.CreateMessage
func (mmCreateMessage *mArtifactPublicServiceClientMockCreateMessage) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.CreateMessageRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockCreateMessage {
	if mmCreateMessage.mock.inspectFuncCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.CreateMessage")
	}

	mmCreateMessage.mock.inspectFuncCreateMessage = f

	return mmCreateMessage
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.CreateMessage
func (mmCreateMessage *mArtifactPublicServiceClientMockCreateMessage) Return(cp1 *mm_artifactv1alpha.CreateMessageResponse, err error) *ArtifactPublicServiceClientMock {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateMessage mock is already set by Set")
	}

	if mmCreateMessage.defaultExpectation == nil {
		mmCreateMessage.defaultExpectation = &ArtifactPublicServiceClientMockCreateMessageExpectation{mock: mmCreateMessage.mock}
	}
	mmCreateMessage.defaultExpectation.results = &ArtifactPublicServiceClientMockCreateMessageResults{cp1, err}
	return mmCreateMessage.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.CreateMessage method
func (mmCreateMessage *mArtifactPublicServiceClientMockCreateMessage) Set(f func(ctx context.Context, in *mm_artifactv1alpha.CreateMessageRequest, opts ...grpc.CallOption) (cp1 *mm_artifactv1alpha.CreateMessageResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmCreateMessage.defaultExpectation != nil {
		mmCreateMessage.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.CreateMessage method")
	}

	if len(mmCreateMessage.expectations) > 0 {
		mmCreateMessage.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.CreateMessage method")
	}

	mmCreateMessage.mock.funcCreateMessage = f
	return mmCreateMessage.mock
}

// When sets expectation for the ArtifactPublicServiceClient.CreateMessage which will trigger the result defined by the following
// Then helper
func (mmCreateMessage *mArtifactPublicServiceClientMockCreateMessage) When(ctx context.Context, in *mm_artifactv1alpha.CreateMessageRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockCreateMessageExpectation {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateMessage mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockCreateMessageExpectation{
		mock:   mmCreateMessage.mock,
		params: &ArtifactPublicServiceClientMockCreateMessageParams{ctx, in, opts},
	}
	mmCreateMessage.expectations = append(mmCreateMessage.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.CreateMessage return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockCreateMessageExpectation) Then(cp1 *mm_artifactv1alpha.CreateMessageResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockCreateMessageResults{cp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.CreateMessage should be invoked
func (mmCreateMessage *mArtifactPublicServiceClientMockCreateMessage) Times(n uint64) *mArtifactPublicServiceClientMockCreateMessage {
	if n == 0 {
		mmCreateMessage.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.CreateMessage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateMessage.expectedInvocations, n)
	return mmCreateMessage
}

func (mmCreateMessage *mArtifactPublicServiceClientMockCreateMessage) invocationsDone() bool {
	if len(mmCreateMessage.expectations) == 0 && mmCreateMessage.defaultExpectation == nil && mmCreateMessage.mock.funcCreateMessage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateMessage.mock.afterCreateMessageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateMessage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateMessage implements artifactv1alpha.ArtifactPublicServiceClient
func (mmCreateMessage *ArtifactPublicServiceClientMock) CreateMessage(ctx context.Context, in *mm_artifactv1alpha.CreateMessageRequest, opts ...grpc.CallOption) (cp1 *mm_artifactv1alpha.CreateMessageResponse, err error) {
	mm_atomic.AddUint64(&mmCreateMessage.beforeCreateMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateMessage.afterCreateMessageCounter, 1)

	if mmCreateMessage.inspectFuncCreateMessage != nil {
		mmCreateMessage.inspectFuncCreateMessage(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockCreateMessageParams{ctx, in, opts}

	// Record call args
	mmCreateMessage.CreateMessageMock.mutex.Lock()
	mmCreateMessage.CreateMessageMock.callArgs = append(mmCreateMessage.CreateMessageMock.callArgs, &mm_params)
	mmCreateMessage.CreateMessageMock.mutex.Unlock()

	for _, e := range mmCreateMessage.CreateMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmCreateMessage.CreateMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateMessage.CreateMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateMessage.CreateMessageMock.defaultExpectation.params
		mm_want_ptrs := mmCreateMessage.CreateMessageMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockCreateMessageParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateMessage.t.Errorf("ArtifactPublicServiceClientMock.CreateMessage got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmCreateMessage.t.Errorf("ArtifactPublicServiceClientMock.CreateMessage got unexpected parameter in, want: %#v, got: %#v%s\n", *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmCreateMessage.t.Errorf("ArtifactPublicServiceClientMock.CreateMessage got unexpected parameter opts, want: %#v, got: %#v%s\n", *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateMessage.t.Errorf("ArtifactPublicServiceClientMock.CreateMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateMessage.CreateMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateMessage.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.CreateMessage")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmCreateMessage.funcCreateMessage != nil {
		return mmCreateMessage.funcCreateMessage(ctx, in, opts...)
	}
	mmCreateMessage.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.CreateMessage. %v %v %v", ctx, in, opts)
	return
}

// CreateMessageAfterCounter returns a count of finished ArtifactPublicServiceClientMock.CreateMessage invocations
func (mmCreateMessage *ArtifactPublicServiceClientMock) CreateMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateMessage.afterCreateMessageCounter)
}

// CreateMessageBeforeCounter returns a count of ArtifactPublicServiceClientMock.CreateMessage invocations
func (mmCreateMessage *ArtifactPublicServiceClientMock) CreateMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateMessage.beforeCreateMessageCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.CreateMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateMessage *mArtifactPublicServiceClientMockCreateMessage) Calls() []*ArtifactPublicServiceClientMockCreateMessageParams {
	mmCreateMessage.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockCreateMessageParams, len(mmCreateMessage.callArgs))
	copy(argCopy, mmCreateMessage.callArgs)

	mmCreateMessage.mutex.RUnlock()

	return argCopy
}

// MinimockCreateMessageDone returns true if the count of the CreateMessage invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockCreateMessageDone() bool {
	if m.CreateMessageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMessageMock.invocationsDone()
}

// MinimockCreateMessageInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockCreateMessageInspect() {
	for _, e := range m.CreateMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.CreateMessage with params: %#v", *e.params)
		}
	}

	afterCreateMessageCounter := mm_atomic.LoadUint64(&m.afterCreateMessageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMessageMock.defaultExpectation != nil && afterCreateMessageCounter < 1 {
		if m.CreateMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ArtifactPublicServiceClientMock.CreateMessage")
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.CreateMessage with params: %#v", *m.CreateMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateMessage != nil && afterCreateMessageCounter < 1 {
		m.t.Error("Expected call to ArtifactPublicServiceClientMock.CreateMessage")
	}

	if !m.CreateMessageMock.invocationsDone() && afterCreateMessageCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.CreateMessage but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMessageMock.expectedInvocations), afterCreateMessageCounter)
	}
}

type mArtifactPublicServiceClientMockDeleteCatalog struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockDeleteCatalogExpectation
	expectations       []*ArtifactPublicServiceClientMockDeleteCatalogExpectation

	callArgs []*ArtifactPublicServiceClientMockDeleteCatalogParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ArtifactPublicServiceClientMockDeleteCatalogExpectation specifies expectation struct of the ArtifactPublicServiceClient.DeleteCatalog
type ArtifactPublicServiceClientMockDeleteCatalogExpectation struct {
	mock      *ArtifactPublicServiceClientMock
	params    *ArtifactPublicServiceClientMockDeleteCatalogParams
	paramPtrs *ArtifactPublicServiceClientMockDeleteCatalogParamPtrs
	results   *ArtifactPublicServiceClientMockDeleteCatalogResults
	Counter   uint64
}

// ArtifactPublicServiceClientMockDeleteCatalogParams contains parameters of the ArtifactPublicServiceClient.DeleteCatalog
type ArtifactPublicServiceClientMockDeleteCatalogParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.DeleteCatalogRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockDeleteCatalogParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.DeleteCatalog
type ArtifactPublicServiceClientMockDeleteCatalogParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.DeleteCatalogRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockDeleteCatalogResults contains results of the ArtifactPublicServiceClient.DeleteCatalog
type ArtifactPublicServiceClientMockDeleteCatalogResults struct {
	dp1 *mm_artifactv1alpha.DeleteCatalogResponse
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteCatalog *mArtifactPublicServiceClientMockDeleteCatalog) Optional() *mArtifactPublicServiceClientMockDeleteCatalog {
	mmDeleteCatalog.optional = true
	return mmDeleteCatalog
}

// Expect sets up expected params for ArtifactPublicServiceClient.DeleteCatalog
func (mmDeleteCatalog *mArtifactPublicServiceClientMockDeleteCatalog) Expect(ctx context.Context, in *mm_artifactv1alpha.DeleteCatalogRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockDeleteCatalog {
	if mmDeleteCatalog.mock.funcDeleteCatalog != nil {
		mmDeleteCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalog mock is already set by Set")
	}

	if mmDeleteCatalog.defaultExpectation == nil {
		mmDeleteCatalog.defaultExpectation = &ArtifactPublicServiceClientMockDeleteCatalogExpectation{}
	}

	if mmDeleteCatalog.defaultExpectation.paramPtrs != nil {
		mmDeleteCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalog mock is already set by ExpectParams functions")
	}

	mmDeleteCatalog.defaultExpectation.params = &ArtifactPublicServiceClientMockDeleteCatalogParams{ctx, in, opts}
	for _, e := range mmDeleteCatalog.expectations {
		if minimock.Equal(e.params, mmDeleteCatalog.defaultExpectation.params) {
			mmDeleteCatalog.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteCatalog.defaultExpectation.params)
		}
	}

	return mmDeleteCatalog
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.DeleteCatalog
func (mmDeleteCatalog *mArtifactPublicServiceClientMockDeleteCatalog) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockDeleteCatalog {
	if mmDeleteCatalog.mock.funcDeleteCatalog != nil {
		mmDeleteCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalog mock is already set by Set")
	}

	if mmDeleteCatalog.defaultExpectation == nil {
		mmDeleteCatalog.defaultExpectation = &ArtifactPublicServiceClientMockDeleteCatalogExpectation{}
	}

	if mmDeleteCatalog.defaultExpectation.params != nil {
		mmDeleteCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalog mock is already set by Expect")
	}

	if mmDeleteCatalog.defaultExpectation.paramPtrs == nil {
		mmDeleteCatalog.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockDeleteCatalogParamPtrs{}
	}
	mmDeleteCatalog.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteCatalog
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.DeleteCatalog
func (mmDeleteCatalog *mArtifactPublicServiceClientMockDeleteCatalog) ExpectInParam2(in *mm_artifactv1alpha.DeleteCatalogRequest) *mArtifactPublicServiceClientMockDeleteCatalog {
	if mmDeleteCatalog.mock.funcDeleteCatalog != nil {
		mmDeleteCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalog mock is already set by Set")
	}

	if mmDeleteCatalog.defaultExpectation == nil {
		mmDeleteCatalog.defaultExpectation = &ArtifactPublicServiceClientMockDeleteCatalogExpectation{}
	}

	if mmDeleteCatalog.defaultExpectation.params != nil {
		mmDeleteCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalog mock is already set by Expect")
	}

	if mmDeleteCatalog.defaultExpectation.paramPtrs == nil {
		mmDeleteCatalog.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockDeleteCatalogParamPtrs{}
	}
	mmDeleteCatalog.defaultExpectation.paramPtrs.in = &in

	return mmDeleteCatalog
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.DeleteCatalog
func (mmDeleteCatalog *mArtifactPublicServiceClientMockDeleteCatalog) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockDeleteCatalog {
	if mmDeleteCatalog.mock.funcDeleteCatalog != nil {
		mmDeleteCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalog mock is already set by Set")
	}

	if mmDeleteCatalog.defaultExpectation == nil {
		mmDeleteCatalog.defaultExpectation = &ArtifactPublicServiceClientMockDeleteCatalogExpectation{}
	}

	if mmDeleteCatalog.defaultExpectation.params != nil {
		mmDeleteCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalog mock is already set by Expect")
	}

	if mmDeleteCatalog.defaultExpectation.paramPtrs == nil {
		mmDeleteCatalog.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockDeleteCatalogParamPtrs{}
	}
	mmDeleteCatalog.defaultExpectation.paramPtrs.opts = &opts

	return mmDeleteCatalog
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.DeleteCatalog
func (mmDeleteCatalog *mArtifactPublicServiceClientMockDeleteCatalog) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.DeleteCatalogRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockDeleteCatalog {
	if mmDeleteCatalog.mock.inspectFuncDeleteCatalog != nil {
		mmDeleteCatalog.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.DeleteCatalog")
	}

	mmDeleteCatalog.mock.inspectFuncDeleteCatalog = f

	return mmDeleteCatalog
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.DeleteCatalog
func (mmDeleteCatalog *mArtifactPublicServiceClientMockDeleteCatalog) Return(dp1 *mm_artifactv1alpha.DeleteCatalogResponse, err error) *ArtifactPublicServiceClientMock {
	if mmDeleteCatalog.mock.funcDeleteCatalog != nil {
		mmDeleteCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalog mock is already set by Set")
	}

	if mmDeleteCatalog.defaultExpectation == nil {
		mmDeleteCatalog.defaultExpectation = &ArtifactPublicServiceClientMockDeleteCatalogExpectation{mock: mmDeleteCatalog.mock}
	}
	mmDeleteCatalog.defaultExpectation.results = &ArtifactPublicServiceClientMockDeleteCatalogResults{dp1, err}
	return mmDeleteCatalog.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.DeleteCatalog method
func (mmDeleteCatalog *mArtifactPublicServiceClientMockDeleteCatalog) Set(f func(ctx context.Context, in *mm_artifactv1alpha.DeleteCatalogRequest, opts ...grpc.CallOption) (dp1 *mm_artifactv1alpha.DeleteCatalogResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmDeleteCatalog.defaultExpectation != nil {
		mmDeleteCatalog.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.DeleteCatalog method")
	}

	if len(mmDeleteCatalog.expectations) > 0 {
		mmDeleteCatalog.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.DeleteCatalog method")
	}

	mmDeleteCatalog.mock.funcDeleteCatalog = f
	return mmDeleteCatalog.mock
}

// When sets expectation for the ArtifactPublicServiceClient.DeleteCatalog which will trigger the result defined by the following
// Then helper
func (mmDeleteCatalog *mArtifactPublicServiceClientMockDeleteCatalog) When(ctx context.Context, in *mm_artifactv1alpha.DeleteCatalogRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockDeleteCatalogExpectation {
	if mmDeleteCatalog.mock.funcDeleteCatalog != nil {
		mmDeleteCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalog mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockDeleteCatalogExpectation{
		mock:   mmDeleteCatalog.mock,
		params: &ArtifactPublicServiceClientMockDeleteCatalogParams{ctx, in, opts},
	}
	mmDeleteCatalog.expectations = append(mmDeleteCatalog.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.DeleteCatalog return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockDeleteCatalogExpectation) Then(dp1 *mm_artifactv1alpha.DeleteCatalogResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockDeleteCatalogResults{dp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.DeleteCatalog should be invoked
func (mmDeleteCatalog *mArtifactPublicServiceClientMockDeleteCatalog) Times(n uint64) *mArtifactPublicServiceClientMockDeleteCatalog {
	if n == 0 {
		mmDeleteCatalog.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.DeleteCatalog mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteCatalog.expectedInvocations, n)
	return mmDeleteCatalog
}

func (mmDeleteCatalog *mArtifactPublicServiceClientMockDeleteCatalog) invocationsDone() bool {
	if len(mmDeleteCatalog.expectations) == 0 && mmDeleteCatalog.defaultExpectation == nil && mmDeleteCatalog.mock.funcDeleteCatalog == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteCatalog.mock.afterDeleteCatalogCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteCatalog.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteCatalog implements artifactv1alpha.ArtifactPublicServiceClient
func (mmDeleteCatalog *ArtifactPublicServiceClientMock) DeleteCatalog(ctx context.Context, in *mm_artifactv1alpha.DeleteCatalogRequest, opts ...grpc.CallOption) (dp1 *mm_artifactv1alpha.DeleteCatalogResponse, err error) {
	mm_atomic.AddUint64(&mmDeleteCatalog.beforeDeleteCatalogCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteCatalog.afterDeleteCatalogCounter, 1)

	if mmDeleteCatalog.inspectFuncDeleteCatalog != nil {
		mmDeleteCatalog.inspectFuncDeleteCatalog(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockDeleteCatalogParams{ctx, in, opts}

	// Record call args
	mmDeleteCatalog.DeleteCatalogMock.mutex.Lock()
	mmDeleteCatalog.DeleteCatalogMock.callArgs = append(mmDeleteCatalog.DeleteCatalogMock.callArgs, &mm_params)
	mmDeleteCatalog.DeleteCatalogMock.mutex.Unlock()

	for _, e := range mmDeleteCatalog.DeleteCatalogMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp1, e.results.err
		}
	}

	if mmDeleteCatalog.DeleteCatalogMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteCatalog.DeleteCatalogMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteCatalog.DeleteCatalogMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteCatalog.DeleteCatalogMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockDeleteCatalogParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteCatalog.t.Errorf("ArtifactPublicServiceClientMock.DeleteCatalog got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmDeleteCatalog.t.Errorf("ArtifactPublicServiceClientMock.DeleteCatalog got unexpected parameter in, want: %#v, got: %#v%s\n", *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmDeleteCatalog.t.Errorf("ArtifactPublicServiceClientMock.DeleteCatalog got unexpected parameter opts, want: %#v, got: %#v%s\n", *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteCatalog.t.Errorf("ArtifactPublicServiceClientMock.DeleteCatalog got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteCatalog.DeleteCatalogMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteCatalog.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.DeleteCatalog")
		}
		return (*mm_results).dp1, (*mm_results).err
	}
	if mmDeleteCatalog.funcDeleteCatalog != nil {
		return mmDeleteCatalog.funcDeleteCatalog(ctx, in, opts...)
	}
	mmDeleteCatalog.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.DeleteCatalog. %v %v %v", ctx, in, opts)
	return
}

// DeleteCatalogAfterCounter returns a count of finished ArtifactPublicServiceClientMock.DeleteCatalog invocations
func (mmDeleteCatalog *ArtifactPublicServiceClientMock) DeleteCatalogAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCatalog.afterDeleteCatalogCounter)
}

// DeleteCatalogBeforeCounter returns a count of ArtifactPublicServiceClientMock.DeleteCatalog invocations
func (mmDeleteCatalog *ArtifactPublicServiceClientMock) DeleteCatalogBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCatalog.beforeDeleteCatalogCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.DeleteCatalog.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteCatalog *mArtifactPublicServiceClientMockDeleteCatalog) Calls() []*ArtifactPublicServiceClientMockDeleteCatalogParams {
	mmDeleteCatalog.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockDeleteCatalogParams, len(mmDeleteCatalog.callArgs))
	copy(argCopy, mmDeleteCatalog.callArgs)

	mmDeleteCatalog.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteCatalogDone returns true if the count of the DeleteCatalog invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockDeleteCatalogDone() bool {
	if m.DeleteCatalogMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteCatalogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteCatalogMock.invocationsDone()
}

// MinimockDeleteCatalogInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockDeleteCatalogInspect() {
	for _, e := range m.DeleteCatalogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.DeleteCatalog with params: %#v", *e.params)
		}
	}

	afterDeleteCatalogCounter := mm_atomic.LoadUint64(&m.afterDeleteCatalogCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteCatalogMock.defaultExpectation != nil && afterDeleteCatalogCounter < 1 {
		if m.DeleteCatalogMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ArtifactPublicServiceClientMock.DeleteCatalog")
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.DeleteCatalog with params: %#v", *m.DeleteCatalogMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteCatalog != nil && afterDeleteCatalogCounter < 1 {
		m.t.Error("Expected call to ArtifactPublicServiceClientMock.DeleteCatalog")
	}

	if !m.DeleteCatalogMock.invocationsDone() && afterDeleteCatalogCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.DeleteCatalog but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteCatalogMock.expectedInvocations), afterDeleteCatalogCounter)
	}
}

type mArtifactPublicServiceClientMockDeleteCatalogFile struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockDeleteCatalogFileExpectation
	expectations       []*ArtifactPublicServiceClientMockDeleteCatalogFileExpectation

	callArgs []*ArtifactPublicServiceClientMockDeleteCatalogFileParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ArtifactPublicServiceClientMockDeleteCatalogFileExpectation specifies expectation struct of the ArtifactPublicServiceClient.DeleteCatalogFile
type ArtifactPublicServiceClientMockDeleteCatalogFileExpectation struct {
	mock      *ArtifactPublicServiceClientMock
	params    *ArtifactPublicServiceClientMockDeleteCatalogFileParams
	paramPtrs *ArtifactPublicServiceClientMockDeleteCatalogFileParamPtrs
	results   *ArtifactPublicServiceClientMockDeleteCatalogFileResults
	Counter   uint64
}

// ArtifactPublicServiceClientMockDeleteCatalogFileParams contains parameters of the ArtifactPublicServiceClient.DeleteCatalogFile
type ArtifactPublicServiceClientMockDeleteCatalogFileParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.DeleteCatalogFileRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockDeleteCatalogFileParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.DeleteCatalogFile
type ArtifactPublicServiceClientMockDeleteCatalogFileParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.DeleteCatalogFileRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockDeleteCatalogFileResults contains results of the ArtifactPublicServiceClient.DeleteCatalogFile
type ArtifactPublicServiceClientMockDeleteCatalogFileResults struct {
	dp1 *mm_artifactv1alpha.DeleteCatalogFileResponse
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteCatalogFile *mArtifactPublicServiceClientMockDeleteCatalogFile) Optional() *mArtifactPublicServiceClientMockDeleteCatalogFile {
	mmDeleteCatalogFile.optional = true
	return mmDeleteCatalogFile
}

// Expect sets up expected params for ArtifactPublicServiceClient.DeleteCatalogFile
func (mmDeleteCatalogFile *mArtifactPublicServiceClientMockDeleteCatalogFile) Expect(ctx context.Context, in *mm_artifactv1alpha.DeleteCatalogFileRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockDeleteCatalogFile {
	if mmDeleteCatalogFile.mock.funcDeleteCatalogFile != nil {
		mmDeleteCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalogFile mock is already set by Set")
	}

	if mmDeleteCatalogFile.defaultExpectation == nil {
		mmDeleteCatalogFile.defaultExpectation = &ArtifactPublicServiceClientMockDeleteCatalogFileExpectation{}
	}

	if mmDeleteCatalogFile.defaultExpectation.paramPtrs != nil {
		mmDeleteCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalogFile mock is already set by ExpectParams functions")
	}

	mmDeleteCatalogFile.defaultExpectation.params = &ArtifactPublicServiceClientMockDeleteCatalogFileParams{ctx, in, opts}
	for _, e := range mmDeleteCatalogFile.expectations {
		if minimock.Equal(e.params, mmDeleteCatalogFile.defaultExpectation.params) {
			mmDeleteCatalogFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteCatalogFile.defaultExpectation.params)
		}
	}

	return mmDeleteCatalogFile
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.DeleteCatalogFile
func (mmDeleteCatalogFile *mArtifactPublicServiceClientMockDeleteCatalogFile) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockDeleteCatalogFile {
	if mmDeleteCatalogFile.mock.funcDeleteCatalogFile != nil {
		mmDeleteCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalogFile mock is already set by Set")
	}

	if mmDeleteCatalogFile.defaultExpectation == nil {
		mmDeleteCatalogFile.defaultExpectation = &ArtifactPublicServiceClientMockDeleteCatalogFileExpectation{}
	}

	if mmDeleteCatalogFile.defaultExpectation.params != nil {
		mmDeleteCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalogFile mock is already set by Expect")
	}

	if mmDeleteCatalogFile.defaultExpectation.paramPtrs == nil {
		mmDeleteCatalogFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockDeleteCatalogFileParamPtrs{}
	}
	mmDeleteCatalogFile.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteCatalogFile
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.DeleteCatalogFile
func (mmDeleteCatalogFile *mArtifactPublicServiceClientMockDeleteCatalogFile) ExpectInParam2(in *mm_artifactv1alpha.DeleteCatalogFileRequest) *mArtifactPublicServiceClientMockDeleteCatalogFile {
	if mmDeleteCatalogFile.mock.funcDeleteCatalogFile != nil {
		mmDeleteCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalogFile mock is already set by Set")
	}

	if mmDeleteCatalogFile.defaultExpectation == nil {
		mmDeleteCatalogFile.defaultExpectation = &ArtifactPublicServiceClientMockDeleteCatalogFileExpectation{}
	}

	if mmDeleteCatalogFile.defaultExpectation.params != nil {
		mmDeleteCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalogFile mock is already set by Expect")
	}

	if mmDeleteCatalogFile.defaultExpectation.paramPtrs == nil {
		mmDeleteCatalogFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockDeleteCatalogFileParamPtrs{}
	}
	mmDeleteCatalogFile.defaultExpectation.paramPtrs.in = &in

	return mmDeleteCatalogFile
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.DeleteCatalogFile
func (mmDeleteCatalogFile *mArtifactPublicServiceClientMockDeleteCatalogFile) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockDeleteCatalogFile {
	if mmDeleteCatalogFile.mock.funcDeleteCatalogFile != nil {
		mmDeleteCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalogFile mock is already set by Set")
	}

	if mmDeleteCatalogFile.defaultExpectation == nil {
		mmDeleteCatalogFile.defaultExpectation = &ArtifactPublicServiceClientMockDeleteCatalogFileExpectation{}
	}

	if mmDeleteCatalogFile.defaultExpectation.params != nil {
		mmDeleteCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalogFile mock is already set by Expect")
	}

	if mmDeleteCatalogFile.defaultExpectation.paramPtrs == nil {
		mmDeleteCatalogFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockDeleteCatalogFileParamPtrs{}
	}
	mmDeleteCatalogFile.defaultExpectation.paramPtrs.opts = &opts

	return mmDeleteCatalogFile
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.DeleteCatalogFile
func (mmDeleteCatalogFile *mArtifactPublicServiceClientMockDeleteCatalogFile) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.DeleteCatalogFileRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockDeleteCatalogFile {
	if mmDeleteCatalogFile.mock.inspectFuncDeleteCatalogFile != nil {
		mmDeleteCatalogFile.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.DeleteCatalogFile")
	}

	mmDeleteCatalogFile.mock.inspectFuncDeleteCatalogFile = f

	return mmDeleteCatalogFile
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.DeleteCatalogFile
func (mmDeleteCatalogFile *mArtifactPublicServiceClientMockDeleteCatalogFile) Return(dp1 *mm_artifactv1alpha.DeleteCatalogFileResponse, err error) *ArtifactPublicServiceClientMock {
	if mmDeleteCatalogFile.mock.funcDeleteCatalogFile != nil {
		mmDeleteCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalogFile mock is already set by Set")
	}

	if mmDeleteCatalogFile.defaultExpectation == nil {
		mmDeleteCatalogFile.defaultExpectation = &ArtifactPublicServiceClientMockDeleteCatalogFileExpectation{mock: mmDeleteCatalogFile.mock}
	}
	mmDeleteCatalogFile.defaultExpectation.results = &ArtifactPublicServiceClientMockDeleteCatalogFileResults{dp1, err}
	return mmDeleteCatalogFile.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.DeleteCatalogFile method
func (mmDeleteCatalogFile *mArtifactPublicServiceClientMockDeleteCatalogFile) Set(f func(ctx context.Context, in *mm_artifactv1alpha.DeleteCatalogFileRequest, opts ...grpc.CallOption) (dp1 *mm_artifactv1alpha.DeleteCatalogFileResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmDeleteCatalogFile.defaultExpectation != nil {
		mmDeleteCatalogFile.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.DeleteCatalogFile method")
	}

	if len(mmDeleteCatalogFile.expectations) > 0 {
		mmDeleteCatalogFile.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.DeleteCatalogFile method")
	}

	mmDeleteCatalogFile.mock.funcDeleteCatalogFile = f
	return mmDeleteCatalogFile.mock
}

// When sets expectation for the ArtifactPublicServiceClient.DeleteCatalogFile which will trigger the result defined by the following
// Then helper
func (mmDeleteCatalogFile *mArtifactPublicServiceClientMockDeleteCatalogFile) When(ctx context.Context, in *mm_artifactv1alpha.DeleteCatalogFileRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockDeleteCatalogFileExpectation {
	if mmDeleteCatalogFile.mock.funcDeleteCatalogFile != nil {
		mmDeleteCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalogFile mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockDeleteCatalogFileExpectation{
		mock:   mmDeleteCatalogFile.mock,
		params: &ArtifactPublicServiceClientMockDeleteCatalogFileParams{ctx, in, opts},
	}
	mmDeleteCatalogFile.expectations = append(mmDeleteCatalogFile.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.DeleteCatalogFile return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockDeleteCatalogFileExpectation) Then(dp1 *mm_artifactv1alpha.DeleteCatalogFileResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockDeleteCatalogFileResults{dp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.DeleteCatalogFile should be invoked
func (mmDeleteCatalogFile *mArtifactPublicServiceClientMockDeleteCatalogFile) Times(n uint64) *mArtifactPublicServiceClientMockDeleteCatalogFile {
	if n == 0 {
		mmDeleteCatalogFile.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.DeleteCatalogFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteCatalogFile.expectedInvocations, n)
	return mmDeleteCatalogFile
}

func (mmDeleteCatalogFile *mArtifactPublicServiceClientMockDeleteCatalogFile) invocationsDone() bool {
	if len(mmDeleteCatalogFile.expectations) == 0 && mmDeleteCatalogFile.defaultExpectation == nil && mmDeleteCatalogFile.mock.funcDeleteCatalogFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteCatalogFile.mock.afterDeleteCatalogFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteCatalogFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteCatalogFile implements artifactv1alpha.ArtifactPublicServiceClient
func (mmDeleteCatalogFile *ArtifactPublicServiceClientMock) DeleteCatalogFile(ctx context.Context, in *mm_artifactv1alpha.DeleteCatalogFileRequest, opts ...grpc.CallOption) (dp1 *mm_artifactv1alpha.DeleteCatalogFileResponse, err error) {
	mm_atomic.AddUint64(&mmDeleteCatalogFile.beforeDeleteCatalogFileCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteCatalogFile.afterDeleteCatalogFileCounter, 1)

	if mmDeleteCatalogFile.inspectFuncDeleteCatalogFile != nil {
		mmDeleteCatalogFile.inspectFuncDeleteCatalogFile(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockDeleteCatalogFileParams{ctx, in, opts}

	// Record call args
	mmDeleteCatalogFile.DeleteCatalogFileMock.mutex.Lock()
	mmDeleteCatalogFile.DeleteCatalogFileMock.callArgs = append(mmDeleteCatalogFile.DeleteCatalogFileMock.callArgs, &mm_params)
	mmDeleteCatalogFile.DeleteCatalogFileMock.mutex.Unlock()

	for _, e := range mmDeleteCatalogFile.DeleteCatalogFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp1, e.results.err
		}
	}

	if mmDeleteCatalogFile.DeleteCatalogFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteCatalogFile.DeleteCatalogFileMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteCatalogFile.DeleteCatalogFileMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteCatalogFile.DeleteCatalogFileMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockDeleteCatalogFileParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteCatalogFile.t.Errorf("ArtifactPublicServiceClientMock.DeleteCatalogFile got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmDeleteCatalogFile.t.Errorf("ArtifactPublicServiceClientMock.DeleteCatalogFile got unexpected parameter in, want: %#v, got: %#v%s\n", *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmDeleteCatalogFile.t.Errorf("ArtifactPublicServiceClientMock.DeleteCatalogFile got unexpected parameter opts, want: %#v, got: %#v%s\n", *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteCatalogFile.t.Errorf("ArtifactPublicServiceClientMock.DeleteCatalogFile got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteCatalogFile.DeleteCatalogFileMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteCatalogFile.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.DeleteCatalogFile")
		}
		return (*mm_results).dp1, (*mm_results).err
	}
	if mmDeleteCatalogFile.funcDeleteCatalogFile != nil {
		return mmDeleteCatalogFile.funcDeleteCatalogFile(ctx, in, opts...)
	}
	mmDeleteCatalogFile.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.DeleteCatalogFile. %v %v %v", ctx, in, opts)
	return
}

// DeleteCatalogFileAfterCounter returns a count of finished ArtifactPublicServiceClientMock.DeleteCatalogFile invocations
func (mmDeleteCatalogFile *ArtifactPublicServiceClientMock) DeleteCatalogFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCatalogFile.afterDeleteCatalogFileCounter)
}

// DeleteCatalogFileBeforeCounter returns a count of ArtifactPublicServiceClientMock.DeleteCatalogFile invocations
func (mmDeleteCatalogFile *ArtifactPublicServiceClientMock) DeleteCatalogFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCatalogFile.beforeDeleteCatalogFileCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.DeleteCatalogFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteCatalogFile *mArtifactPublicServiceClientMockDeleteCatalogFile) Calls() []*ArtifactPublicServiceClientMockDeleteCatalogFileParams {
	mmDeleteCatalogFile.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockDeleteCatalogFileParams, len(mmDeleteCatalogFile.callArgs))
	copy(argCopy, mmDeleteCatalogFile.callArgs)

	mmDeleteCatalogFile.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteCatalogFileDone returns true if the count of the DeleteCatalogFile invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockDeleteCatalogFileDone() bool {
	if m.DeleteCatalogFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteCatalogFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteCatalogFileMock.invocationsDone()
}

// MinimockDeleteCatalogFileInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockDeleteCatalogFileInspect() {
	for _, e := range m.DeleteCatalogFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.DeleteCatalogFile with params: %#v", *e.params)
		}
	}

	afterDeleteCatalogFileCounter := mm_atomic.LoadUint64(&m.afterDeleteCatalogFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteCatalogFileMock.defaultExpectation != nil && afterDeleteCatalogFileCounter < 1 {
		if m.DeleteCatalogFileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ArtifactPublicServiceClientMock.DeleteCatalogFile")
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.DeleteCatalogFile with params: %#v", *m.DeleteCatalogFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteCatalogFile != nil && afterDeleteCatalogFileCounter < 1 {
		m.t.Error("Expected call to ArtifactPublicServiceClientMock.DeleteCatalogFile")
	}

	if !m.DeleteCatalogFileMock.invocationsDone() && afterDeleteCatalogFileCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.DeleteCatalogFile but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteCatalogFileMock.expectedInvocations), afterDeleteCatalogFileCounter)
	}
}

type mArtifactPublicServiceClientMockDeleteConversation struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockDeleteConversationExpectation
	expectations       []*ArtifactPublicServiceClientMockDeleteConversationExpectation

	callArgs []*ArtifactPublicServiceClientMockDeleteConversationParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ArtifactPublicServiceClientMockDeleteConversationExpectation specifies expectation struct of the ArtifactPublicServiceClient.DeleteConversation
type ArtifactPublicServiceClientMockDeleteConversationExpectation struct {
	mock      *ArtifactPublicServiceClientMock
	params    *ArtifactPublicServiceClientMockDeleteConversationParams
	paramPtrs *ArtifactPublicServiceClientMockDeleteConversationParamPtrs
	results   *ArtifactPublicServiceClientMockDeleteConversationResults
	Counter   uint64
}

// ArtifactPublicServiceClientMockDeleteConversationParams contains parameters of the ArtifactPublicServiceClient.DeleteConversation
type ArtifactPublicServiceClientMockDeleteConversationParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.DeleteConversationRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockDeleteConversationParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.DeleteConversation
type ArtifactPublicServiceClientMockDeleteConversationParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.DeleteConversationRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockDeleteConversationResults contains results of the ArtifactPublicServiceClient.DeleteConversation
type ArtifactPublicServiceClientMockDeleteConversationResults struct {
	dp1 *mm_artifactv1alpha.DeleteConversationResponse
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteConversation *mArtifactPublicServiceClientMockDeleteConversation) Optional() *mArtifactPublicServiceClientMockDeleteConversation {
	mmDeleteConversation.optional = true
	return mmDeleteConversation
}

// Expect sets up expected params for ArtifactPublicServiceClient.DeleteConversation
func (mmDeleteConversation *mArtifactPublicServiceClientMockDeleteConversation) Expect(ctx context.Context, in *mm_artifactv1alpha.DeleteConversationRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockDeleteConversation {
	if mmDeleteConversation.mock.funcDeleteConversation != nil {
		mmDeleteConversation.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteConversation mock is already set by Set")
	}

	if mmDeleteConversation.defaultExpectation == nil {
		mmDeleteConversation.defaultExpectation = &ArtifactPublicServiceClientMockDeleteConversationExpectation{}
	}

	if mmDeleteConversation.defaultExpectation.paramPtrs != nil {
		mmDeleteConversation.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteConversation mock is already set by ExpectParams functions")
	}

	mmDeleteConversation.defaultExpectation.params = &ArtifactPublicServiceClientMockDeleteConversationParams{ctx, in, opts}
	for _, e := range mmDeleteConversation.expectations {
		if minimock.Equal(e.params, mmDeleteConversation.defaultExpectation.params) {
			mmDeleteConversation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteConversation.defaultExpectation.params)
		}
	}

	return mmDeleteConversation
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.DeleteConversation
func (mmDeleteConversation *mArtifactPublicServiceClientMockDeleteConversation) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockDeleteConversation {
	if mmDeleteConversation.mock.funcDeleteConversation != nil {
		mmDeleteConversation.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteConversation mock is already set by Set")
	}

	if mmDeleteConversation.defaultExpectation == nil {
		mmDeleteConversation.defaultExpectation = &ArtifactPublicServiceClientMockDeleteConversationExpectation{}
	}

	if mmDeleteConversation.defaultExpectation.params != nil {
		mmDeleteConversation.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteConversation mock is already set by Expect")
	}

	if mmDeleteConversation.defaultExpectation.paramPtrs == nil {
		mmDeleteConversation.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockDeleteConversationParamPtrs{}
	}
	mmDeleteConversation.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteConversation
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.DeleteConversation
func (mmDeleteConversation *mArtifactPublicServiceClientMockDeleteConversation) ExpectInParam2(in *mm_artifactv1alpha.DeleteConversationRequest) *mArtifactPublicServiceClientMockDeleteConversation {
	if mmDeleteConversation.mock.funcDeleteConversation != nil {
		mmDeleteConversation.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteConversation mock is already set by Set")
	}

	if mmDeleteConversation.defaultExpectation == nil {
		mmDeleteConversation.defaultExpectation = &ArtifactPublicServiceClientMockDeleteConversationExpectation{}
	}

	if mmDeleteConversation.defaultExpectation.params != nil {
		mmDeleteConversation.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteConversation mock is already set by Expect")
	}

	if mmDeleteConversation.defaultExpectation.paramPtrs == nil {
		mmDeleteConversation.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockDeleteConversationParamPtrs{}
	}
	mmDeleteConversation.defaultExpectation.paramPtrs.in = &in

	return mmDeleteConversation
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.DeleteConversation
func (mmDeleteConversation *mArtifactPublicServiceClientMockDeleteConversation) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockDeleteConversation {
	if mmDeleteConversation.mock.funcDeleteConversation != nil {
		mmDeleteConversation.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteConversation mock is already set by Set")
	}

	if mmDeleteConversation.defaultExpectation == nil {
		mmDeleteConversation.defaultExpectation = &ArtifactPublicServiceClientMockDeleteConversationExpectation{}
	}

	if mmDeleteConversation.defaultExpectation.params != nil {
		mmDeleteConversation.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteConversation mock is already set by Expect")
	}

	if mmDeleteConversation.defaultExpectation.paramPtrs == nil {
		mmDeleteConversation.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockDeleteConversationParamPtrs{}
	}
	mmDeleteConversation.defaultExpectation.paramPtrs.opts = &opts

	return mmDeleteConversation
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.DeleteConversation
func (mmDeleteConversation *mArtifactPublicServiceClientMockDeleteConversation) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.DeleteConversationRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockDeleteConversation {
	if mmDeleteConversation.mock.inspectFuncDeleteConversation != nil {
		mmDeleteConversation.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.DeleteConversation")
	}

	mmDeleteConversation.mock.inspectFuncDeleteConversation = f

	return mmDeleteConversation
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.DeleteConversation
func (mmDeleteConversation *mArtifactPublicServiceClientMockDeleteConversation) Return(dp1 *mm_artifactv1alpha.DeleteConversationResponse, err error) *ArtifactPublicServiceClientMock {
	if mmDeleteConversation.mock.funcDeleteConversation != nil {
		mmDeleteConversation.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteConversation mock is already set by Set")
	}

	if mmDeleteConversation.defaultExpectation == nil {
		mmDeleteConversation.defaultExpectation = &ArtifactPublicServiceClientMockDeleteConversationExpectation{mock: mmDeleteConversation.mock}
	}
	mmDeleteConversation.defaultExpectation.results = &ArtifactPublicServiceClientMockDeleteConversationResults{dp1, err}
	return mmDeleteConversation.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.DeleteConversation method
func (mmDeleteConversation *mArtifactPublicServiceClientMockDeleteConversation) Set(f func(ctx context.Context, in *mm_artifactv1alpha.DeleteConversationRequest, opts ...grpc.CallOption) (dp1 *mm_artifactv1alpha.DeleteConversationResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmDeleteConversation.defaultExpectation != nil {
		mmDeleteConversation.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.DeleteConversation method")
	}

	if len(mmDeleteConversation.expectations) > 0 {
		mmDeleteConversation.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.DeleteConversation method")
	}

	mmDeleteConversation.mock.funcDeleteConversation = f
	return mmDeleteConversation.mock
}

// When sets expectation for the ArtifactPublicServiceClient.DeleteConversation which will trigger the result defined by the following
// Then helper
func (mmDeleteConversation *mArtifactPublicServiceClientMockDeleteConversation) When(ctx context.Context, in *mm_artifactv1alpha.DeleteConversationRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockDeleteConversationExpectation {
	if mmDeleteConversation.mock.funcDeleteConversation != nil {
		mmDeleteConversation.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteConversation mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockDeleteConversationExpectation{
		mock:   mmDeleteConversation.mock,
		params: &ArtifactPublicServiceClientMockDeleteConversationParams{ctx, in, opts},
	}
	mmDeleteConversation.expectations = append(mmDeleteConversation.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.DeleteConversation return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockDeleteConversationExpectation) Then(dp1 *mm_artifactv1alpha.DeleteConversationResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockDeleteConversationResults{dp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.DeleteConversation should be invoked
func (mmDeleteConversation *mArtifactPublicServiceClientMockDeleteConversation) Times(n uint64) *mArtifactPublicServiceClientMockDeleteConversation {
	if n == 0 {
		mmDeleteConversation.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.DeleteConversation mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteConversation.expectedInvocations, n)
	return mmDeleteConversation
}

func (mmDeleteConversation *mArtifactPublicServiceClientMockDeleteConversation) invocationsDone() bool {
	if len(mmDeleteConversation.expectations) == 0 && mmDeleteConversation.defaultExpectation == nil && mmDeleteConversation.mock.funcDeleteConversation == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteConversation.mock.afterDeleteConversationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteConversation.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteConversation implements artifactv1alpha.ArtifactPublicServiceClient
func (mmDeleteConversation *ArtifactPublicServiceClientMock) DeleteConversation(ctx context.Context, in *mm_artifactv1alpha.DeleteConversationRequest, opts ...grpc.CallOption) (dp1 *mm_artifactv1alpha.DeleteConversationResponse, err error) {
	mm_atomic.AddUint64(&mmDeleteConversation.beforeDeleteConversationCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteConversation.afterDeleteConversationCounter, 1)

	if mmDeleteConversation.inspectFuncDeleteConversation != nil {
		mmDeleteConversation.inspectFuncDeleteConversation(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockDeleteConversationParams{ctx, in, opts}

	// Record call args
	mmDeleteConversation.DeleteConversationMock.mutex.Lock()
	mmDeleteConversation.DeleteConversationMock.callArgs = append(mmDeleteConversation.DeleteConversationMock.callArgs, &mm_params)
	mmDeleteConversation.DeleteConversationMock.mutex.Unlock()

	for _, e := range mmDeleteConversation.DeleteConversationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp1, e.results.err
		}
	}

	if mmDeleteConversation.DeleteConversationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteConversation.DeleteConversationMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteConversation.DeleteConversationMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteConversation.DeleteConversationMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockDeleteConversationParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteConversation.t.Errorf("ArtifactPublicServiceClientMock.DeleteConversation got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmDeleteConversation.t.Errorf("ArtifactPublicServiceClientMock.DeleteConversation got unexpected parameter in, want: %#v, got: %#v%s\n", *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmDeleteConversation.t.Errorf("ArtifactPublicServiceClientMock.DeleteConversation got unexpected parameter opts, want: %#v, got: %#v%s\n", *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteConversation.t.Errorf("ArtifactPublicServiceClientMock.DeleteConversation got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteConversation.DeleteConversationMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteConversation.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.DeleteConversation")
		}
		return (*mm_results).dp1, (*mm_results).err
	}
	if mmDeleteConversation.funcDeleteConversation != nil {
		return mmDeleteConversation.funcDeleteConversation(ctx, in, opts...)
	}
	mmDeleteConversation.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.DeleteConversation. %v %v %v", ctx, in, opts)
	return
}

// DeleteConversationAfterCounter returns a count of finished ArtifactPublicServiceClientMock.DeleteConversation invocations
func (mmDeleteConversation *ArtifactPublicServiceClientMock) DeleteConversationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteConversation.afterDeleteConversationCounter)
}

// DeleteConversationBeforeCounter returns a count of ArtifactPublicServiceClientMock.DeleteConversation invocations
func (mmDeleteConversation *ArtifactPublicServiceClientMock) DeleteConversationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteConversation.beforeDeleteConversationCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.DeleteConversation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteConversation *mArtifactPublicServiceClientMockDeleteConversation) Calls() []*ArtifactPublicServiceClientMockDeleteConversationParams {
	mmDeleteConversation.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockDeleteConversationParams, len(mmDeleteConversation.callArgs))
	copy(argCopy, mmDeleteConversation.callArgs)

	mmDeleteConversation.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteConversationDone returns true if the count of the DeleteConversation invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockDeleteConversationDone() bool {
	if m.DeleteConversationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteConversationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteConversationMock.invocationsDone()
}

// MinimockDeleteConversationInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockDeleteConversationInspect() {
	for _, e := range m.DeleteConversationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.DeleteConversation with params: %#v", *e.params)
		}
	}

	afterDeleteConversationCounter := mm_atomic.LoadUint64(&m.afterDeleteConversationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteConversationMock.defaultExpectation != nil && afterDeleteConversationCounter < 1 {
		if m.DeleteConversationMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ArtifactPublicServiceClientMock.DeleteConversation")
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.DeleteConversation with params: %#v", *m.DeleteConversationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteConversation != nil && afterDeleteConversationCounter < 1 {
		m.t.Error("Expected call to ArtifactPublicServiceClientMock.DeleteConversation")
	}

	if !m.DeleteConversationMock.invocationsDone() && afterDeleteConversationCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.DeleteConversation but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteConversationMock.expectedInvocations), afterDeleteConversationCounter)
	}
}

type mArtifactPublicServiceClientMockDeleteMessage struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockDeleteMessageExpectation
	expectations       []*ArtifactPublicServiceClientMockDeleteMessageExpectation

	callArgs []*ArtifactPublicServiceClientMockDeleteMessageParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ArtifactPublicServiceClientMockDeleteMessageExpectation specifies expectation struct of the ArtifactPublicServiceClient.DeleteMessage
type ArtifactPublicServiceClientMockDeleteMessageExpectation struct {
	mock      *ArtifactPublicServiceClientMock
	params    *ArtifactPublicServiceClientMockDeleteMessageParams
	paramPtrs *ArtifactPublicServiceClientMockDeleteMessageParamPtrs
	results   *ArtifactPublicServiceClientMockDeleteMessageResults
	Counter   uint64
}

// ArtifactPublicServiceClientMockDeleteMessageParams contains parameters of the ArtifactPublicServiceClient.DeleteMessage
type ArtifactPublicServiceClientMockDeleteMessageParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.DeleteMessageRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockDeleteMessageParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.DeleteMessage
type ArtifactPublicServiceClientMockDeleteMessageParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.DeleteMessageRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockDeleteMessageResults contains results of the ArtifactPublicServiceClient.DeleteMessage
type ArtifactPublicServiceClientMockDeleteMessageResults struct {
	dp1 *mm_artifactv1alpha.DeleteMessageResponse
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteMessage *mArtifactPublicServiceClientMockDeleteMessage) Optional() *mArtifactPublicServiceClientMockDeleteMessage {
	mmDeleteMessage.optional = true
	return mmDeleteMessage
}

// Expect sets up expected params for ArtifactPublicServiceClient.DeleteMessage
func (mmDeleteMessage *mArtifactPublicServiceClientMockDeleteMessage) Expect(ctx context.Context, in *mm_artifactv1alpha.DeleteMessageRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockDeleteMessage {
	if mmDeleteMessage.mock.funcDeleteMessage != nil {
		mmDeleteMessage.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteMessage mock is already set by Set")
	}

	if mmDeleteMessage.defaultExpectation == nil {
		mmDeleteMessage.defaultExpectation = &ArtifactPublicServiceClientMockDeleteMessageExpectation{}
	}

	if mmDeleteMessage.defaultExpectation.paramPtrs != nil {
		mmDeleteMessage.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteMessage mock is already set by ExpectParams functions")
	}

	mmDeleteMessage.defaultExpectation.params = &ArtifactPublicServiceClientMockDeleteMessageParams{ctx, in, opts}
	for _, e := range mmDeleteMessage.expectations {
		if minimock.Equal(e.params, mmDeleteMessage.defaultExpectation.params) {
			mmDeleteMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteMessage.defaultExpectation.params)
		}
	}

	return mmDeleteMessage
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.DeleteMessage
func (mmDeleteMessage *mArtifactPublicServiceClientMockDeleteMessage) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockDeleteMessage {
	if mmDeleteMessage.mock.funcDeleteMessage != nil {
		mmDeleteMessage.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteMessage mock is already set by Set")
	}

	if mmDeleteMessage.defaultExpectation == nil {
		mmDeleteMessage.defaultExpectation = &ArtifactPublicServiceClientMockDeleteMessageExpectation{}
	}

	if mmDeleteMessage.defaultExpectation.params != nil {
		mmDeleteMessage.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteMessage mock is already set by Expect")
	}

	if mmDeleteMessage.defaultExpectation.paramPtrs == nil {
		mmDeleteMessage.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockDeleteMessageParamPtrs{}
	}
	mmDeleteMessage.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteMessage
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.DeleteMessage
func (mmDeleteMessage *mArtifactPublicServiceClientMockDeleteMessage) ExpectInParam2(in *mm_artifactv1alpha.DeleteMessageRequest) *mArtifactPublicServiceClientMockDeleteMessage {
	if mmDeleteMessage.mock.funcDeleteMessage != nil {
		mmDeleteMessage.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteMessage mock is already set by Set")
	}

	if mmDeleteMessage.defaultExpectation == nil {
		mmDeleteMessage.defaultExpectation = &ArtifactPublicServiceClientMockDeleteMessageExpectation{}
	}

	if mmDeleteMessage.defaultExpectation.params != nil {
		mmDeleteMessage.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteMessage mock is already set by Expect")
	}

	if mmDeleteMessage.defaultExpectation.paramPtrs == nil {
		mmDeleteMessage.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockDeleteMessageParamPtrs{}
	}
	mmDeleteMessage.defaultExpectation.paramPtrs.in = &in

	return mmDeleteMessage
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.DeleteMessage
func (mmDeleteMessage *mArtifactPublicServiceClientMockDeleteMessage) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockDeleteMessage {
	if mmDeleteMessage.mock.funcDeleteMessage != nil {
		mmDeleteMessage.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteMessage mock is already set by Set")
	}

	if mmDeleteMessage.defaultExpectation == nil {
		mmDeleteMessage.defaultExpectation = &ArtifactPublicServiceClientMockDeleteMessageExpectation{}
	}

	if mmDeleteMessage.defaultExpectation.params != nil {
		mmDeleteMessage.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteMessage mock is already set by Expect")
	}

	if mmDeleteMessage.defaultExpectation.paramPtrs == nil {
		mmDeleteMessage.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockDeleteMessageParamPtrs{}
	}
	mmDeleteMessage.defaultExpectation.paramPtrs.opts = &opts

	return mmDeleteMessage
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.DeleteMessage
func (mmDeleteMessage *mArtifactPublicServiceClientMockDeleteMessage) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.DeleteMessageRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockDeleteMessage {
	if mmDeleteMessage.mock.inspectFuncDeleteMessage != nil {
		mmDeleteMessage.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.DeleteMessage")
	}

	mmDeleteMessage.mock.inspectFuncDeleteMessage = f

	return mmDeleteMessage
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.DeleteMessage
func (mmDeleteMessage *mArtifactPublicServiceClientMockDeleteMessage) Return(dp1 *mm_artifactv1alpha.DeleteMessageResponse, err error) *ArtifactPublicServiceClientMock {
	if mmDeleteMessage.mock.funcDeleteMessage != nil {
		mmDeleteMessage.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteMessage mock is already set by Set")
	}

	if mmDeleteMessage.defaultExpectation == nil {
		mmDeleteMessage.defaultExpectation = &ArtifactPublicServiceClientMockDeleteMessageExpectation{mock: mmDeleteMessage.mock}
	}
	mmDeleteMessage.defaultExpectation.results = &ArtifactPublicServiceClientMockDeleteMessageResults{dp1, err}
	return mmDeleteMessage.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.DeleteMessage method
func (mmDeleteMessage *mArtifactPublicServiceClientMockDeleteMessage) Set(f func(ctx context.Context, in *mm_artifactv1alpha.DeleteMessageRequest, opts ...grpc.CallOption) (dp1 *mm_artifactv1alpha.DeleteMessageResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmDeleteMessage.defaultExpectation != nil {
		mmDeleteMessage.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.DeleteMessage method")
	}

	if len(mmDeleteMessage.expectations) > 0 {
		mmDeleteMessage.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.DeleteMessage method")
	}

	mmDeleteMessage.mock.funcDeleteMessage = f
	return mmDeleteMessage.mock
}

// When sets expectation for the ArtifactPublicServiceClient.DeleteMessage which will trigger the result defined by the following
// Then helper
func (mmDeleteMessage *mArtifactPublicServiceClientMockDeleteMessage) When(ctx context.Context, in *mm_artifactv1alpha.DeleteMessageRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockDeleteMessageExpectation {
	if mmDeleteMessage.mock.funcDeleteMessage != nil {
		mmDeleteMessage.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteMessage mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockDeleteMessageExpectation{
		mock:   mmDeleteMessage.mock,
		params: &ArtifactPublicServiceClientMockDeleteMessageParams{ctx, in, opts},
	}
	mmDeleteMessage.expectations = append(mmDeleteMessage.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.DeleteMessage return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockDeleteMessageExpectation) Then(dp1 *mm_artifactv1alpha.DeleteMessageResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockDeleteMessageResults{dp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.DeleteMessage should be invoked
func (mmDeleteMessage *mArtifactPublicServiceClientMockDeleteMessage) Times(n uint64) *mArtifactPublicServiceClientMockDeleteMessage {
	if n == 0 {
		mmDeleteMessage.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.DeleteMessage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteMessage.expectedInvocations, n)
	return mmDeleteMessage
}

func (mmDeleteMessage *mArtifactPublicServiceClientMockDeleteMessage) invocationsDone() bool {
	if len(mmDeleteMessage.expectations) == 0 && mmDeleteMessage.defaultExpectation == nil && mmDeleteMessage.mock.funcDeleteMessage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteMessage.mock.afterDeleteMessageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteMessage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteMessage implements artifactv1alpha.ArtifactPublicServiceClient
func (mmDeleteMessage *ArtifactPublicServiceClientMock) DeleteMessage(ctx context.Context, in *mm_artifactv1alpha.DeleteMessageRequest, opts ...grpc.CallOption) (dp1 *mm_artifactv1alpha.DeleteMessageResponse, err error) {
	mm_atomic.AddUint64(&mmDeleteMessage.beforeDeleteMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteMessage.afterDeleteMessageCounter, 1)

	if mmDeleteMessage.inspectFuncDeleteMessage != nil {
		mmDeleteMessage.inspectFuncDeleteMessage(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockDeleteMessageParams{ctx, in, opts}

	// Record call args
	mmDeleteMessage.DeleteMessageMock.mutex.Lock()
	mmDeleteMessage.DeleteMessageMock.callArgs = append(mmDeleteMessage.DeleteMessageMock.callArgs, &mm_params)
	mmDeleteMessage.DeleteMessageMock.mutex.Unlock()

	for _, e := range mmDeleteMessage.DeleteMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp1, e.results.err
		}
	}

	if mmDeleteMessage.DeleteMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteMessage.DeleteMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteMessage.DeleteMessageMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteMessage.DeleteMessageMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockDeleteMessageParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteMessage.t.Errorf("ArtifactPublicServiceClientMock.DeleteMessage got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmDeleteMessage.t.Errorf("ArtifactPublicServiceClientMock.DeleteMessage got unexpected parameter in, want: %#v, got: %#v%s\n", *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmDeleteMessage.t.Errorf("ArtifactPublicServiceClientMock.DeleteMessage got unexpected parameter opts, want: %#v, got: %#v%s\n", *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteMessage.t.Errorf("ArtifactPublicServiceClientMock.DeleteMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteMessage.DeleteMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteMessage.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.DeleteMessage")
		}
		return (*mm_results).dp1, (*mm_results).err
	}
	if mmDeleteMessage.funcDeleteMessage != nil {
		return mmDeleteMessage.funcDeleteMessage(ctx, in, opts...)
	}
	mmDeleteMessage.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.DeleteMessage. %v %v %v", ctx, in, opts)
	return
}

// DeleteMessageAfterCounter returns a count of finished ArtifactPublicServiceClientMock.DeleteMessage invocations
func (mmDeleteMessage *ArtifactPublicServiceClientMock) DeleteMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteMessage.afterDeleteMessageCounter)
}

// DeleteMessageBeforeCounter returns a count of ArtifactPublicServiceClientMock.DeleteMessage invocations
func (mmDeleteMessage *ArtifactPublicServiceClientMock) DeleteMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteMessage.beforeDeleteMessageCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.DeleteMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteMessage *mArtifactPublicServiceClientMockDeleteMessage) Calls() []*ArtifactPublicServiceClientMockDeleteMessageParams {
	mmDeleteMessage.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockDeleteMessageParams, len(mmDeleteMessage.callArgs))
	copy(argCopy, mmDeleteMessage.callArgs)

	mmDeleteMessage.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteMessageDone returns true if the count of the DeleteMessage invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockDeleteMessageDone() bool {
	if m.DeleteMessageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMessageMock.invocationsDone()
}

// MinimockDeleteMessageInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockDeleteMessageInspect() {
	for _, e := range m.DeleteMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.DeleteMessage with params: %#v", *e.params)
		}
	}

	afterDeleteMessageCounter := mm_atomic.LoadUint64(&m.afterDeleteMessageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMessageMock.defaultExpectation != nil && afterDeleteMessageCounter < 1 {
		if m.DeleteMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ArtifactPublicServiceClientMock.DeleteMessage")
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.DeleteMessage with params: %#v", *m.DeleteMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteMessage != nil && afterDeleteMessageCounter < 1 {
		m.t.Error("Expected call to ArtifactPublicServiceClientMock.DeleteMessage")
	}

	if !m.DeleteMessageMock.invocationsDone() && afterDeleteMessageCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.DeleteMessage but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMessageMock.expectedInvocations), afterDeleteMessageCounter)
	}
}

type mArtifactPublicServiceClientMockGetFileCatalog struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockGetFileCatalogExpectation
	expectations       []*ArtifactPublicServiceClientMockGetFileCatalogExpectation

	callArgs []*ArtifactPublicServiceClientMockGetFileCatalogParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ArtifactPublicServiceClientMockGetFileCatalogExpectation specifies expectation struct of the ArtifactPublicServiceClient.GetFileCatalog
type ArtifactPublicServiceClientMockGetFileCatalogExpectation struct {
	mock      *ArtifactPublicServiceClientMock
	params    *ArtifactPublicServiceClientMockGetFileCatalogParams
	paramPtrs *ArtifactPublicServiceClientMockGetFileCatalogParamPtrs
	results   *ArtifactPublicServiceClientMockGetFileCatalogResults
	Counter   uint64
}

// ArtifactPublicServiceClientMockGetFileCatalogParams contains parameters of the ArtifactPublicServiceClient.GetFileCatalog
type ArtifactPublicServiceClientMockGetFileCatalogParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.GetFileCatalogRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockGetFileCatalogParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.GetFileCatalog
type ArtifactPublicServiceClientMockGetFileCatalogParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.GetFileCatalogRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockGetFileCatalogResults contains results of the ArtifactPublicServiceClient.GetFileCatalog
type ArtifactPublicServiceClientMockGetFileCatalogResults struct {
	gp1 *mm_artifactv1alpha.GetFileCatalogResponse
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetFileCatalog *mArtifactPublicServiceClientMockGetFileCatalog) Optional() *mArtifactPublicServiceClientMockGetFileCatalog {
	mmGetFileCatalog.optional = true
	return mmGetFileCatalog
}

// Expect sets up expected params for ArtifactPublicServiceClient.GetFileCatalog
func (mmGetFileCatalog *mArtifactPublicServiceClientMockGetFileCatalog) Expect(ctx context.Context, in *mm_artifactv1alpha.GetFileCatalogRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockGetFileCatalog {
	if mmGetFileCatalog.mock.funcGetFileCatalog != nil {
		mmGetFileCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetFileCatalog mock is already set by Set")
	}

	if mmGetFileCatalog.defaultExpectation == nil {
		mmGetFileCatalog.defaultExpectation = &ArtifactPublicServiceClientMockGetFileCatalogExpectation{}
	}

	if mmGetFileCatalog.defaultExpectation.paramPtrs != nil {
		mmGetFileCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetFileCatalog mock is already set by ExpectParams functions")
	}

	mmGetFileCatalog.defaultExpectation.params = &ArtifactPublicServiceClientMockGetFileCatalogParams{ctx, in, opts}
	for _, e := range mmGetFileCatalog.expectations {
		if minimock.Equal(e.params, mmGetFileCatalog.defaultExpectation.params) {
			mmGetFileCatalog.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetFileCatalog.defaultExpectation.params)
		}
	}

	return mmGetFileCatalog
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.GetFileCatalog
func (mmGetFileCatalog *mArtifactPublicServiceClientMockGetFileCatalog) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockGetFileCatalog {
	if mmGetFileCatalog.mock.funcGetFileCatalog != nil {
		mmGetFileCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetFileCatalog mock is already set by Set")
	}

	if mmGetFileCatalog.defaultExpectation == nil {
		mmGetFileCatalog.defaultExpectation = &ArtifactPublicServiceClientMockGetFileCatalogExpectation{}
	}

	if mmGetFileCatalog.defaultExpectation.params != nil {
		mmGetFileCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetFileCatalog mock is already set by Expect")
	}

	if mmGetFileCatalog.defaultExpectation.paramPtrs == nil {
		mmGetFileCatalog.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockGetFileCatalogParamPtrs{}
	}
	mmGetFileCatalog.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetFileCatalog
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.GetFileCatalog
func (mmGetFileCatalog *mArtifactPublicServiceClientMockGetFileCatalog) ExpectInParam2(in *mm_artifactv1alpha.GetFileCatalogRequest) *mArtifactPublicServiceClientMockGetFileCatalog {
	if mmGetFileCatalog.mock.funcGetFileCatalog != nil {
		mmGetFileCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetFileCatalog mock is already set by Set")
	}

	if mmGetFileCatalog.defaultExpectation == nil {
		mmGetFileCatalog.defaultExpectation = &ArtifactPublicServiceClientMockGetFileCatalogExpectation{}
	}

	if mmGetFileCatalog.defaultExpectation.params != nil {
		mmGetFileCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetFileCatalog mock is already set by Expect")
	}

	if mmGetFileCatalog.defaultExpectation.paramPtrs == nil {
		mmGetFileCatalog.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockGetFileCatalogParamPtrs{}
	}
	mmGetFileCatalog.defaultExpectation.paramPtrs.in = &in

	return mmGetFileCatalog
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.GetFileCatalog
func (mmGetFileCatalog *mArtifactPublicServiceClientMockGetFileCatalog) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockGetFileCatalog {
	if mmGetFileCatalog.mock.funcGetFileCatalog != nil {
		mmGetFileCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetFileCatalog mock is already set by Set")
	}

	if mmGetFileCatalog.defaultExpectation == nil {
		mmGetFileCatalog.defaultExpectation = &ArtifactPublicServiceClientMockGetFileCatalogExpectation{}
	}

	if mmGetFileCatalog.defaultExpectation.params != nil {
		mmGetFileCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetFileCatalog mock is already set by Expect")
	}

	if mmGetFileCatalog.defaultExpectation.paramPtrs == nil {
		mmGetFileCatalog.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockGetFileCatalogParamPtrs{}
	}
	mmGetFileCatalog.defaultExpectation.paramPtrs.opts = &opts

	return mmGetFileCatalog
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.GetFileCatalog
func (mmGetFileCatalog *mArtifactPublicServiceClientMockGetFileCatalog) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.GetFileCatalogRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockGetFileCatalog {
	if mmGetFileCatalog.mock.inspectFuncGetFileCatalog != nil {
		mmGetFileCatalog.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.GetFileCatalog")
	}

	mmGetFileCatalog.mock.inspectFuncGetFileCatalog = f

	return mmGetFileCatalog
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.GetFileCatalog
func (mmGetFileCatalog *mArtifactPublicServiceClientMockGetFileCatalog) Return(gp1 *mm_artifactv1alpha.GetFileCatalogResponse, err error) *ArtifactPublicServiceClientMock {
	if mmGetFileCatalog.mock.funcGetFileCatalog != nil {
		mmGetFileCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetFileCatalog mock is already set by Set")
	}

	if mmGetFileCatalog.defaultExpectation == nil {
		mmGetFileCatalog.defaultExpectation = &ArtifactPublicServiceClientMockGetFileCatalogExpectation{mock: mmGetFileCatalog.mock}
	}
	mmGetFileCatalog.defaultExpectation.results = &ArtifactPublicServiceClientMockGetFileCatalogResults{gp1, err}
	return mmGetFileCatalog.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.GetFileCatalog method
func (mmGetFileCatalog *mArtifactPublicServiceClientMockGetFileCatalog) Set(f func(ctx context.Context, in *mm_artifactv1alpha.GetFileCatalogRequest, opts ...grpc.CallOption) (gp1 *mm_artifactv1alpha.GetFileCatalogResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmGetFileCatalog.defaultExpectation != nil {
		mmGetFileCatalog.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.GetFileCatalog method")
	}

	if len(mmGetFileCatalog.expectations) > 0 {
		mmGetFileCatalog.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.GetFileCatalog method")
	}

	mmGetFileCatalog.mock.funcGetFileCatalog = f
	return mmGetFileCatalog.mock
}

// When sets expectation for the ArtifactPublicServiceClient.GetFileCatalog which will trigger the result defined by the following
// Then helper
func (mmGetFileCatalog *mArtifactPublicServiceClientMockGetFileCatalog) When(ctx context.Context, in *mm_artifactv1alpha.GetFileCatalogRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockGetFileCatalogExpectation {
	if mmGetFileCatalog.mock.funcGetFileCatalog != nil {
		mmGetFileCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetFileCatalog mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockGetFileCatalogExpectation{
		mock:   mmGetFileCatalog.mock,
		params: &ArtifactPublicServiceClientMockGetFileCatalogParams{ctx, in, opts},
	}
	mmGetFileCatalog.expectations = append(mmGetFileCatalog.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.GetFileCatalog return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockGetFileCatalogExpectation) Then(gp1 *mm_artifactv1alpha.GetFileCatalogResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockGetFileCatalogResults{gp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.GetFileCatalog should be invoked
func (mmGetFileCatalog *mArtifactPublicServiceClientMockGetFileCatalog) Times(n uint64) *mArtifactPublicServiceClientMockGetFileCatalog {
	if n == 0 {
		mmGetFileCatalog.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.GetFileCatalog mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetFileCatalog.expectedInvocations, n)
	return mmGetFileCatalog
}

func (mmGetFileCatalog *mArtifactPublicServiceClientMockGetFileCatalog) invocationsDone() bool {
	if len(mmGetFileCatalog.expectations) == 0 && mmGetFileCatalog.defaultExpectation == nil && mmGetFileCatalog.mock.funcGetFileCatalog == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetFileCatalog.mock.afterGetFileCatalogCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetFileCatalog.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetFileCatalog implements artifactv1alpha.ArtifactPublicServiceClient
func (mmGetFileCatalog *ArtifactPublicServiceClientMock) GetFileCatalog(ctx context.Context, in *mm_artifactv1alpha.GetFileCatalogRequest, opts ...grpc.CallOption) (gp1 *mm_artifactv1alpha.GetFileCatalogResponse, err error) {
	mm_atomic.AddUint64(&mmGetFileCatalog.beforeGetFileCatalogCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFileCatalog.afterGetFileCatalogCounter, 1)

	if mmGetFileCatalog.inspectFuncGetFileCatalog != nil {
		mmGetFileCatalog.inspectFuncGetFileCatalog(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockGetFileCatalogParams{ctx, in, opts}

	// Record call args
	mmGetFileCatalog.GetFileCatalogMock.mutex.Lock()
	mmGetFileCatalog.GetFileCatalogMock.callArgs = append(mmGetFileCatalog.GetFileCatalogMock.callArgs, &mm_params)
	mmGetFileCatalog.GetFileCatalogMock.mutex.Unlock()

	for _, e := range mmGetFileCatalog.GetFileCatalogMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1, e.results.err
		}
	}

	if mmGetFileCatalog.GetFileCatalogMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFileCatalog.GetFileCatalogMock.defaultExpectation.Counter, 1)
		mm_want := mmGetFileCatalog.GetFileCatalogMock.defaultExpectation.params
		mm_want_ptrs := mmGetFileCatalog.GetFileCatalogMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockGetFileCatalogParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetFileCatalog.t.Errorf("ArtifactPublicServiceClientMock.GetFileCatalog got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmGetFileCatalog.t.Errorf("ArtifactPublicServiceClientMock.GetFileCatalog got unexpected parameter in, want: %#v, got: %#v%s\n", *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmGetFileCatalog.t.Errorf("ArtifactPublicServiceClientMock.GetFileCatalog got unexpected parameter opts, want: %#v, got: %#v%s\n", *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetFileCatalog.t.Errorf("ArtifactPublicServiceClientMock.GetFileCatalog got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetFileCatalog.GetFileCatalogMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFileCatalog.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.GetFileCatalog")
		}
		return (*mm_results).gp1, (*mm_results).err
	}
	if mmGetFileCatalog.funcGetFileCatalog != nil {
		return mmGetFileCatalog.funcGetFileCatalog(ctx, in, opts...)
	}
	mmGetFileCatalog.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.GetFileCatalog. %v %v %v", ctx, in, opts)
	return
}

// GetFileCatalogAfterCounter returns a count of finished ArtifactPublicServiceClientMock.GetFileCatalog invocations
func (mmGetFileCatalog *ArtifactPublicServiceClientMock) GetFileCatalogAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFileCatalog.afterGetFileCatalogCounter)
}

// GetFileCatalogBeforeCounter returns a count of ArtifactPublicServiceClientMock.GetFileCatalog invocations
func (mmGetFileCatalog *ArtifactPublicServiceClientMock) GetFileCatalogBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFileCatalog.beforeGetFileCatalogCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.GetFileCatalog.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetFileCatalog *mArtifactPublicServiceClientMockGetFileCatalog) Calls() []*ArtifactPublicServiceClientMockGetFileCatalogParams {
	mmGetFileCatalog.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockGetFileCatalogParams, len(mmGetFileCatalog.callArgs))
	copy(argCopy, mmGetFileCatalog.callArgs)

	mmGetFileCatalog.mutex.RUnlock()

	return argCopy
}

// MinimockGetFileCatalogDone returns true if the count of the GetFileCatalog invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockGetFileCatalogDone() bool {
	if m.GetFileCatalogMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetFileCatalogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetFileCatalogMock.invocationsDone()
}

// MinimockGetFileCatalogInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockGetFileCatalogInspect() {
	for _, e := range m.GetFileCatalogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetFileCatalog with params: %#v", *e.params)
		}
	}

	afterGetFileCatalogCounter := mm_atomic.LoadUint64(&m.afterGetFileCatalogCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetFileCatalogMock.defaultExpectation != nil && afterGetFileCatalogCounter < 1 {
		if m.GetFileCatalogMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ArtifactPublicServiceClientMock.GetFileCatalog")
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetFileCatalog with params: %#v", *m.GetFileCatalogMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFileCatalog != nil && afterGetFileCatalogCounter < 1 {
		m.t.Error("Expected call to ArtifactPublicServiceClientMock.GetFileCatalog")
	}

	if !m.GetFileCatalogMock.invocationsDone() && afterGetFileCatalogCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.GetFileCatalog but found %d calls",
			mm_atomic.LoadUint64(&m.GetFileCatalogMock.expectedInvocations), afterGetFileCatalogCounter)
	}
}

type mArtifactPublicServiceClientMockGetSourceFile struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockGetSourceFileExpectation
	expectations       []*ArtifactPublicServiceClientMockGetSourceFileExpectation

	callArgs []*ArtifactPublicServiceClientMockGetSourceFileParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ArtifactPublicServiceClientMockGetSourceFileExpectation specifies expectation struct of the ArtifactPublicServiceClient.GetSourceFile
type ArtifactPublicServiceClientMockGetSourceFileExpectation struct {
	mock      *ArtifactPublicServiceClientMock
	params    *ArtifactPublicServiceClientMockGetSourceFileParams
	paramPtrs *ArtifactPublicServiceClientMockGetSourceFileParamPtrs
	results   *ArtifactPublicServiceClientMockGetSourceFileResults
	Counter   uint64
}

// ArtifactPublicServiceClientMockGetSourceFileParams contains parameters of the ArtifactPublicServiceClient.GetSourceFile
type ArtifactPublicServiceClientMockGetSourceFileParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.GetSourceFileRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockGetSourceFileParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.GetSourceFile
type ArtifactPublicServiceClientMockGetSourceFileParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.GetSourceFileRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockGetSourceFileResults contains results of the ArtifactPublicServiceClient.GetSourceFile
type ArtifactPublicServiceClientMockGetSourceFileResults struct {
	gp1 *mm_artifactv1alpha.GetSourceFileResponse
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetSourceFile *mArtifactPublicServiceClientMockGetSourceFile) Optional() *mArtifactPublicServiceClientMockGetSourceFile {
	mmGetSourceFile.optional = true
	return mmGetSourceFile
}

// Expect sets up expected params for ArtifactPublicServiceClient.GetSourceFile
func (mmGetSourceFile *mArtifactPublicServiceClientMockGetSourceFile) Expect(ctx context.Context, in *mm_artifactv1alpha.GetSourceFileRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockGetSourceFile {
	if mmGetSourceFile.mock.funcGetSourceFile != nil {
		mmGetSourceFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetSourceFile mock is already set by Set")
	}

	if mmGetSourceFile.defaultExpectation == nil {
		mmGetSourceFile.defaultExpectation = &ArtifactPublicServiceClientMockGetSourceFileExpectation{}
	}

	if mmGetSourceFile.defaultExpectation.paramPtrs != nil {
		mmGetSourceFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetSourceFile mock is already set by ExpectParams functions")
	}

	mmGetSourceFile.defaultExpectation.params = &ArtifactPublicServiceClientMockGetSourceFileParams{ctx, in, opts}
	for _, e := range mmGetSourceFile.expectations {
		if minimock.Equal(e.params, mmGetSourceFile.defaultExpectation.params) {
			mmGetSourceFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetSourceFile.defaultExpectation.params)
		}
	}

	return mmGetSourceFile
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.GetSourceFile
func (mmGetSourceFile *mArtifactPublicServiceClientMockGetSourceFile) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockGetSourceFile {
	if mmGetSourceFile.mock.funcGetSourceFile != nil {
		mmGetSourceFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetSourceFile mock is already set by Set")
	}

	if mmGetSourceFile.defaultExpectation == nil {
		mmGetSourceFile.defaultExpectation = &ArtifactPublicServiceClientMockGetSourceFileExpectation{}
	}

	if mmGetSourceFile.defaultExpectation.params != nil {
		mmGetSourceFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetSourceFile mock is already set by Expect")
	}

	if mmGetSourceFile.defaultExpectation.paramPtrs == nil {
		mmGetSourceFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockGetSourceFileParamPtrs{}
	}
	mmGetSourceFile.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetSourceFile
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.GetSourceFile
func (mmGetSourceFile *mArtifactPublicServiceClientMockGetSourceFile) ExpectInParam2(in *mm_artifactv1alpha.GetSourceFileRequest) *mArtifactPublicServiceClientMockGetSourceFile {
	if mmGetSourceFile.mock.funcGetSourceFile != nil {
		mmGetSourceFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetSourceFile mock is already set by Set")
	}

	if mmGetSourceFile.defaultExpectation == nil {
		mmGetSourceFile.defaultExpectation = &ArtifactPublicServiceClientMockGetSourceFileExpectation{}
	}

	if mmGetSourceFile.defaultExpectation.params != nil {
		mmGetSourceFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetSourceFile mock is already set by Expect")
	}

	if mmGetSourceFile.defaultExpectation.paramPtrs == nil {
		mmGetSourceFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockGetSourceFileParamPtrs{}
	}
	mmGetSourceFile.defaultExpectation.paramPtrs.in = &in

	return mmGetSourceFile
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.GetSourceFile
func (mmGetSourceFile *mArtifactPublicServiceClientMockGetSourceFile) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockGetSourceFile {
	if mmGetSourceFile.mock.funcGetSourceFile != nil {
		mmGetSourceFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetSourceFile mock is already set by Set")
	}

	if mmGetSourceFile.defaultExpectation == nil {
		mmGetSourceFile.defaultExpectation = &ArtifactPublicServiceClientMockGetSourceFileExpectation{}
	}

	if mmGetSourceFile.defaultExpectation.params != nil {
		mmGetSourceFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetSourceFile mock is already set by Expect")
	}

	if mmGetSourceFile.defaultExpectation.paramPtrs == nil {
		mmGetSourceFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockGetSourceFileParamPtrs{}
	}
	mmGetSourceFile.defaultExpectation.paramPtrs.opts = &opts

	return mmGetSourceFile
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.GetSourceFile
func (mmGetSourceFile *mArtifactPublicServiceClientMockGetSourceFile) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.GetSourceFileRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockGetSourceFile {
	if mmGetSourceFile.mock.inspectFuncGetSourceFile != nil {
		mmGetSourceFile.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.GetSourceFile")
	}

	mmGetSourceFile.mock.inspectFuncGetSourceFile = f

	return mmGetSourceFile
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.GetSourceFile
func (mmGetSourceFile *mArtifactPublicServiceClientMockGetSourceFile) Return(gp1 *mm_artifactv1alpha.GetSourceFileResponse, err error) *ArtifactPublicServiceClientMock {
	if mmGetSourceFile.mock.funcGetSourceFile != nil {
		mmGetSourceFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetSourceFile mock is already set by Set")
	}

	if mmGetSourceFile.defaultExpectation == nil {
		mmGetSourceFile.defaultExpectation = &ArtifactPublicServiceClientMockGetSourceFileExpectation{mock: mmGetSourceFile.mock}
	}
	mmGetSourceFile.defaultExpectation.results = &ArtifactPublicServiceClientMockGetSourceFileResults{gp1, err}
	return mmGetSourceFile.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.GetSourceFile method
func (mmGetSourceFile *mArtifactPublicServiceClientMockGetSourceFile) Set(f func(ctx context.Context, in *mm_artifactv1alpha.GetSourceFileRequest, opts ...grpc.CallOption) (gp1 *mm_artifactv1alpha.GetSourceFileResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmGetSourceFile.defaultExpectation != nil {
		mmGetSourceFile.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.GetSourceFile method")
	}

	if len(mmGetSourceFile.expectations) > 0 {
		mmGetSourceFile.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.GetSourceFile method")
	}

	mmGetSourceFile.mock.funcGetSourceFile = f
	return mmGetSourceFile.mock
}

// When sets expectation for the ArtifactPublicServiceClient.GetSourceFile which will trigger the result defined by the following
// Then helper
func (mmGetSourceFile *mArtifactPublicServiceClientMockGetSourceFile) When(ctx context.Context, in *mm_artifactv1alpha.GetSourceFileRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockGetSourceFileExpectation {
	if mmGetSourceFile.mock.funcGetSourceFile != nil {
		mmGetSourceFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetSourceFile mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockGetSourceFileExpectation{
		mock:   mmGetSourceFile.mock,
		params: &ArtifactPublicServiceClientMockGetSourceFileParams{ctx, in, opts},
	}
	mmGetSourceFile.expectations = append(mmGetSourceFile.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.GetSourceFile return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockGetSourceFileExpectation) Then(gp1 *mm_artifactv1alpha.GetSourceFileResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockGetSourceFileResults{gp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.GetSourceFile should be invoked
func (mmGetSourceFile *mArtifactPublicServiceClientMockGetSourceFile) Times(n uint64) *mArtifactPublicServiceClientMockGetSourceFile {
	if n == 0 {
		mmGetSourceFile.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.GetSourceFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetSourceFile.expectedInvocations, n)
	return mmGetSourceFile
}

func (mmGetSourceFile *mArtifactPublicServiceClientMockGetSourceFile) invocationsDone() bool {
	if len(mmGetSourceFile.expectations) == 0 && mmGetSourceFile.defaultExpectation == nil && mmGetSourceFile.mock.funcGetSourceFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetSourceFile.mock.afterGetSourceFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetSourceFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetSourceFile implements artifactv1alpha.ArtifactPublicServiceClient
func (mmGetSourceFile *ArtifactPublicServiceClientMock) GetSourceFile(ctx context.Context, in *mm_artifactv1alpha.GetSourceFileRequest, opts ...grpc.CallOption) (gp1 *mm_artifactv1alpha.GetSourceFileResponse, err error) {
	mm_atomic.AddUint64(&mmGetSourceFile.beforeGetSourceFileCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSourceFile.afterGetSourceFileCounter, 1)

	if mmGetSourceFile.inspectFuncGetSourceFile != nil {
		mmGetSourceFile.inspectFuncGetSourceFile(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockGetSourceFileParams{ctx, in, opts}

	// Record call args
	mmGetSourceFile.GetSourceFileMock.mutex.Lock()
	mmGetSourceFile.GetSourceFileMock.callArgs = append(mmGetSourceFile.GetSourceFileMock.callArgs, &mm_params)
	mmGetSourceFile.GetSourceFileMock.mutex.Unlock()

	for _, e := range mmGetSourceFile.GetSourceFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1, e.results.err
		}
	}

	if mmGetSourceFile.GetSourceFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSourceFile.GetSourceFileMock.defaultExpectation.Counter, 1)
		mm_want := mmGetSourceFile.GetSourceFileMock.defaultExpectation.params
		mm_want_ptrs := mmGetSourceFile.GetSourceFileMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockGetSourceFileParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetSourceFile.t.Errorf("ArtifactPublicServiceClientMock.GetSourceFile got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmGetSourceFile.t.Errorf("ArtifactPublicServiceClientMock.GetSourceFile got unexpected parameter in, want: %#v, got: %#v%s\n", *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmGetSourceFile.t.Errorf("ArtifactPublicServiceClientMock.GetSourceFile got unexpected parameter opts, want: %#v, got: %#v%s\n", *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetSourceFile.t.Errorf("ArtifactPublicServiceClientMock.GetSourceFile got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetSourceFile.GetSourceFileMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSourceFile.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.GetSourceFile")
		}
		return (*mm_results).gp1, (*mm_results).err
	}
	if mmGetSourceFile.funcGetSourceFile != nil {
		return mmGetSourceFile.funcGetSourceFile(ctx, in, opts...)
	}
	mmGetSourceFile.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.GetSourceFile. %v %v %v", ctx, in, opts)
	return
}

// GetSourceFileAfterCounter returns a count of finished ArtifactPublicServiceClientMock.GetSourceFile invocations
func (mmGetSourceFile *ArtifactPublicServiceClientMock) GetSourceFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSourceFile.afterGetSourceFileCounter)
}

// GetSourceFileBeforeCounter returns a count of ArtifactPublicServiceClientMock.GetSourceFile invocations
func (mmGetSourceFile *ArtifactPublicServiceClientMock) GetSourceFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSourceFile.beforeGetSourceFileCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.GetSourceFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetSourceFile *mArtifactPublicServiceClientMockGetSourceFile) Calls() []*ArtifactPublicServiceClientMockGetSourceFileParams {
	mmGetSourceFile.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockGetSourceFileParams, len(mmGetSourceFile.callArgs))
	copy(argCopy, mmGetSourceFile.callArgs)

	mmGetSourceFile.mutex.RUnlock()

	return argCopy
}

// MinimockGetSourceFileDone returns true if the count of the GetSourceFile invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockGetSourceFileDone() bool {
	if m.GetSourceFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetSourceFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetSourceFileMock.invocationsDone()
}

// MinimockGetSourceFileInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockGetSourceFileInspect() {
	for _, e := range m.GetSourceFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetSourceFile with params: %#v", *e.params)
		}
	}

	afterGetSourceFileCounter := mm_atomic.LoadUint64(&m.afterGetSourceFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetSourceFileMock.defaultExpectation != nil && afterGetSourceFileCounter < 1 {
		if m.GetSourceFileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ArtifactPublicServiceClientMock.GetSourceFile")
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetSourceFile with params: %#v", *m.GetSourceFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSourceFile != nil && afterGetSourceFileCounter < 1 {
		m.t.Error("Expected call to ArtifactPublicServiceClientMock.GetSourceFile")
	}

	if !m.GetSourceFileMock.invocationsDone() && afterGetSourceFileCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.GetSourceFile but found %d calls",
			mm_atomic.LoadUint64(&m.GetSourceFileMock.expectedInvocations), afterGetSourceFileCounter)
	}
}

type mArtifactPublicServiceClientMockListCatalogFiles struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockListCatalogFilesExpectation
	expectations       []*ArtifactPublicServiceClientMockListCatalogFilesExpectation

	callArgs []*ArtifactPublicServiceClientMockListCatalogFilesParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ArtifactPublicServiceClientMockListCatalogFilesExpectation specifies expectation struct of the ArtifactPublicServiceClient.ListCatalogFiles
type ArtifactPublicServiceClientMockListCatalogFilesExpectation struct {
	mock      *ArtifactPublicServiceClientMock
	params    *ArtifactPublicServiceClientMockListCatalogFilesParams
	paramPtrs *ArtifactPublicServiceClientMockListCatalogFilesParamPtrs
	results   *ArtifactPublicServiceClientMockListCatalogFilesResults
	Counter   uint64
}

// ArtifactPublicServiceClientMockListCatalogFilesParams contains parameters of the ArtifactPublicServiceClient.ListCatalogFiles
type ArtifactPublicServiceClientMockListCatalogFilesParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.ListCatalogFilesRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockListCatalogFilesParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.ListCatalogFiles
type ArtifactPublicServiceClientMockListCatalogFilesParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.ListCatalogFilesRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockListCatalogFilesResults contains results of the ArtifactPublicServiceClient.ListCatalogFiles
type ArtifactPublicServiceClientMockListCatalogFilesResults struct {
	lp1 *mm_artifactv1alpha.ListCatalogFilesResponse
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListCatalogFiles *mArtifactPublicServiceClientMockListCatalogFiles) Optional() *mArtifactPublicServiceClientMockListCatalogFiles {
	mmListCatalogFiles.optional = true
	return mmListCatalogFiles
}

// Expect sets up expected params for ArtifactPublicServiceClient.ListCatalogFiles
func (mmListCatalogFiles *mArtifactPublicServiceClientMockListCatalogFiles) Expect(ctx context.Context, in *mm_artifactv1alpha.ListCatalogFilesRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockListCatalogFiles {
	if mmListCatalogFiles.mock.funcListCatalogFiles != nil {
		mmListCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogFiles mock is already set by Set")
	}

	if mmListCatalogFiles.defaultExpectation == nil {
		mmListCatalogFiles.defaultExpectation = &ArtifactPublicServiceClientMockListCatalogFilesExpectation{}
	}

	if mmListCatalogFiles.defaultExpectation.paramPtrs != nil {
		mmListCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogFiles mock is already set by ExpectParams functions")
	}

	mmListCatalogFiles.defaultExpectation.params = &ArtifactPublicServiceClientMockListCatalogFilesParams{ctx, in, opts}
	for _, e := range mmListCatalogFiles.expectations {
		if minimock.Equal(e.params, mmListCatalogFiles.defaultExpectation.params) {
			mmListCatalogFiles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListCatalogFiles.defaultExpectation.params)
		}
	}

	return mmListCatalogFiles
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.ListCatalogFiles
func (mmListCatalogFiles *mArtifactPublicServiceClientMockListCatalogFiles) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockListCatalogFiles {
	if mmListCatalogFiles.mock.funcListCatalogFiles != nil {
		mmListCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogFiles mock is already set by Set")
	}

	if mmListCatalogFiles.defaultExpectation == nil {
		mmListCatalogFiles.defaultExpectation = &ArtifactPublicServiceClientMockListCatalogFilesExpectation{}
	}

	if mmListCatalogFiles.defaultExpectation.params != nil {
		mmListCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogFiles mock is already set by Expect")
	}

	if mmListCatalogFiles.defaultExpectation.paramPtrs == nil {
		mmListCatalogFiles.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockListCatalogFilesParamPtrs{}
	}
	mmListCatalogFiles.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListCatalogFiles
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.ListCatalogFiles
func (mmListCatalogFiles *mArtifactPublicServiceClientMockListCatalogFiles) ExpectInParam2(in *mm_artifactv1alpha.ListCatalogFilesRequest) *mArtifactPublicServiceClientMockListCatalogFiles {
	if mmListCatalogFiles.mock.funcListCatalogFiles != nil {
		mmListCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogFiles mock is already set by Set")
	}

	if mmListCatalogFiles.defaultExpectation == nil {
		mmListCatalogFiles.defaultExpectation = &ArtifactPublicServiceClientMockListCatalogFilesExpectation{}
	}

	if mmListCatalogFiles.defaultExpectation.params != nil {
		mmListCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogFiles mock is already set by Expect")
	}

	if mmListCatalogFiles.defaultExpectation.paramPtrs == nil {
		mmListCatalogFiles.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockListCatalogFilesParamPtrs{}
	}
	mmListCatalogFiles.defaultExpectation.paramPtrs.in = &in

	return mmListCatalogFiles
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.ListCatalogFiles
func (mmListCatalogFiles *mArtifactPublicServiceClientMockListCatalogFiles) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockListCatalogFiles {
	if mmListCatalogFiles.mock.funcListCatalogFiles != nil {
		mmListCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogFiles mock is already set by Set")
	}

	if mmListCatalogFiles.defaultExpectation == nil {
		mmListCatalogFiles.defaultExpectation = &ArtifactPublicServiceClientMockListCatalogFilesExpectation{}
	}

	if mmListCatalogFiles.defaultExpectation.params != nil {
		mmListCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogFiles mock is already set by Expect")
	}

	if mmListCatalogFiles.defaultExpectation.paramPtrs == nil {
		mmListCatalogFiles.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockListCatalogFilesParamPtrs{}
	}
	mmListCatalogFiles.defaultExpectation.paramPtrs.opts = &opts

	return mmListCatalogFiles
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.ListCatalogFiles
func (mmListCatalogFiles *mArtifactPublicServiceClientMockListCatalogFiles) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.ListCatalogFilesRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockListCatalogFiles {
	if mmListCatalogFiles.mock.inspectFuncListCatalogFiles != nil {
		mmListCatalogFiles.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.ListCatalogFiles")
	}

	mmListCatalogFiles.mock.inspectFuncListCatalogFiles = f

	return mmListCatalogFiles
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.ListCatalogFiles
func (mmListCatalogFiles *mArtifactPublicServiceClientMockListCatalogFiles) Return(lp1 *mm_artifactv1alpha.ListCatalogFilesResponse, err error) *ArtifactPublicServiceClientMock {
	if mmListCatalogFiles.mock.funcListCatalogFiles != nil {
		mmListCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogFiles mock is already set by Set")
	}

	if mmListCatalogFiles.defaultExpectation == nil {
		mmListCatalogFiles.defaultExpectation = &ArtifactPublicServiceClientMockListCatalogFilesExpectation{mock: mmListCatalogFiles.mock}
	}
	mmListCatalogFiles.defaultExpectation.results = &ArtifactPublicServiceClientMockListCatalogFilesResults{lp1, err}
	return mmListCatalogFiles.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.ListCatalogFiles method
func (mmListCatalogFiles *mArtifactPublicServiceClientMockListCatalogFiles) Set(f func(ctx context.Context, in *mm_artifactv1alpha.ListCatalogFilesRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.ListCatalogFilesResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmListCatalogFiles.defaultExpectation != nil {
		mmListCatalogFiles.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.ListCatalogFiles method")
	}

	if len(mmListCatalogFiles.expectations) > 0 {
		mmListCatalogFiles.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.ListCatalogFiles method")
	}

	mmListCatalogFiles.mock.funcListCatalogFiles = f
	return mmListCatalogFiles.mock
}

// When sets expectation for the ArtifactPublicServiceClient.ListCatalogFiles which will trigger the result defined by the following
// Then helper
func (mmListCatalogFiles *mArtifactPublicServiceClientMockListCatalogFiles) When(ctx context.Context, in *mm_artifactv1alpha.ListCatalogFilesRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockListCatalogFilesExpectation {
	if mmListCatalogFiles.mock.funcListCatalogFiles != nil {
		mmListCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogFiles mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockListCatalogFilesExpectation{
		mock:   mmListCatalogFiles.mock,
		params: &ArtifactPublicServiceClientMockListCatalogFilesParams{ctx, in, opts},
	}
	mmListCatalogFiles.expectations = append(mmListCatalogFiles.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.ListCatalogFiles return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockListCatalogFilesExpectation) Then(lp1 *mm_artifactv1alpha.ListCatalogFilesResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockListCatalogFilesResults{lp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.ListCatalogFiles should be invoked
func (mmListCatalogFiles *mArtifactPublicServiceClientMockListCatalogFiles) Times(n uint64) *mArtifactPublicServiceClientMockListCatalogFiles {
	if n == 0 {
		mmListCatalogFiles.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.ListCatalogFiles mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListCatalogFiles.expectedInvocations, n)
	return mmListCatalogFiles
}

func (mmListCatalogFiles *mArtifactPublicServiceClientMockListCatalogFiles) invocationsDone() bool {
	if len(mmListCatalogFiles.expectations) == 0 && mmListCatalogFiles.defaultExpectation == nil && mmListCatalogFiles.mock.funcListCatalogFiles == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListCatalogFiles.mock.afterListCatalogFilesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListCatalogFiles.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListCatalogFiles implements artifactv1alpha.ArtifactPublicServiceClient
func (mmListCatalogFiles *ArtifactPublicServiceClientMock) ListCatalogFiles(ctx context.Context, in *mm_artifactv1alpha.ListCatalogFilesRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.ListCatalogFilesResponse, err error) {
	mm_atomic.AddUint64(&mmListCatalogFiles.beforeListCatalogFilesCounter, 1)
	defer mm_atomic.AddUint64(&mmListCatalogFiles.afterListCatalogFilesCounter, 1)

	if mmListCatalogFiles.inspectFuncListCatalogFiles != nil {
		mmListCatalogFiles.inspectFuncListCatalogFiles(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockListCatalogFilesParams{ctx, in, opts}

	// Record call args
	mmListCatalogFiles.ListCatalogFilesMock.mutex.Lock()
	mmListCatalogFiles.ListCatalogFilesMock.callArgs = append(mmListCatalogFiles.ListCatalogFilesMock.callArgs, &mm_params)
	mmListCatalogFiles.ListCatalogFilesMock.mutex.Unlock()

	for _, e := range mmListCatalogFiles.ListCatalogFilesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp1, e.results.err
		}
	}

	if mmListCatalogFiles.ListCatalogFilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListCatalogFiles.ListCatalogFilesMock.defaultExpectation.Counter, 1)
		mm_want := mmListCatalogFiles.ListCatalogFilesMock.defaultExpectation.params
		mm_want_ptrs := mmListCatalogFiles.ListCatalogFilesMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockListCatalogFilesParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListCatalogFiles.t.Errorf("ArtifactPublicServiceClientMock.ListCatalogFiles got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmListCatalogFiles.t.Errorf("ArtifactPublicServiceClientMock.ListCatalogFiles got unexpected parameter in, want: %#v, got: %#v%s\n", *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmListCatalogFiles.t.Errorf("ArtifactPublicServiceClientMock.ListCatalogFiles got unexpected parameter opts, want: %#v, got: %#v%s\n", *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListCatalogFiles.t.Errorf("ArtifactPublicServiceClientMock.ListCatalogFiles got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListCatalogFiles.ListCatalogFilesMock.defaultExpectation.results
		if mm_results == nil {
			mmListCatalogFiles.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.ListCatalogFiles")
		}
		return (*mm_results).lp1, (*mm_results).err
	}
	if mmListCatalogFiles.funcListCatalogFiles != nil {
		return mmListCatalogFiles.funcListCatalogFiles(ctx, in, opts...)
	}
	mmListCatalogFiles.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.ListCatalogFiles. %v %v %v", ctx, in, opts)
	return
}

// ListCatalogFilesAfterCounter returns a count of finished ArtifactPublicServiceClientMock.ListCatalogFiles invocations
func (mmListCatalogFiles *ArtifactPublicServiceClientMock) ListCatalogFilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCatalogFiles.afterListCatalogFilesCounter)
}

// ListCatalogFilesBeforeCounter returns a count of ArtifactPublicServiceClientMock.ListCatalogFiles invocations
func (mmListCatalogFiles *ArtifactPublicServiceClientMock) ListCatalogFilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCatalogFiles.beforeListCatalogFilesCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.ListCatalogFiles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListCatalogFiles *mArtifactPublicServiceClientMockListCatalogFiles) Calls() []*ArtifactPublicServiceClientMockListCatalogFilesParams {
	mmListCatalogFiles.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockListCatalogFilesParams, len(mmListCatalogFiles.callArgs))
	copy(argCopy, mmListCatalogFiles.callArgs)

	mmListCatalogFiles.mutex.RUnlock()

	return argCopy
}

// MinimockListCatalogFilesDone returns true if the count of the ListCatalogFiles invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockListCatalogFilesDone() bool {
	if m.ListCatalogFilesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListCatalogFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListCatalogFilesMock.invocationsDone()
}

// MinimockListCatalogFilesInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockListCatalogFilesInspect() {
	for _, e := range m.ListCatalogFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListCatalogFiles with params: %#v", *e.params)
		}
	}

	afterListCatalogFilesCounter := mm_atomic.LoadUint64(&m.afterListCatalogFilesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListCatalogFilesMock.defaultExpectation != nil && afterListCatalogFilesCounter < 1 {
		if m.ListCatalogFilesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ArtifactPublicServiceClientMock.ListCatalogFiles")
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListCatalogFiles with params: %#v", *m.ListCatalogFilesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListCatalogFiles != nil && afterListCatalogFilesCounter < 1 {
		m.t.Error("Expected call to ArtifactPublicServiceClientMock.ListCatalogFiles")
	}

	if !m.ListCatalogFilesMock.invocationsDone() && afterListCatalogFilesCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.ListCatalogFiles but found %d calls",
			mm_atomic.LoadUint64(&m.ListCatalogFilesMock.expectedInvocations), afterListCatalogFilesCounter)
	}
}

type mArtifactPublicServiceClientMockListCatalogs struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockListCatalogsExpectation
	expectations       []*ArtifactPublicServiceClientMockListCatalogsExpectation

	callArgs []*ArtifactPublicServiceClientMockListCatalogsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ArtifactPublicServiceClientMockListCatalogsExpectation specifies expectation struct of the ArtifactPublicServiceClient.ListCatalogs
type ArtifactPublicServiceClientMockListCatalogsExpectation struct {
	mock      *ArtifactPublicServiceClientMock
	params    *ArtifactPublicServiceClientMockListCatalogsParams
	paramPtrs *ArtifactPublicServiceClientMockListCatalogsParamPtrs
	results   *ArtifactPublicServiceClientMockListCatalogsResults
	Counter   uint64
}

// ArtifactPublicServiceClientMockListCatalogsParams contains parameters of the ArtifactPublicServiceClient.ListCatalogs
type ArtifactPublicServiceClientMockListCatalogsParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.ListCatalogsRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockListCatalogsParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.ListCatalogs
type ArtifactPublicServiceClientMockListCatalogsParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.ListCatalogsRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockListCatalogsResults contains results of the ArtifactPublicServiceClient.ListCatalogs
type ArtifactPublicServiceClientMockListCatalogsResults struct {
	lp1 *mm_artifactv1alpha.ListCatalogsResponse
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListCatalogs *mArtifactPublicServiceClientMockListCatalogs) Optional() *mArtifactPublicServiceClientMockListCatalogs {
	mmListCatalogs.optional = true
	return mmListCatalogs
}

// Expect sets up expected params for ArtifactPublicServiceClient.ListCatalogs
func (mmListCatalogs *mArtifactPublicServiceClientMockListCatalogs) Expect(ctx context.Context, in *mm_artifactv1alpha.ListCatalogsRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockListCatalogs {
	if mmListCatalogs.mock.funcListCatalogs != nil {
		mmListCatalogs.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogs mock is already set by Set")
	}

	if mmListCatalogs.defaultExpectation == nil {
		mmListCatalogs.defaultExpectation = &ArtifactPublicServiceClientMockListCatalogsExpectation{}
	}

	if mmListCatalogs.defaultExpectation.paramPtrs != nil {
		mmListCatalogs.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogs mock is already set by ExpectParams functions")
	}

	mmListCatalogs.defaultExpectation.params = &ArtifactPublicServiceClientMockListCatalogsParams{ctx, in, opts}
	for _, e := range mmListCatalogs.expectations {
		if minimock.Equal(e.params, mmListCatalogs.defaultExpectation.params) {
			mmListCatalogs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListCatalogs.defaultExpectation.params)
		}
	}

	return mmListCatalogs
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.ListCatalogs
func (mmListCatalogs *mArtifactPublicServiceClientMockListCatalogs) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockListCatalogs {
	if mmListCatalogs.mock.funcListCatalogs != nil {
		mmListCatalogs.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogs mock is already set by Set")
	}

	if mmListCatalogs.defaultExpectation == nil {
		mmListCatalogs.defaultExpectation = &ArtifactPublicServiceClientMockListCatalogsExpectation{}
	}

	if mmListCatalogs.defaultExpectation.params != nil {
		mmListCatalogs.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogs mock is already set by Expect")
	}

	if mmListCatalogs.defaultExpectation.paramPtrs == nil {
		mmListCatalogs.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockListCatalogsParamPtrs{}
	}
	mmListCatalogs.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListCatalogs
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.ListCatalogs
func (mmListCatalogs *mArtifactPublicServiceClientMockListCatalogs) ExpectInParam2(in *mm_artifactv1alpha.ListCatalogsRequest) *mArtifactPublicServiceClientMockListCatalogs {
	if mmListCatalogs.mock.funcListCatalogs != nil {
		mmListCatalogs.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogs mock is already set by Set")
	}

	if mmListCatalogs.defaultExpectation == nil {
		mmListCatalogs.defaultExpectation = &ArtifactPublicServiceClientMockListCatalogsExpectation{}
	}

	if mmListCatalogs.defaultExpectation.params != nil {
		mmListCatalogs.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogs mock is already set by Expect")
	}

	if mmListCatalogs.defaultExpectation.paramPtrs == nil {
		mmListCatalogs.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockListCatalogsParamPtrs{}
	}
	mmListCatalogs.defaultExpectation.paramPtrs.in = &in

	return mmListCatalogs
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.ListCatalogs
func (mmListCatalogs *mArtifactPublicServiceClientMockListCatalogs) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockListCatalogs {
	if mmListCatalogs.mock.funcListCatalogs != nil {
		mmListCatalogs.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogs mock is already set by Set")
	}

	if mmListCatalogs.defaultExpectation == nil {
		mmListCatalogs.defaultExpectation = &ArtifactPublicServiceClientMockListCatalogsExpectation{}
	}

	if mmListCatalogs.defaultExpectation.params != nil {
		mmListCatalogs.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogs mock is already set by Expect")
	}

	if mmListCatalogs.defaultExpectation.paramPtrs == nil {
		mmListCatalogs.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockListCatalogsParamPtrs{}
	}
	mmListCatalogs.defaultExpectation.paramPtrs.opts = &opts

	return mmListCatalogs
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.ListCatalogs
func (mmListCatalogs *mArtifactPublicServiceClientMockListCatalogs) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.ListCatalogsRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockListCatalogs {
	if mmListCatalogs.mock.inspectFuncListCatalogs != nil {
		mmListCatalogs.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.ListCatalogs")
	}

	mmListCatalogs.mock.inspectFuncListCatalogs = f

	return mmListCatalogs
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.ListCatalogs
func (mmListCatalogs *mArtifactPublicServiceClientMockListCatalogs) Return(lp1 *mm_artifactv1alpha.ListCatalogsResponse, err error) *ArtifactPublicServiceClientMock {
	if mmListCatalogs.mock.funcListCatalogs != nil {
		mmListCatalogs.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogs mock is already set by Set")
	}

	if mmListCatalogs.defaultExpectation == nil {
		mmListCatalogs.defaultExpectation = &ArtifactPublicServiceClientMockListCatalogsExpectation{mock: mmListCatalogs.mock}
	}
	mmListCatalogs.defaultExpectation.results = &ArtifactPublicServiceClientMockListCatalogsResults{lp1, err}
	return mmListCatalogs.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.ListCatalogs method
func (mmListCatalogs *mArtifactPublicServiceClientMockListCatalogs) Set(f func(ctx context.Context, in *mm_artifactv1alpha.ListCatalogsRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.ListCatalogsResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmListCatalogs.defaultExpectation != nil {
		mmListCatalogs.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.ListCatalogs method")
	}

	if len(mmListCatalogs.expectations) > 0 {
		mmListCatalogs.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.ListCatalogs method")
	}

	mmListCatalogs.mock.funcListCatalogs = f
	return mmListCatalogs.mock
}

// When sets expectation for the ArtifactPublicServiceClient.ListCatalogs which will trigger the result defined by the following
// Then helper
func (mmListCatalogs *mArtifactPublicServiceClientMockListCatalogs) When(ctx context.Context, in *mm_artifactv1alpha.ListCatalogsRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockListCatalogsExpectation {
	if mmListCatalogs.mock.funcListCatalogs != nil {
		mmListCatalogs.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogs mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockListCatalogsExpectation{
		mock:   mmListCatalogs.mock,
		params: &ArtifactPublicServiceClientMockListCatalogsParams{ctx, in, opts},
	}
	mmListCatalogs.expectations = append(mmListCatalogs.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.ListCatalogs return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockListCatalogsExpectation) Then(lp1 *mm_artifactv1alpha.ListCatalogsResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockListCatalogsResults{lp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.ListCatalogs should be invoked
func (mmListCatalogs *mArtifactPublicServiceClientMockListCatalogs) Times(n uint64) *mArtifactPublicServiceClientMockListCatalogs {
	if n == 0 {
		mmListCatalogs.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.ListCatalogs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListCatalogs.expectedInvocations, n)
	return mmListCatalogs
}

func (mmListCatalogs *mArtifactPublicServiceClientMockListCatalogs) invocationsDone() bool {
	if len(mmListCatalogs.expectations) == 0 && mmListCatalogs.defaultExpectation == nil && mmListCatalogs.mock.funcListCatalogs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListCatalogs.mock.afterListCatalogsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListCatalogs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListCatalogs implements artifactv1alpha.ArtifactPublicServiceClient
func (mmListCatalogs *ArtifactPublicServiceClientMock) ListCatalogs(ctx context.Context, in *mm_artifactv1alpha.ListCatalogsRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.ListCatalogsResponse, err error) {
	mm_atomic.AddUint64(&mmListCatalogs.beforeListCatalogsCounter, 1)
	defer mm_atomic.AddUint64(&mmListCatalogs.afterListCatalogsCounter, 1)

	if mmListCatalogs.inspectFuncListCatalogs != nil {
		mmListCatalogs.inspectFuncListCatalogs(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockListCatalogsParams{ctx, in, opts}

	// Record call args
	mmListCatalogs.ListCatalogsMock.mutex.Lock()
	mmListCatalogs.ListCatalogsMock.callArgs = append(mmListCatalogs.ListCatalogsMock.callArgs, &mm_params)
	mmListCatalogs.ListCatalogsMock.mutex.Unlock()

	for _, e := range mmListCatalogs.ListCatalogsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp1, e.results.err
		}
	}

	if mmListCatalogs.ListCatalogsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListCatalogs.ListCatalogsMock.defaultExpectation.Counter, 1)
		mm_want := mmListCatalogs.ListCatalogsMock.defaultExpectation.params
		mm_want_ptrs := mmListCatalogs.ListCatalogsMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockListCatalogsParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListCatalogs.t.Errorf("ArtifactPublicServiceClientMock.ListCatalogs got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmListCatalogs.t.Errorf("ArtifactPublicServiceClientMock.ListCatalogs got unexpected parameter in, want: %#v, got: %#v%s\n", *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmListCatalogs.t.Errorf("ArtifactPublicServiceClientMock.ListCatalogs got unexpected parameter opts, want: %#v, got: %#v%s\n", *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListCatalogs.t.Errorf("ArtifactPublicServiceClientMock.ListCatalogs got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListCatalogs.ListCatalogsMock.defaultExpectation.results
		if mm_results == nil {
			mmListCatalogs.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.ListCatalogs")
		}
		return (*mm_results).lp1, (*mm_results).err
	}
	if mmListCatalogs.funcListCatalogs != nil {
		return mmListCatalogs.funcListCatalogs(ctx, in, opts...)
	}
	mmListCatalogs.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.ListCatalogs. %v %v %v", ctx, in, opts)
	return
}

// ListCatalogsAfterCounter returns a count of finished ArtifactPublicServiceClientMock.ListCatalogs invocations
func (mmListCatalogs *ArtifactPublicServiceClientMock) ListCatalogsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCatalogs.afterListCatalogsCounter)
}

// ListCatalogsBeforeCounter returns a count of ArtifactPublicServiceClientMock.ListCatalogs invocations
func (mmListCatalogs *ArtifactPublicServiceClientMock) ListCatalogsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCatalogs.beforeListCatalogsCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.ListCatalogs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListCatalogs *mArtifactPublicServiceClientMockListCatalogs) Calls() []*ArtifactPublicServiceClientMockListCatalogsParams {
	mmListCatalogs.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockListCatalogsParams, len(mmListCatalogs.callArgs))
	copy(argCopy, mmListCatalogs.callArgs)

	mmListCatalogs.mutex.RUnlock()

	return argCopy
}

// MinimockListCatalogsDone returns true if the count of the ListCatalogs invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockListCatalogsDone() bool {
	if m.ListCatalogsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListCatalogsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListCatalogsMock.invocationsDone()
}

// MinimockListCatalogsInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockListCatalogsInspect() {
	for _, e := range m.ListCatalogsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListCatalogs with params: %#v", *e.params)
		}
	}

	afterListCatalogsCounter := mm_atomic.LoadUint64(&m.afterListCatalogsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListCatalogsMock.defaultExpectation != nil && afterListCatalogsCounter < 1 {
		if m.ListCatalogsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ArtifactPublicServiceClientMock.ListCatalogs")
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListCatalogs with params: %#v", *m.ListCatalogsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListCatalogs != nil && afterListCatalogsCounter < 1 {
		m.t.Error("Expected call to ArtifactPublicServiceClientMock.ListCatalogs")
	}

	if !m.ListCatalogsMock.invocationsDone() && afterListCatalogsCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.ListCatalogs but found %d calls",
			mm_atomic.LoadUint64(&m.ListCatalogsMock.expectedInvocations), afterListCatalogsCounter)
	}
}

type mArtifactPublicServiceClientMockListChunks struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockListChunksExpectation
	expectations       []*ArtifactPublicServiceClientMockListChunksExpectation

	callArgs []*ArtifactPublicServiceClientMockListChunksParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ArtifactPublicServiceClientMockListChunksExpectation specifies expectation struct of the ArtifactPublicServiceClient.ListChunks
type ArtifactPublicServiceClientMockListChunksExpectation struct {
	mock      *ArtifactPublicServiceClientMock
	params    *ArtifactPublicServiceClientMockListChunksParams
	paramPtrs *ArtifactPublicServiceClientMockListChunksParamPtrs
	results   *ArtifactPublicServiceClientMockListChunksResults
	Counter   uint64
}

// ArtifactPublicServiceClientMockListChunksParams contains parameters of the ArtifactPublicServiceClient.ListChunks
type ArtifactPublicServiceClientMockListChunksParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.ListChunksRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockListChunksParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.ListChunks
type ArtifactPublicServiceClientMockListChunksParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.ListChunksRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockListChunksResults contains results of the ArtifactPublicServiceClient.ListChunks
type ArtifactPublicServiceClientMockListChunksResults struct {
	lp1 *mm_artifactv1alpha.ListChunksResponse
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListChunks *mArtifactPublicServiceClientMockListChunks) Optional() *mArtifactPublicServiceClientMockListChunks {
	mmListChunks.optional = true
	return mmListChunks
}

// Expect sets up expected params for ArtifactPublicServiceClient.ListChunks
func (mmListChunks *mArtifactPublicServiceClientMockListChunks) Expect(ctx context.Context, in *mm_artifactv1alpha.ListChunksRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockListChunks {
	if mmListChunks.mock.funcListChunks != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListChunks mock is already set by Set")
	}

	if mmListChunks.defaultExpectation == nil {
		mmListChunks.defaultExpectation = &ArtifactPublicServiceClientMockListChunksExpectation{}
	}

	if mmListChunks.defaultExpectation.paramPtrs != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListChunks mock is already set by ExpectParams functions")
	}

	mmListChunks.defaultExpectation.params = &ArtifactPublicServiceClientMockListChunksParams{ctx, in, opts}
	for _, e := range mmListChunks.expectations {
		if minimock.Equal(e.params, mmListChunks.defaultExpectation.params) {
			mmListChunks.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListChunks.defaultExpectation.params)
		}
	}

	return mmListChunks
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.ListChunks
func (mmListChunks *mArtifactPublicServiceClientMockListChunks) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockListChunks {
	if mmListChunks.mock.funcListChunks != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListChunks mock is already set by Set")
	}

	if mmListChunks.defaultExpectation == nil {
		mmListChunks.defaultExpectation = &ArtifactPublicServiceClientMockListChunksExpectation{}
	}

	if mmListChunks.defaultExpectation.params != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListChunks mock is already set by Expect")
	}

	if mmListChunks.defaultExpectation.paramPtrs == nil {
		mmListChunks.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockListChunksParamPtrs{}
	}
	mmListChunks.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListChunks
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.ListChunks
func (mmListChunks *mArtifactPublicServiceClientMockListChunks) ExpectInParam2(in *mm_artifactv1alpha.ListChunksRequest) *mArtifactPublicServiceClientMockListChunks {
	if mmListChunks.mock.funcListChunks != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListChunks mock is already set by Set")
	}

	if mmListChunks.defaultExpectation == nil {
		mmListChunks.defaultExpectation = &ArtifactPublicServiceClientMockListChunksExpectation{}
	}

	if mmListChunks.defaultExpectation.params != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListChunks mock is already set by Expect")
	}

	if mmListChunks.defaultExpectation.paramPtrs == nil {
		mmListChunks.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockListChunksParamPtrs{}
	}
	mmListChunks.defaultExpectation.paramPtrs.in = &in

	return mmListChunks
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.ListChunks
func (mmListChunks *mArtifactPublicServiceClientMockListChunks) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockListChunks {
	if mmListChunks.mock.funcListChunks != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListChunks mock is already set by Set")
	}

	if mmListChunks.defaultExpectation == nil {
		mmListChunks.defaultExpectation = &ArtifactPublicServiceClientMockListChunksExpectation{}
	}

	if mmListChunks.defaultExpectation.params != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListChunks mock is already set by Expect")
	}

	if mmListChunks.defaultExpectation.paramPtrs == nil {
		mmListChunks.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockListChunksParamPtrs{}
	}
	mmListChunks.defaultExpectation.paramPtrs.opts = &opts

	return mmListChunks
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.ListChunks
func (mmListChunks *mArtifactPublicServiceClientMockListChunks) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.ListChunksRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockListChunks {
	if mmListChunks.mock.inspectFuncListChunks != nil {
		mmListChunks.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.ListChunks")
	}

	mmListChunks.mock.inspectFuncListChunks = f

	return mmListChunks
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.ListChunks
func (mmListChunks *mArtifactPublicServiceClientMockListChunks) Return(lp1 *mm_artifactv1alpha.ListChunksResponse, err error) *ArtifactPublicServiceClientMock {
	if mmListChunks.mock.funcListChunks != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListChunks mock is already set by Set")
	}

	if mmListChunks.defaultExpectation == nil {
		mmListChunks.defaultExpectation = &ArtifactPublicServiceClientMockListChunksExpectation{mock: mmListChunks.mock}
	}
	mmListChunks.defaultExpectation.results = &ArtifactPublicServiceClientMockListChunksResults{lp1, err}
	return mmListChunks.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.ListChunks method
func (mmListChunks *mArtifactPublicServiceClientMockListChunks) Set(f func(ctx context.Context, in *mm_artifactv1alpha.ListChunksRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.ListChunksResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmListChunks.defaultExpectation != nil {
		mmListChunks.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.ListChunks method")
	}

	if len(mmListChunks.expectations) > 0 {
		mmListChunks.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.ListChunks method")
	}

	mmListChunks.mock.funcListChunks = f
	return mmListChunks.mock
}

// When sets expectation for the ArtifactPublicServiceClient.ListChunks which will trigger the result defined by the following
// Then helper
func (mmListChunks *mArtifactPublicServiceClientMockListChunks) When(ctx context.Context, in *mm_artifactv1alpha.ListChunksRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockListChunksExpectation {
	if mmListChunks.mock.funcListChunks != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListChunks mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockListChunksExpectation{
		mock:   mmListChunks.mock,
		params: &ArtifactPublicServiceClientMockListChunksParams{ctx, in, opts},
	}
	mmListChunks.expectations = append(mmListChunks.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.ListChunks return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockListChunksExpectation) Then(lp1 *mm_artifactv1alpha.ListChunksResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockListChunksResults{lp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.ListChunks should be invoked
func (mmListChunks *mArtifactPublicServiceClientMockListChunks) Times(n uint64) *mArtifactPublicServiceClientMockListChunks {
	if n == 0 {
		mmListChunks.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.ListChunks mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListChunks.expectedInvocations, n)
	return mmListChunks
}

func (mmListChunks *mArtifactPublicServiceClientMockListChunks) invocationsDone() bool {
	if len(mmListChunks.expectations) == 0 && mmListChunks.defaultExpectation == nil && mmListChunks.mock.funcListChunks == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListChunks.mock.afterListChunksCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListChunks.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListChunks implements artifactv1alpha.ArtifactPublicServiceClient
func (mmListChunks *ArtifactPublicServiceClientMock) ListChunks(ctx context.Context, in *mm_artifactv1alpha.ListChunksRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.ListChunksResponse, err error) {
	mm_atomic.AddUint64(&mmListChunks.beforeListChunksCounter, 1)
	defer mm_atomic.AddUint64(&mmListChunks.afterListChunksCounter, 1)

	if mmListChunks.inspectFuncListChunks != nil {
		mmListChunks.inspectFuncListChunks(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockListChunksParams{ctx, in, opts}

	// Record call args
	mmListChunks.ListChunksMock.mutex.Lock()
	mmListChunks.ListChunksMock.callArgs = append(mmListChunks.ListChunksMock.callArgs, &mm_params)
	mmListChunks.ListChunksMock.mutex.Unlock()

	for _, e := range mmListChunks.ListChunksMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp1, e.results.err
		}
	}

	if mmListChunks.ListChunksMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListChunks.ListChunksMock.defaultExpectation.Counter, 1)
		mm_want := mmListChunks.ListChunksMock.defaultExpectation.params
		mm_want_ptrs := mmListChunks.ListChunksMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockListChunksParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListChunks.t.Errorf("ArtifactPublicServiceClientMock.ListChunks got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmListChunks.t.Errorf("ArtifactPublicServiceClientMock.ListChunks got unexpected parameter in, want: %#v, got: %#v%s\n", *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmListChunks.t.Errorf("ArtifactPublicServiceClientMock.ListChunks got unexpected parameter opts, want: %#v, got: %#v%s\n", *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListChunks.t.Errorf("ArtifactPublicServiceClientMock.ListChunks got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListChunks.ListChunksMock.defaultExpectation.results
		if mm_results == nil {
			mmListChunks.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.ListChunks")
		}
		return (*mm_results).lp1, (*mm_results).err
	}
	if mmListChunks.funcListChunks != nil {
		return mmListChunks.funcListChunks(ctx, in, opts...)
	}
	mmListChunks.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.ListChunks. %v %v %v", ctx, in, opts)
	return
}

// ListChunksAfterCounter returns a count of finished ArtifactPublicServiceClientMock.ListChunks invocations
func (mmListChunks *ArtifactPublicServiceClientMock) ListChunksAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListChunks.afterListChunksCounter)
}

// ListChunksBeforeCounter returns a count of ArtifactPublicServiceClientMock.ListChunks invocations
func (mmListChunks *ArtifactPublicServiceClientMock) ListChunksBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListChunks.beforeListChunksCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.ListChunks.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListChunks *mArtifactPublicServiceClientMockListChunks) Calls() []*ArtifactPublicServiceClientMockListChunksParams {
	mmListChunks.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockListChunksParams, len(mmListChunks.callArgs))
	copy(argCopy, mmListChunks.callArgs)

	mmListChunks.mutex.RUnlock()

	return argCopy
}

// MinimockListChunksDone returns true if the count of the ListChunks invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockListChunksDone() bool {
	if m.ListChunksMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListChunksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListChunksMock.invocationsDone()
}

// MinimockListChunksInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockListChunksInspect() {
	for _, e := range m.ListChunksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListChunks with params: %#v", *e.params)
		}
	}

	afterListChunksCounter := mm_atomic.LoadUint64(&m.afterListChunksCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListChunksMock.defaultExpectation != nil && afterListChunksCounter < 1 {
		if m.ListChunksMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ArtifactPublicServiceClientMock.ListChunks")
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListChunks with params: %#v", *m.ListChunksMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListChunks != nil && afterListChunksCounter < 1 {
		m.t.Error("Expected call to ArtifactPublicServiceClientMock.ListChunks")
	}

	if !m.ListChunksMock.invocationsDone() && afterListChunksCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.ListChunks but found %d calls",
			mm_atomic.LoadUint64(&m.ListChunksMock.expectedInvocations), afterListChunksCounter)
	}
}

type mArtifactPublicServiceClientMockListConversations struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockListConversationsExpectation
	expectations       []*ArtifactPublicServiceClientMockListConversationsExpectation

	callArgs []*ArtifactPublicServiceClientMockListConversationsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ArtifactPublicServiceClientMockListConversationsExpectation specifies expectation struct of the ArtifactPublicServiceClient.ListConversations
type ArtifactPublicServiceClientMockListConversationsExpectation struct {
	mock      *ArtifactPublicServiceClientMock
	params    *ArtifactPublicServiceClientMockListConversationsParams
	paramPtrs *ArtifactPublicServiceClientMockListConversationsParamPtrs
	results   *ArtifactPublicServiceClientMockListConversationsResults
	Counter   uint64
}

// ArtifactPublicServiceClientMockListConversationsParams contains parameters of the ArtifactPublicServiceClient.ListConversations
type ArtifactPublicServiceClientMockListConversationsParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.ListConversationsRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockListConversationsParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.ListConversations
type ArtifactPublicServiceClientMockListConversationsParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.ListConversationsRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockListConversationsResults contains results of the ArtifactPublicServiceClient.ListConversations
type ArtifactPublicServiceClientMockListConversationsResults struct {
	lp1 *mm_artifactv1alpha.ListConversationsResponse
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListConversations *mArtifactPublicServiceClientMockListConversations) Optional() *mArtifactPublicServiceClientMockListConversations {
	mmListConversations.optional = true
	return mmListConversations
}

// Expect sets up expected params for ArtifactPublicServiceClient.ListConversations
func (mmListConversations *mArtifactPublicServiceClientMockListConversations) Expect(ctx context.Context, in *mm_artifactv1alpha.ListConversationsRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockListConversations {
	if mmListConversations.mock.funcListConversations != nil {
		mmListConversations.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListConversations mock is already set by Set")
	}

	if mmListConversations.defaultExpectation == nil {
		mmListConversations.defaultExpectation = &ArtifactPublicServiceClientMockListConversationsExpectation{}
	}

	if mmListConversations.defaultExpectation.paramPtrs != nil {
		mmListConversations.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListConversations mock is already set by ExpectParams functions")
	}

	mmListConversations.defaultExpectation.params = &ArtifactPublicServiceClientMockListConversationsParams{ctx, in, opts}
	for _, e := range mmListConversations.expectations {
		if minimock.Equal(e.params, mmListConversations.defaultExpectation.params) {
			mmListConversations.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListConversations.defaultExpectation.params)
		}
	}

	return mmListConversations
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.ListConversations
func (mmListConversations *mArtifactPublicServiceClientMockListConversations) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockListConversations {
	if mmListConversations.mock.funcListConversations != nil {
		mmListConversations.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListConversations mock is already set by Set")
	}

	if mmListConversations.defaultExpectation == nil {
		mmListConversations.defaultExpectation = &ArtifactPublicServiceClientMockListConversationsExpectation{}
	}

	if mmListConversations.defaultExpectation.params != nil {
		mmListConversations.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListConversations mock is already set by Expect")
	}

	if mmListConversations.defaultExpectation.paramPtrs == nil {
		mmListConversations.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockListConversationsParamPtrs{}
	}
	mmListConversations.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListConversations
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.ListConversations
func (mmListConversations *mArtifactPublicServiceClientMockListConversations) ExpectInParam2(in *mm_artifactv1alpha.ListConversationsRequest) *mArtifactPublicServiceClientMockListConversations {
	if mmListConversations.mock.funcListConversations != nil {
		mmListConversations.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListConversations mock is already set by Set")
	}

	if mmListConversations.defaultExpectation == nil {
		mmListConversations.defaultExpectation = &ArtifactPublicServiceClientMockListConversationsExpectation{}
	}

	if mmListConversations.defaultExpectation.params != nil {
		mmListConversations.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListConversations mock is already set by Expect")
	}

	if mmListConversations.defaultExpectation.paramPtrs == nil {
		mmListConversations.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockListConversationsParamPtrs{}
	}
	mmListConversations.defaultExpectation.paramPtrs.in = &in

	return mmListConversations
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.ListConversations
func (mmListConversations *mArtifactPublicServiceClientMockListConversations) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockListConversations {
	if mmListConversations.mock.funcListConversations != nil {
		mmListConversations.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListConversations mock is already set by Set")
	}

	if mmListConversations.defaultExpectation == nil {
		mmListConversations.defaultExpectation = &ArtifactPublicServiceClientMockListConversationsExpectation{}
	}

	if mmListConversations.defaultExpectation.params != nil {
		mmListConversations.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListConversations mock is already set by Expect")
	}

	if mmListConversations.defaultExpectation.paramPtrs == nil {
		mmListConversations.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockListConversationsParamPtrs{}
	}
	mmListConversations.defaultExpectation.paramPtrs.opts = &opts

	return mmListConversations
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.ListConversations
func (mmListConversations *mArtifactPublicServiceClientMockListConversations) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.ListConversationsRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockListConversations {
	if mmListConversations.mock.inspectFuncListConversations != nil {
		mmListConversations.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.ListConversations")
	}

	mmListConversations.mock.inspectFuncListConversations = f

	return mmListConversations
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.ListConversations
func (mmListConversations *mArtifactPublicServiceClientMockListConversations) Return(lp1 *mm_artifactv1alpha.ListConversationsResponse, err error) *ArtifactPublicServiceClientMock {
	if mmListConversations.mock.funcListConversations != nil {
		mmListConversations.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListConversations mock is already set by Set")
	}

	if mmListConversations.defaultExpectation == nil {
		mmListConversations.defaultExpectation = &ArtifactPublicServiceClientMockListConversationsExpectation{mock: mmListConversations.mock}
	}
	mmListConversations.defaultExpectation.results = &ArtifactPublicServiceClientMockListConversationsResults{lp1, err}
	return mmListConversations.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.ListConversations method
func (mmListConversations *mArtifactPublicServiceClientMockListConversations) Set(f func(ctx context.Context, in *mm_artifactv1alpha.ListConversationsRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.ListConversationsResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmListConversations.defaultExpectation != nil {
		mmListConversations.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.ListConversations method")
	}

	if len(mmListConversations.expectations) > 0 {
		mmListConversations.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.ListConversations method")
	}

	mmListConversations.mock.funcListConversations = f
	return mmListConversations.mock
}

// When sets expectation for the ArtifactPublicServiceClient.ListConversations which will trigger the result defined by the following
// Then helper
func (mmListConversations *mArtifactPublicServiceClientMockListConversations) When(ctx context.Context, in *mm_artifactv1alpha.ListConversationsRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockListConversationsExpectation {
	if mmListConversations.mock.funcListConversations != nil {
		mmListConversations.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListConversations mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockListConversationsExpectation{
		mock:   mmListConversations.mock,
		params: &ArtifactPublicServiceClientMockListConversationsParams{ctx, in, opts},
	}
	mmListConversations.expectations = append(mmListConversations.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.ListConversations return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockListConversationsExpectation) Then(lp1 *mm_artifactv1alpha.ListConversationsResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockListConversationsResults{lp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.ListConversations should be invoked
func (mmListConversations *mArtifactPublicServiceClientMockListConversations) Times(n uint64) *mArtifactPublicServiceClientMockListConversations {
	if n == 0 {
		mmListConversations.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.ListConversations mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListConversations.expectedInvocations, n)
	return mmListConversations
}

func (mmListConversations *mArtifactPublicServiceClientMockListConversations) invocationsDone() bool {
	if len(mmListConversations.expectations) == 0 && mmListConversations.defaultExpectation == nil && mmListConversations.mock.funcListConversations == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListConversations.mock.afterListConversationsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListConversations.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListConversations implements artifactv1alpha.ArtifactPublicServiceClient
func (mmListConversations *ArtifactPublicServiceClientMock) ListConversations(ctx context.Context, in *mm_artifactv1alpha.ListConversationsRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.ListConversationsResponse, err error) {
	mm_atomic.AddUint64(&mmListConversations.beforeListConversationsCounter, 1)
	defer mm_atomic.AddUint64(&mmListConversations.afterListConversationsCounter, 1)

	if mmListConversations.inspectFuncListConversations != nil {
		mmListConversations.inspectFuncListConversations(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockListConversationsParams{ctx, in, opts}

	// Record call args
	mmListConversations.ListConversationsMock.mutex.Lock()
	mmListConversations.ListConversationsMock.callArgs = append(mmListConversations.ListConversationsMock.callArgs, &mm_params)
	mmListConversations.ListConversationsMock.mutex.Unlock()

	for _, e := range mmListConversations.ListConversationsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp1, e.results.err
		}
	}

	if mmListConversations.ListConversationsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListConversations.ListConversationsMock.defaultExpectation.Counter, 1)
		mm_want := mmListConversations.ListConversationsMock.defaultExpectation.params
		mm_want_ptrs := mmListConversations.ListConversationsMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockListConversationsParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListConversations.t.Errorf("ArtifactPublicServiceClientMock.ListConversations got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmListConversations.t.Errorf("ArtifactPublicServiceClientMock.ListConversations got unexpected parameter in, want: %#v, got: %#v%s\n", *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmListConversations.t.Errorf("ArtifactPublicServiceClientMock.ListConversations got unexpected parameter opts, want: %#v, got: %#v%s\n", *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListConversations.t.Errorf("ArtifactPublicServiceClientMock.ListConversations got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListConversations.ListConversationsMock.defaultExpectation.results
		if mm_results == nil {
			mmListConversations.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.ListConversations")
		}
		return (*mm_results).lp1, (*mm_results).err
	}
	if mmListConversations.funcListConversations != nil {
		return mmListConversations.funcListConversations(ctx, in, opts...)
	}
	mmListConversations.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.ListConversations. %v %v %v", ctx, in, opts)
	return
}

// ListConversationsAfterCounter returns a count of finished ArtifactPublicServiceClientMock.ListConversations invocations
func (mmListConversations *ArtifactPublicServiceClientMock) ListConversationsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListConversations.afterListConversationsCounter)
}

// ListConversationsBeforeCounter returns a count of ArtifactPublicServiceClientMock.ListConversations invocations
func (mmListConversations *ArtifactPublicServiceClientMock) ListConversationsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListConversations.beforeListConversationsCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.ListConversations.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListConversations *mArtifactPublicServiceClientMockListConversations) Calls() []*ArtifactPublicServiceClientMockListConversationsParams {
	mmListConversations.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockListConversationsParams, len(mmListConversations.callArgs))
	copy(argCopy, mmListConversations.callArgs)

	mmListConversations.mutex.RUnlock()

	return argCopy
}

// MinimockListConversationsDone returns true if the count of the ListConversations invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockListConversationsDone() bool {
	if m.ListConversationsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListConversationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListConversationsMock.invocationsDone()
}

// MinimockListConversationsInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockListConversationsInspect() {
	for _, e := range m.ListConversationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListConversations with params: %#v", *e.params)
		}
	}

	afterListConversationsCounter := mm_atomic.LoadUint64(&m.afterListConversationsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListConversationsMock.defaultExpectation != nil && afterListConversationsCounter < 1 {
		if m.ListConversationsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ArtifactPublicServiceClientMock.ListConversations")
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListConversations with params: %#v", *m.ListConversationsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListConversations != nil && afterListConversationsCounter < 1 {
		m.t.Error("Expected call to ArtifactPublicServiceClientMock.ListConversations")
	}

	if !m.ListConversationsMock.invocationsDone() && afterListConversationsCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.ListConversations but found %d calls",
			mm_atomic.LoadUint64(&m.ListConversationsMock.expectedInvocations), afterListConversationsCounter)
	}
}

type mArtifactPublicServiceClientMockListMessages struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockListMessagesExpectation
	expectations       []*ArtifactPublicServiceClientMockListMessagesExpectation

	callArgs []*ArtifactPublicServiceClientMockListMessagesParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ArtifactPublicServiceClientMockListMessagesExpectation specifies expectation struct of the ArtifactPublicServiceClient.ListMessages
type ArtifactPublicServiceClientMockListMessagesExpectation struct {
	mock      *ArtifactPublicServiceClientMock
	params    *ArtifactPublicServiceClientMockListMessagesParams
	paramPtrs *ArtifactPublicServiceClientMockListMessagesParamPtrs
	results   *ArtifactPublicServiceClientMockListMessagesResults
	Counter   uint64
}

// ArtifactPublicServiceClientMockListMessagesParams contains parameters of the ArtifactPublicServiceClient.ListMessages
type ArtifactPublicServiceClientMockListMessagesParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.ListMessagesRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockListMessagesParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.ListMessages
type ArtifactPublicServiceClientMockListMessagesParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.ListMessagesRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockListMessagesResults contains results of the ArtifactPublicServiceClient.ListMessages
type ArtifactPublicServiceClientMockListMessagesResults struct {
	lp1 *mm_artifactv1alpha.ListMessagesResponse
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListMessages *mArtifactPublicServiceClientMockListMessages) Optional() *mArtifactPublicServiceClientMockListMessages {
	mmListMessages.optional = true
	return mmListMessages
}

// Expect sets up expected params for ArtifactPublicServiceClient.ListMessages
func (mmListMessages *mArtifactPublicServiceClientMockListMessages) Expect(ctx context.Context, in *mm_artifactv1alpha.ListMessagesRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockListMessages {
	if mmListMessages.mock.funcListMessages != nil {
		mmListMessages.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListMessages mock is already set by Set")
	}

	if mmListMessages.defaultExpectation == nil {
		mmListMessages.defaultExpectation = &ArtifactPublicServiceClientMockListMessagesExpectation{}
	}

	if mmListMessages.defaultExpectation.paramPtrs != nil {
		mmListMessages.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListMessages mock is already set by ExpectParams functions")
	}

	mmListMessages.defaultExpectation.params = &ArtifactPublicServiceClientMockListMessagesParams{ctx, in, opts}
	for _, e := range mmListMessages.expectations {
		if minimock.Equal(e.params, mmListMessages.defaultExpectation.params) {
			mmListMessages.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListMessages.defaultExpectation.params)
		}
	}

	return mmListMessages
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.ListMessages
func (mmListMessages *mArtifactPublicServiceClientMockListMessages) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockListMessages {
	if mmListMessages.mock.funcListMessages != nil {
		mmListMessages.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListMessages mock is already set by Set")
	}

	if mmListMessages.defaultExpectation == nil {
		mmListMessages.defaultExpectation = &ArtifactPublicServiceClientMockListMessagesExpectation{}
	}

	if mmListMessages.defaultExpectation.params != nil {
		mmListMessages.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListMessages mock is already set by Expect")
	}

	if mmListMessages.defaultExpectation.paramPtrs == nil {
		mmListMessages.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockListMessagesParamPtrs{}
	}
	mmListMessages.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListMessages
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.ListMessages
func (mmListMessages *mArtifactPublicServiceClientMockListMessages) ExpectInParam2(in *mm_artifactv1alpha.ListMessagesRequest) *mArtifactPublicServiceClientMockListMessages {
	if mmListMessages.mock.funcListMessages != nil {
		mmListMessages.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListMessages mock is already set by Set")
	}

	if mmListMessages.defaultExpectation == nil {
		mmListMessages.defaultExpectation = &ArtifactPublicServiceClientMockListMessagesExpectation{}
	}

	if mmListMessages.defaultExpectation.params != nil {
		mmListMessages.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListMessages mock is already set by Expect")
	}

	if mmListMessages.defaultExpectation.paramPtrs == nil {
		mmListMessages.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockListMessagesParamPtrs{}
	}
	mmListMessages.defaultExpectation.paramPtrs.in = &in

	return mmListMessages
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.ListMessages
func (mmListMessages *mArtifactPublicServiceClientMockListMessages) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockListMessages {
	if mmListMessages.mock.funcListMessages != nil {
		mmListMessages.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListMessages mock is already set by Set")
	}

	if mmListMessages.defaultExpectation == nil {
		mmListMessages.defaultExpectation = &ArtifactPublicServiceClientMockListMessagesExpectation{}
	}

	if mmListMessages.defaultExpectation.params != nil {
		mmListMessages.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListMessages mock is already set by Expect")
	}

	if mmListMessages.defaultExpectation.paramPtrs == nil {
		mmListMessages.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockListMessagesParamPtrs{}
	}
	mmListMessages.defaultExpectation.paramPtrs.opts = &opts

	return mmListMessages
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.ListMessages
func (mmListMessages *mArtifactPublicServiceClientMockListMessages) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.ListMessagesRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockListMessages {
	if mmListMessages.mock.inspectFuncListMessages != nil {
		mmListMessages.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.ListMessages")
	}

	mmListMessages.mock.inspectFuncListMessages = f

	return mmListMessages
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.ListMessages
func (mmListMessages *mArtifactPublicServiceClientMockListMessages) Return(lp1 *mm_artifactv1alpha.ListMessagesResponse, err error) *ArtifactPublicServiceClientMock {
	if mmListMessages.mock.funcListMessages != nil {
		mmListMessages.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListMessages mock is already set by Set")
	}

	if mmListMessages.defaultExpectation == nil {
		mmListMessages.defaultExpectation = &ArtifactPublicServiceClientMockListMessagesExpectation{mock: mmListMessages.mock}
	}
	mmListMessages.defaultExpectation.results = &ArtifactPublicServiceClientMockListMessagesResults{lp1, err}
	return mmListMessages.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.ListMessages method
func (mmListMessages *mArtifactPublicServiceClientMockListMessages) Set(f func(ctx context.Context, in *mm_artifactv1alpha.ListMessagesRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.ListMessagesResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmListMessages.defaultExpectation != nil {
		mmListMessages.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.ListMessages method")
	}

	if len(mmListMessages.expectations) > 0 {
		mmListMessages.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.ListMessages method")
	}

	mmListMessages.mock.funcListMessages = f
	return mmListMessages.mock
}

// When sets expectation for the ArtifactPublicServiceClient.ListMessages which will trigger the result defined by the following
// Then helper
func (mmListMessages *mArtifactPublicServiceClientMockListMessages) When(ctx context.Context, in *mm_artifactv1alpha.ListMessagesRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockListMessagesExpectation {
	if mmListMessages.mock.funcListMessages != nil {
		mmListMessages.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListMessages mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockListMessagesExpectation{
		mock:   mmListMessages.mock,
		params: &ArtifactPublicServiceClientMockListMessagesParams{ctx, in, opts},
	}
	mmListMessages.expectations = append(mmListMessages.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.ListMessages return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockListMessagesExpectation) Then(lp1 *mm_artifactv1alpha.ListMessagesResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockListMessagesResults{lp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.ListMessages should be invoked
func (mmListMessages *mArtifactPublicServiceClientMockListMessages) Times(n uint64) *mArtifactPublicServiceClientMockListMessages {
	if n == 0 {
		mmListMessages.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.ListMessages mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListMessages.expectedInvocations, n)
	return mmListMessages
}

func (mmListMessages *mArtifactPublicServiceClientMockListMessages) invocationsDone() bool {
	if len(mmListMessages.expectations) == 0 && mmListMessages.defaultExpectation == nil && mmListMessages.mock.funcListMessages == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListMessages.mock.afterListMessagesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListMessages.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListMessages implements artifactv1alpha.ArtifactPublicServiceClient
func (mmListMessages *ArtifactPublicServiceClientMock) ListMessages(ctx context.Context, in *mm_artifactv1alpha.ListMessagesRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.ListMessagesResponse, err error) {
	mm_atomic.AddUint64(&mmListMessages.beforeListMessagesCounter, 1)
	defer mm_atomic.AddUint64(&mmListMessages.afterListMessagesCounter, 1)

	if mmListMessages.inspectFuncListMessages != nil {
		mmListMessages.inspectFuncListMessages(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockListMessagesParams{ctx, in, opts}

	// Record call args
	mmListMessages.ListMessagesMock.mutex.Lock()
	mmListMessages.ListMessagesMock.callArgs = append(mmListMessages.ListMessagesMock.callArgs, &mm_params)
	mmListMessages.ListMessagesMock.mutex.Unlock()

	for _, e := range mmListMessages.ListMessagesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp1, e.results.err
		}
	}

	if mmListMessages.ListMessagesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListMessages.ListMessagesMock.defaultExpectation.Counter, 1)
		mm_want := mmListMessages.ListMessagesMock.defaultExpectation.params
		mm_want_ptrs := mmListMessages.ListMessagesMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockListMessagesParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListMessages.t.Errorf("ArtifactPublicServiceClientMock.ListMessages got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmListMessages.t.Errorf("ArtifactPublicServiceClientMock.ListMessages got unexpected parameter in, want: %#v, got: %#v%s\n", *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmListMessages.t.Errorf("ArtifactPublicServiceClientMock.ListMessages got unexpected parameter opts, want: %#v, got: %#v%s\n", *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListMessages.t.Errorf("ArtifactPublicServiceClientMock.ListMessages got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListMessages.ListMessagesMock.defaultExpectation.results
		if mm_results == nil {
			mmListMessages.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.ListMessages")
		}
		return (*mm_results).lp1, (*mm_results).err
	}
	if mmListMessages.funcListMessages != nil {
		return mmListMessages.funcListMessages(ctx, in, opts...)
	}
	mmListMessages.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.ListMessages. %v %v %v", ctx, in, opts)
	return
}

// ListMessagesAfterCounter returns a count of finished ArtifactPublicServiceClientMock.ListMessages invocations
func (mmListMessages *ArtifactPublicServiceClientMock) ListMessagesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListMessages.afterListMessagesCounter)
}

// ListMessagesBeforeCounter returns a count of ArtifactPublicServiceClientMock.ListMessages invocations
func (mmListMessages *ArtifactPublicServiceClientMock) ListMessagesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListMessages.beforeListMessagesCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.ListMessages.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListMessages *mArtifactPublicServiceClientMockListMessages) Calls() []*ArtifactPublicServiceClientMockListMessagesParams {
	mmListMessages.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockListMessagesParams, len(mmListMessages.callArgs))
	copy(argCopy, mmListMessages.callArgs)

	mmListMessages.mutex.RUnlock()

	return argCopy
}

// MinimockListMessagesDone returns true if the count of the ListMessages invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockListMessagesDone() bool {
	if m.ListMessagesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListMessagesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListMessagesMock.invocationsDone()
}

// MinimockListMessagesInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockListMessagesInspect() {
	for _, e := range m.ListMessagesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListMessages with params: %#v", *e.params)
		}
	}

	afterListMessagesCounter := mm_atomic.LoadUint64(&m.afterListMessagesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListMessagesMock.defaultExpectation != nil && afterListMessagesCounter < 1 {
		if m.ListMessagesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ArtifactPublicServiceClientMock.ListMessages")
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListMessages with params: %#v", *m.ListMessagesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListMessages != nil && afterListMessagesCounter < 1 {
		m.t.Error("Expected call to ArtifactPublicServiceClientMock.ListMessages")
	}

	if !m.ListMessagesMock.invocationsDone() && afterListMessagesCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.ListMessages but found %d calls",
			mm_atomic.LoadUint64(&m.ListMessagesMock.expectedInvocations), afterListMessagesCounter)
	}
}

type mArtifactPublicServiceClientMockLiveness struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockLivenessExpectation
	expectations       []*ArtifactPublicServiceClientMockLivenessExpectation

	callArgs []*ArtifactPublicServiceClientMockLivenessParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ArtifactPublicServiceClientMockLivenessExpectation specifies expectation struct of the ArtifactPublicServiceClient.Liveness
type ArtifactPublicServiceClientMockLivenessExpectation struct {
	mock      *ArtifactPublicServiceClientMock
	params    *ArtifactPublicServiceClientMockLivenessParams
	paramPtrs *ArtifactPublicServiceClientMockLivenessParamPtrs
	results   *ArtifactPublicServiceClientMockLivenessResults
	Counter   uint64
}

// ArtifactPublicServiceClientMockLivenessParams contains parameters of the ArtifactPublicServiceClient.Liveness
type ArtifactPublicServiceClientMockLivenessParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.LivenessRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockLivenessParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.Liveness
type ArtifactPublicServiceClientMockLivenessParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.LivenessRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockLivenessResults contains results of the ArtifactPublicServiceClient.Liveness
type ArtifactPublicServiceClientMockLivenessResults struct {
	lp1 *mm_artifactv1alpha.LivenessResponse
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLiveness *mArtifactPublicServiceClientMockLiveness) Optional() *mArtifactPublicServiceClientMockLiveness {
	mmLiveness.optional = true
	return mmLiveness
}

// Expect sets up expected params for ArtifactPublicServiceClient.Liveness
func (mmLiveness *mArtifactPublicServiceClientMockLiveness) Expect(ctx context.Context, in *mm_artifactv1alpha.LivenessRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockLiveness {
	if mmLiveness.mock.funcLiveness != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Liveness mock is already set by Set")
	}

	if mmLiveness.defaultExpectation == nil {
		mmLiveness.defaultExpectation = &ArtifactPublicServiceClientMockLivenessExpectation{}
	}

	if mmLiveness.defaultExpectation.paramPtrs != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Liveness mock is already set by ExpectParams functions")
	}

	mmLiveness.defaultExpectation.params = &ArtifactPublicServiceClientMockLivenessParams{ctx, in, opts}
	for _, e := range mmLiveness.expectations {
		if minimock.Equal(e.params, mmLiveness.defaultExpectation.params) {
			mmLiveness.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLiveness.defaultExpectation.params)
		}
	}

	return mmLiveness
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.Liveness
func (mmLiveness *mArtifactPublicServiceClientMockLiveness) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockLiveness {
	if mmLiveness.mock.funcLiveness != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Liveness mock is already set by Set")
	}

	if mmLiveness.defaultExpectation == nil {
		mmLiveness.defaultExpectation = &ArtifactPublicServiceClientMockLivenessExpectation{}
	}

	if mmLiveness.defaultExpectation.params != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Liveness mock is already set by Expect")
	}

	if mmLiveness.defaultExpectation.paramPtrs == nil {
		mmLiveness.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockLivenessParamPtrs{}
	}
	mmLiveness.defaultExpectation.paramPtrs.ctx = &ctx

	return mmLiveness
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.Liveness
func (mmLiveness *mArtifactPublicServiceClientMockLiveness) ExpectInParam2(in *mm_artifactv1alpha.LivenessRequest) *mArtifactPublicServiceClientMockLiveness {
	if mmLiveness.mock.funcLiveness != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Liveness mock is already set by Set")
	}

	if mmLiveness.defaultExpectation == nil {
		mmLiveness.defaultExpectation = &ArtifactPublicServiceClientMockLivenessExpectation{}
	}

	if mmLiveness.defaultExpectation.params != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Liveness mock is already set by Expect")
	}

	if mmLiveness.defaultExpectation.paramPtrs == nil {
		mmLiveness.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockLivenessParamPtrs{}
	}
	mmLiveness.defaultExpectation.paramPtrs.in = &in

	return mmLiveness
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.Liveness
func (mmLiveness *mArtifactPublicServiceClientMockLiveness) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockLiveness {
	if mmLiveness.mock.funcLiveness != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Liveness mock is already set by Set")
	}

	if mmLiveness.defaultExpectation == nil {
		mmLiveness.defaultExpectation = &ArtifactPublicServiceClientMockLivenessExpectation{}
	}

	if mmLiveness.defaultExpectation.params != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Liveness mock is already set by Expect")
	}

	if mmLiveness.defaultExpectation.paramPtrs == nil {
		mmLiveness.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockLivenessParamPtrs{}
	}
	mmLiveness.defaultExpectation.paramPtrs.opts = &opts

	return mmLiveness
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.Liveness
func (mmLiveness *mArtifactPublicServiceClientMockLiveness) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.LivenessRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockLiveness {
	if mmLiveness.mock.inspectFuncLiveness != nil {
		mmLiveness.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.Liveness")
	}

	mmLiveness.mock.inspectFuncLiveness = f

	return mmLiveness
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.Liveness
func (mmLiveness *mArtifactPublicServiceClientMockLiveness) Return(lp1 *mm_artifactv1alpha.LivenessResponse, err error) *ArtifactPublicServiceClientMock {
	if mmLiveness.mock.funcLiveness != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Liveness mock is already set by Set")
	}

	if mmLiveness.defaultExpectation == nil {
		mmLiveness.defaultExpectation = &ArtifactPublicServiceClientMockLivenessExpectation{mock: mmLiveness.mock}
	}
	mmLiveness.defaultExpectation.results = &ArtifactPublicServiceClientMockLivenessResults{lp1, err}
	return mmLiveness.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.Liveness method
func (mmLiveness *mArtifactPublicServiceClientMockLiveness) Set(f func(ctx context.Context, in *mm_artifactv1alpha.LivenessRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.LivenessResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmLiveness.defaultExpectation != nil {
		mmLiveness.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.Liveness method")
	}

	if len(mmLiveness.expectations) > 0 {
		mmLiveness.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.Liveness method")
	}

	mmLiveness.mock.funcLiveness = f
	return mmLiveness.mock
}

// When sets expectation for the ArtifactPublicServiceClient.Liveness which will trigger the result defined by the following
// Then helper
func (mmLiveness *mArtifactPublicServiceClientMockLiveness) When(ctx context.Context, in *mm_artifactv1alpha.LivenessRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockLivenessExpectation {
	if mmLiveness.mock.funcLiveness != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Liveness mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockLivenessExpectation{
		mock:   mmLiveness.mock,
		params: &ArtifactPublicServiceClientMockLivenessParams{ctx, in, opts},
	}
	mmLiveness.expectations = append(mmLiveness.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.Liveness return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockLivenessExpectation) Then(lp1 *mm_artifactv1alpha.LivenessResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockLivenessResults{lp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.Liveness should be invoked
func (mmLiveness *mArtifactPublicServiceClientMockLiveness) Times(n uint64) *mArtifactPublicServiceClientMockLiveness {
	if n == 0 {
		mmLiveness.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.Liveness mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLiveness.expectedInvocations, n)
	return mmLiveness
}

func (mmLiveness *mArtifactPublicServiceClientMockLiveness) invocationsDone() bool {
	if len(mmLiveness.expectations) == 0 && mmLiveness.defaultExpectation == nil && mmLiveness.mock.funcLiveness == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLiveness.mock.afterLivenessCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLiveness.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Liveness implements artifactv1alpha.ArtifactPublicServiceClient
func (mmLiveness *ArtifactPublicServiceClientMock) Liveness(ctx context.Context, in *mm_artifactv1alpha.LivenessRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.LivenessResponse, err error) {
	mm_atomic.AddUint64(&mmLiveness.beforeLivenessCounter, 1)
	defer mm_atomic.AddUint64(&mmLiveness.afterLivenessCounter, 1)

	if mmLiveness.inspectFuncLiveness != nil {
		mmLiveness.inspectFuncLiveness(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockLivenessParams{ctx, in, opts}

	// Record call args
	mmLiveness.LivenessMock.mutex.Lock()
	mmLiveness.LivenessMock.callArgs = append(mmLiveness.LivenessMock.callArgs, &mm_params)
	mmLiveness.LivenessMock.mutex.Unlock()

	for _, e := range mmLiveness.LivenessMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp1, e.results.err
		}
	}

	if mmLiveness.LivenessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLiveness.LivenessMock.defaultExpectation.Counter, 1)
		mm_want := mmLiveness.LivenessMock.defaultExpectation.params
		mm_want_ptrs := mmLiveness.LivenessMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockLivenessParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLiveness.t.Errorf("ArtifactPublicServiceClientMock.Liveness got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmLiveness.t.Errorf("ArtifactPublicServiceClientMock.Liveness got unexpected parameter in, want: %#v, got: %#v%s\n", *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmLiveness.t.Errorf("ArtifactPublicServiceClientMock.Liveness got unexpected parameter opts, want: %#v, got: %#v%s\n", *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLiveness.t.Errorf("ArtifactPublicServiceClientMock.Liveness got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLiveness.LivenessMock.defaultExpectation.results
		if mm_results == nil {
			mmLiveness.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.Liveness")
		}
		return (*mm_results).lp1, (*mm_results).err
	}
	if mmLiveness.funcLiveness != nil {
		return mmLiveness.funcLiveness(ctx, in, opts...)
	}
	mmLiveness.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.Liveness. %v %v %v", ctx, in, opts)
	return
}

// LivenessAfterCounter returns a count of finished ArtifactPublicServiceClientMock.Liveness invocations
func (mmLiveness *ArtifactPublicServiceClientMock) LivenessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLiveness.afterLivenessCounter)
}

// LivenessBeforeCounter returns a count of ArtifactPublicServiceClientMock.Liveness invocations
func (mmLiveness *ArtifactPublicServiceClientMock) LivenessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLiveness.beforeLivenessCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.Liveness.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLiveness *mArtifactPublicServiceClientMockLiveness) Calls() []*ArtifactPublicServiceClientMockLivenessParams {
	mmLiveness.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockLivenessParams, len(mmLiveness.callArgs))
	copy(argCopy, mmLiveness.callArgs)

	mmLiveness.mutex.RUnlock()

	return argCopy
}

// MinimockLivenessDone returns true if the count of the Liveness invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockLivenessDone() bool {
	if m.LivenessMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LivenessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LivenessMock.invocationsDone()
}

// MinimockLivenessInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockLivenessInspect() {
	for _, e := range m.LivenessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.Liveness with params: %#v", *e.params)
		}
	}

	afterLivenessCounter := mm_atomic.LoadUint64(&m.afterLivenessCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LivenessMock.defaultExpectation != nil && afterLivenessCounter < 1 {
		if m.LivenessMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ArtifactPublicServiceClientMock.Liveness")
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.Liveness with params: %#v", *m.LivenessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLiveness != nil && afterLivenessCounter < 1 {
		m.t.Error("Expected call to ArtifactPublicServiceClientMock.Liveness")
	}

	if !m.LivenessMock.invocationsDone() && afterLivenessCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.Liveness but found %d calls",
			mm_atomic.LoadUint64(&m.LivenessMock.expectedInvocations), afterLivenessCounter)
	}
}

type mArtifactPublicServiceClientMockProcessCatalogFiles struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockProcessCatalogFilesExpectation
	expectations       []*ArtifactPublicServiceClientMockProcessCatalogFilesExpectation

	callArgs []*ArtifactPublicServiceClientMockProcessCatalogFilesParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ArtifactPublicServiceClientMockProcessCatalogFilesExpectation specifies expectation struct of the ArtifactPublicServiceClient.ProcessCatalogFiles
type ArtifactPublicServiceClientMockProcessCatalogFilesExpectation struct {
	mock      *ArtifactPublicServiceClientMock
	params    *ArtifactPublicServiceClientMockProcessCatalogFilesParams
	paramPtrs *ArtifactPublicServiceClientMockProcessCatalogFilesParamPtrs
	results   *ArtifactPublicServiceClientMockProcessCatalogFilesResults
	Counter   uint64
}

// ArtifactPublicServiceClientMockProcessCatalogFilesParams contains parameters of the ArtifactPublicServiceClient.ProcessCatalogFiles
type ArtifactPublicServiceClientMockProcessCatalogFilesParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.ProcessCatalogFilesRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockProcessCatalogFilesParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.ProcessCatalogFiles
type ArtifactPublicServiceClientMockProcessCatalogFilesParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.ProcessCatalogFilesRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockProcessCatalogFilesResults contains results of the ArtifactPublicServiceClient.ProcessCatalogFiles
type ArtifactPublicServiceClientMockProcessCatalogFilesResults struct {
	pp1 *mm_artifactv1alpha.ProcessCatalogFilesResponse
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmProcessCatalogFiles *mArtifactPublicServiceClientMockProcessCatalogFiles) Optional() *mArtifactPublicServiceClientMockProcessCatalogFiles {
	mmProcessCatalogFiles.optional = true
	return mmProcessCatalogFiles
}

// Expect sets up expected params for ArtifactPublicServiceClient.ProcessCatalogFiles
func (mmProcessCatalogFiles *mArtifactPublicServiceClientMockProcessCatalogFiles) Expect(ctx context.Context, in *mm_artifactv1alpha.ProcessCatalogFilesRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockProcessCatalogFiles {
	if mmProcessCatalogFiles.mock.funcProcessCatalogFiles != nil {
		mmProcessCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ProcessCatalogFiles mock is already set by Set")
	}

	if mmProcessCatalogFiles.defaultExpectation == nil {
		mmProcessCatalogFiles.defaultExpectation = &ArtifactPublicServiceClientMockProcessCatalogFilesExpectation{}
	}

	if mmProcessCatalogFiles.defaultExpectation.paramPtrs != nil {
		mmProcessCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ProcessCatalogFiles mock is already set by ExpectParams functions")
	}

	mmProcessCatalogFiles.defaultExpectation.params = &ArtifactPublicServiceClientMockProcessCatalogFilesParams{ctx, in, opts}
	for _, e := range mmProcessCatalogFiles.expectations {
		if minimock.Equal(e.params, mmProcessCatalogFiles.defaultExpectation.params) {
			mmProcessCatalogFiles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmProcessCatalogFiles.defaultExpectation.params)
		}
	}

	return mmProcessCatalogFiles
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.ProcessCatalogFiles
func (mmProcessCatalogFiles *mArtifactPublicServiceClientMockProcessCatalogFiles) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockProcessCatalogFiles {
	if mmProcessCatalogFiles.mock.funcProcessCatalogFiles != nil {
		mmProcessCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ProcessCatalogFiles mock is already set by Set")
	}

	if mmProcessCatalogFiles.defaultExpectation == nil {
		mmProcessCatalogFiles.defaultExpectation = &ArtifactPublicServiceClientMockProcessCatalogFilesExpectation{}
	}

	if mmProcessCatalogFiles.defaultExpectation.params != nil {
		mmProcessCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ProcessCatalogFiles mock is already set by Expect")
	}

	if mmProcessCatalogFiles.defaultExpectation.paramPtrs == nil {
		mmProcessCatalogFiles.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockProcessCatalogFilesParamPtrs{}
	}
	mmProcessCatalogFiles.defaultExpectation.paramPtrs.ctx = &ctx

	return mmProcessCatalogFiles
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.ProcessCatalogFiles
func (mmProcessCatalogFiles *mArtifactPublicServiceClientMockProcessCatalogFiles) ExpectInParam2(in *mm_artifactv1alpha.ProcessCatalogFilesRequest) *mArtifactPublicServiceClientMockProcessCatalogFiles {
	if mmProcessCatalogFiles.mock.funcProcessCatalogFiles != nil {
		mmProcessCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ProcessCatalogFiles mock is already set by Set")
	}

	if mmProcessCatalogFiles.defaultExpectation == nil {
		mmProcessCatalogFiles.defaultExpectation = &ArtifactPublicServiceClientMockProcessCatalogFilesExpectation{}
	}

	if mmProcessCatalogFiles.defaultExpectation.params != nil {
		mmProcessCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ProcessCatalogFiles mock is already set by Expect")
	}

	if mmProcessCatalogFiles.defaultExpectation.paramPtrs == nil {
		mmProcessCatalogFiles.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockProcessCatalogFilesParamPtrs{}
	}
	mmProcessCatalogFiles.defaultExpectation.paramPtrs.in = &in

	return mmProcessCatalogFiles
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.ProcessCatalogFiles
func (mmProcessCatalogFiles *mArtifactPublicServiceClientMockProcessCatalogFiles) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockProcessCatalogFiles {
	if mmProcessCatalogFiles.mock.funcProcessCatalogFiles != nil {
		mmProcessCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ProcessCatalogFiles mock is already set by Set")
	}

	if mmProcessCatalogFiles.defaultExpectation == nil {
		mmProcessCatalogFiles.defaultExpectation = &ArtifactPublicServiceClientMockProcessCatalogFilesExpectation{}
	}

	if mmProcessCatalogFiles.defaultExpectation.params != nil {
		mmProcessCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ProcessCatalogFiles mock is already set by Expect")
	}

	if mmProcessCatalogFiles.defaultExpectation.paramPtrs == nil {
		mmProcessCatalogFiles.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockProcessCatalogFilesParamPtrs{}
	}
	mmProcessCatalogFiles.defaultExpectation.paramPtrs.opts = &opts

	return mmProcessCatalogFiles
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.ProcessCatalogFiles
func (mmProcessCatalogFiles *mArtifactPublicServiceClientMockProcessCatalogFiles) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.ProcessCatalogFilesRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockProcessCatalogFiles {
	if mmProcessCatalogFiles.mock.inspectFuncProcessCatalogFiles != nil {
		mmProcessCatalogFiles.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.ProcessCatalogFiles")
	}

	mmProcessCatalogFiles.mock.inspectFuncProcessCatalogFiles = f

	return mmProcessCatalogFiles
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.ProcessCatalogFiles
func (mmProcessCatalogFiles *mArtifactPublicServiceClientMockProcessCatalogFiles) Return(pp1 *mm_artifactv1alpha.ProcessCatalogFilesResponse, err error) *ArtifactPublicServiceClientMock {
	if mmProcessCatalogFiles.mock.funcProcessCatalogFiles != nil {
		mmProcessCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ProcessCatalogFiles mock is already set by Set")
	}

	if mmProcessCatalogFiles.defaultExpectation == nil {
		mmProcessCatalogFiles.defaultExpectation = &ArtifactPublicServiceClientMockProcessCatalogFilesExpectation{mock: mmProcessCatalogFiles.mock}
	}
	mmProcessCatalogFiles.defaultExpectation.results = &ArtifactPublicServiceClientMockProcessCatalogFilesResults{pp1, err}
	return mmProcessCatalogFiles.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.ProcessCatalogFiles method
func (mmProcessCatalogFiles *mArtifactPublicServiceClientMockProcessCatalogFiles) Set(f func(ctx context.Context, in *mm_artifactv1alpha.ProcessCatalogFilesRequest, opts ...grpc.CallOption) (pp1 *mm_artifactv1alpha.ProcessCatalogFilesResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmProcessCatalogFiles.defaultExpectation != nil {
		mmProcessCatalogFiles.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.ProcessCatalogFiles method")
	}

	if len(mmProcessCatalogFiles.expectations) > 0 {
		mmProcessCatalogFiles.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.ProcessCatalogFiles method")
	}

	mmProcessCatalogFiles.mock.funcProcessCatalogFiles = f
	return mmProcessCatalogFiles.mock
}

// When sets expectation for the ArtifactPublicServiceClient.ProcessCatalogFiles which will trigger the result defined by the following
// Then helper
func (mmProcessCatalogFiles *mArtifactPublicServiceClientMockProcessCatalogFiles) When(ctx context.Context, in *mm_artifactv1alpha.ProcessCatalogFilesRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockProcessCatalogFilesExpectation {
	if mmProcessCatalogFiles.mock.funcProcessCatalogFiles != nil {
		mmProcessCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ProcessCatalogFiles mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockProcessCatalogFilesExpectation{
		mock:   mmProcessCatalogFiles.mock,
		params: &ArtifactPublicServiceClientMockProcessCatalogFilesParams{ctx, in, opts},
	}
	mmProcessCatalogFiles.expectations = append(mmProcessCatalogFiles.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.ProcessCatalogFiles return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockProcessCatalogFilesExpectation) Then(pp1 *mm_artifactv1alpha.ProcessCatalogFilesResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockProcessCatalogFilesResults{pp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.ProcessCatalogFiles should be invoked
func (mmProcessCatalogFiles *mArtifactPublicServiceClientMockProcessCatalogFiles) Times(n uint64) *mArtifactPublicServiceClientMockProcessCatalogFiles {
	if n == 0 {
		mmProcessCatalogFiles.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.ProcessCatalogFiles mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmProcessCatalogFiles.expectedInvocations, n)
	return mmProcessCatalogFiles
}

func (mmProcessCatalogFiles *mArtifactPublicServiceClientMockProcessCatalogFiles) invocationsDone() bool {
	if len(mmProcessCatalogFiles.expectations) == 0 && mmProcessCatalogFiles.defaultExpectation == nil && mmProcessCatalogFiles.mock.funcProcessCatalogFiles == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmProcessCatalogFiles.mock.afterProcessCatalogFilesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmProcessCatalogFiles.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ProcessCatalogFiles implements artifactv1alpha.ArtifactPublicServiceClient
func (mmProcessCatalogFiles *ArtifactPublicServiceClientMock) ProcessCatalogFiles(ctx context.Context, in *mm_artifactv1alpha.ProcessCatalogFilesRequest, opts ...grpc.CallOption) (pp1 *mm_artifactv1alpha.ProcessCatalogFilesResponse, err error) {
	mm_atomic.AddUint64(&mmProcessCatalogFiles.beforeProcessCatalogFilesCounter, 1)
	defer mm_atomic.AddUint64(&mmProcessCatalogFiles.afterProcessCatalogFilesCounter, 1)

	if mmProcessCatalogFiles.inspectFuncProcessCatalogFiles != nil {
		mmProcessCatalogFiles.inspectFuncProcessCatalogFiles(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockProcessCatalogFilesParams{ctx, in, opts}

	// Record call args
	mmProcessCatalogFiles.ProcessCatalogFilesMock.mutex.Lock()
	mmProcessCatalogFiles.ProcessCatalogFilesMock.callArgs = append(mmProcessCatalogFiles.ProcessCatalogFilesMock.callArgs, &mm_params)
	mmProcessCatalogFiles.ProcessCatalogFilesMock.mutex.Unlock()

	for _, e := range mmProcessCatalogFiles.ProcessCatalogFilesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmProcessCatalogFiles.ProcessCatalogFilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmProcessCatalogFiles.ProcessCatalogFilesMock.defaultExpectation.Counter, 1)
		mm_want := mmProcessCatalogFiles.ProcessCatalogFilesMock.defaultExpectation.params
		mm_want_ptrs := mmProcessCatalogFiles.ProcessCatalogFilesMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockProcessCatalogFilesParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmProcessCatalogFiles.t.Errorf("ArtifactPublicServiceClientMock.ProcessCatalogFiles got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmProcessCatalogFiles.t.Errorf("ArtifactPublicServiceClientMock.ProcessCatalogFiles got unexpected parameter in, want: %#v, got: %#v%s\n", *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmProcessCatalogFiles.t.Errorf("ArtifactPublicServiceClientMock.ProcessCatalogFiles got unexpected parameter opts, want: %#v, got: %#v%s\n", *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmProcessCatalogFiles.t.Errorf("ArtifactPublicServiceClientMock.ProcessCatalogFiles got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmProcessCatalogFiles.ProcessCatalogFilesMock.defaultExpectation.results
		if mm_results == nil {
			mmProcessCatalogFiles.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.ProcessCatalogFiles")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmProcessCatalogFiles.funcProcessCatalogFiles != nil {
		return mmProcessCatalogFiles.funcProcessCatalogFiles(ctx, in, opts...)
	}
	mmProcessCatalogFiles.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.ProcessCatalogFiles. %v %v %v", ctx, in, opts)
	return
}

// ProcessCatalogFilesAfterCounter returns a count of finished ArtifactPublicServiceClientMock.ProcessCatalogFiles invocations
func (mmProcessCatalogFiles *ArtifactPublicServiceClientMock) ProcessCatalogFilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcessCatalogFiles.afterProcessCatalogFilesCounter)
}

// ProcessCatalogFilesBeforeCounter returns a count of ArtifactPublicServiceClientMock.ProcessCatalogFiles invocations
func (mmProcessCatalogFiles *ArtifactPublicServiceClientMock) ProcessCatalogFilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcessCatalogFiles.beforeProcessCatalogFilesCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.ProcessCatalogFiles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmProcessCatalogFiles *mArtifactPublicServiceClientMockProcessCatalogFiles) Calls() []*ArtifactPublicServiceClientMockProcessCatalogFilesParams {
	mmProcessCatalogFiles.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockProcessCatalogFilesParams, len(mmProcessCatalogFiles.callArgs))
	copy(argCopy, mmProcessCatalogFiles.callArgs)

	mmProcessCatalogFiles.mutex.RUnlock()

	return argCopy
}

// MinimockProcessCatalogFilesDone returns true if the count of the ProcessCatalogFiles invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockProcessCatalogFilesDone() bool {
	if m.ProcessCatalogFilesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ProcessCatalogFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ProcessCatalogFilesMock.invocationsDone()
}

// MinimockProcessCatalogFilesInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockProcessCatalogFilesInspect() {
	for _, e := range m.ProcessCatalogFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ProcessCatalogFiles with params: %#v", *e.params)
		}
	}

	afterProcessCatalogFilesCounter := mm_atomic.LoadUint64(&m.afterProcessCatalogFilesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ProcessCatalogFilesMock.defaultExpectation != nil && afterProcessCatalogFilesCounter < 1 {
		if m.ProcessCatalogFilesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ArtifactPublicServiceClientMock.ProcessCatalogFiles")
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ProcessCatalogFiles with params: %#v", *m.ProcessCatalogFilesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProcessCatalogFiles != nil && afterProcessCatalogFilesCounter < 1 {
		m.t.Error("Expected call to ArtifactPublicServiceClientMock.ProcessCatalogFiles")
	}

	if !m.ProcessCatalogFilesMock.invocationsDone() && afterProcessCatalogFilesCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.ProcessCatalogFiles but found %d calls",
			mm_atomic.LoadUint64(&m.ProcessCatalogFilesMock.expectedInvocations), afterProcessCatalogFilesCounter)
	}
}

type mArtifactPublicServiceClientMockQuestionAnswering struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockQuestionAnsweringExpectation
	expectations       []*ArtifactPublicServiceClientMockQuestionAnsweringExpectation

	callArgs []*ArtifactPublicServiceClientMockQuestionAnsweringParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ArtifactPublicServiceClientMockQuestionAnsweringExpectation specifies expectation struct of the ArtifactPublicServiceClient.QuestionAnswering
type ArtifactPublicServiceClientMockQuestionAnsweringExpectation struct {
	mock      *ArtifactPublicServiceClientMock
	params    *ArtifactPublicServiceClientMockQuestionAnsweringParams
	paramPtrs *ArtifactPublicServiceClientMockQuestionAnsweringParamPtrs
	results   *ArtifactPublicServiceClientMockQuestionAnsweringResults
	Counter   uint64
}

// ArtifactPublicServiceClientMockQuestionAnsweringParams contains parameters of the ArtifactPublicServiceClient.QuestionAnswering
type ArtifactPublicServiceClientMockQuestionAnsweringParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.QuestionAnsweringRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockQuestionAnsweringParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.QuestionAnswering
type ArtifactPublicServiceClientMockQuestionAnsweringParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.QuestionAnsweringRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockQuestionAnsweringResults contains results of the ArtifactPublicServiceClient.QuestionAnswering
type ArtifactPublicServiceClientMockQuestionAnsweringResults struct {
	qp1 *mm_artifactv1alpha.QuestionAnsweringResponse
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmQuestionAnswering *mArtifactPublicServiceClientMockQuestionAnswering) Optional() *mArtifactPublicServiceClientMockQuestionAnswering {
	mmQuestionAnswering.optional = true
	return mmQuestionAnswering
}

// Expect sets up expected params for ArtifactPublicServiceClient.QuestionAnswering
func (mmQuestionAnswering *mArtifactPublicServiceClientMockQuestionAnswering) Expect(ctx context.Context, in *mm_artifactv1alpha.QuestionAnsweringRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockQuestionAnswering {
	if mmQuestionAnswering.mock.funcQuestionAnswering != nil {
		mmQuestionAnswering.mock.t.Fatalf("ArtifactPublicServiceClientMock.QuestionAnswering mock is already set by Set")
	}

	if mmQuestionAnswering.defaultExpectation == nil {
		mmQuestionAnswering.defaultExpectation = &ArtifactPublicServiceClientMockQuestionAnsweringExpectation{}
	}

	if mmQuestionAnswering.defaultExpectation.paramPtrs != nil {
		mmQuestionAnswering.mock.t.Fatalf("ArtifactPublicServiceClientMock.QuestionAnswering mock is already set by ExpectParams functions")
	}

	mmQuestionAnswering.defaultExpectation.params = &ArtifactPublicServiceClientMockQuestionAnsweringParams{ctx, in, opts}
	for _, e := range mmQuestionAnswering.expectations {
		if minimock.Equal(e.params, mmQuestionAnswering.defaultExpectation.params) {
			mmQuestionAnswering.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQuestionAnswering.defaultExpectation.params)
		}
	}

	return mmQuestionAnswering
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.QuestionAnswering
func (mmQuestionAnswering *mArtifactPublicServiceClientMockQuestionAnswering) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockQuestionAnswering {
	if mmQuestionAnswering.mock.funcQuestionAnswering != nil {
		mmQuestionAnswering.mock.t.Fatalf("ArtifactPublicServiceClientMock.QuestionAnswering mock is already set by Set")
	}

	if mmQuestionAnswering.defaultExpectation == nil {
		mmQuestionAnswering.defaultExpectation = &ArtifactPublicServiceClientMockQuestionAnsweringExpectation{}
	}

	if mmQuestionAnswering.defaultExpectation.params != nil {
		mmQuestionAnswering.mock.t.Fatalf("ArtifactPublicServiceClientMock.QuestionAnswering mock is already set by Expect")
	}

	if mmQuestionAnswering.defaultExpectation.paramPtrs == nil {
		mmQuestionAnswering.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockQuestionAnsweringParamPtrs{}
	}
	mmQuestionAnswering.defaultExpectation.paramPtrs.ctx = &ctx

	return mmQuestionAnswering
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.QuestionAnswering
func (mmQuestionAnswering *mArtifactPublicServiceClientMockQuestionAnswering) ExpectInParam2(in *mm_artifactv1alpha.QuestionAnsweringRequest) *mArtifactPublicServiceClientMockQuestionAnswering {
	if mmQuestionAnswering.mock.funcQuestionAnswering != nil {
		mmQuestionAnswering.mock.t.Fatalf("ArtifactPublicServiceClientMock.QuestionAnswering mock is already set by Set")
	}

	if mmQuestionAnswering.defaultExpectation == nil {
		mmQuestionAnswering.defaultExpectation = &ArtifactPublicServiceClientMockQuestionAnsweringExpectation{}
	}

	if mmQuestionAnswering.defaultExpectation.params != nil {
		mmQuestionAnswering.mock.t.Fatalf("ArtifactPublicServiceClientMock.QuestionAnswering mock is already set by Expect")
	}

	if mmQuestionAnswering.defaultExpectation.paramPtrs == nil {
		mmQuestionAnswering.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockQuestionAnsweringParamPtrs{}
	}
	mmQuestionAnswering.defaultExpectation.paramPtrs.in = &in

	return mmQuestionAnswering
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.QuestionAnswering
func (mmQuestionAnswering *mArtifactPublicServiceClientMockQuestionAnswering) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockQuestionAnswering {
	if mmQuestionAnswering.mock.funcQuestionAnswering != nil {
		mmQuestionAnswering.mock.t.Fatalf("ArtifactPublicServiceClientMock.QuestionAnswering mock is already set by Set")
	}

	if mmQuestionAnswering.defaultExpectation == nil {
		mmQuestionAnswering.defaultExpectation = &ArtifactPublicServiceClientMockQuestionAnsweringExpectation{}
	}

	if mmQuestionAnswering.defaultExpectation.params != nil {
		mmQuestionAnswering.mock.t.Fatalf("ArtifactPublicServiceClientMock.QuestionAnswering mock is already set by Expect")
	}

	if mmQuestionAnswering.defaultExpectation.paramPtrs == nil {
		mmQuestionAnswering.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockQuestionAnsweringParamPtrs{}
	}
	mmQuestionAnswering.defaultExpectation.paramPtrs.opts = &opts

	return mmQuestionAnswering
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.QuestionAnswering
func (mmQuestionAnswering *mArtifactPublicServiceClientMockQuestionAnswering) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.QuestionAnsweringRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockQuestionAnswering {
	if mmQuestionAnswering.mock.inspectFuncQuestionAnswering != nil {
		mmQuestionAnswering.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.QuestionAnswering")
	}

	mmQuestionAnswering.mock.inspectFuncQuestionAnswering = f

	return mmQuestionAnswering
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.QuestionAnswering
func (mmQuestionAnswering *mArtifactPublicServiceClientMockQuestionAnswering) Return(qp1 *mm_artifactv1alpha.QuestionAnsweringResponse, err error) *ArtifactPublicServiceClientMock {
	if mmQuestionAnswering.mock.funcQuestionAnswering != nil {
		mmQuestionAnswering.mock.t.Fatalf("ArtifactPublicServiceClientMock.QuestionAnswering mock is already set by Set")
	}

	if mmQuestionAnswering.defaultExpectation == nil {
		mmQuestionAnswering.defaultExpectation = &ArtifactPublicServiceClientMockQuestionAnsweringExpectation{mock: mmQuestionAnswering.mock}
	}
	mmQuestionAnswering.defaultExpectation.results = &ArtifactPublicServiceClientMockQuestionAnsweringResults{qp1, err}
	return mmQuestionAnswering.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.QuestionAnswering method
func (mmQuestionAnswering *mArtifactPublicServiceClientMockQuestionAnswering) Set(f func(ctx context.Context, in *mm_artifactv1alpha.QuestionAnsweringRequest, opts ...grpc.CallOption) (qp1 *mm_artifactv1alpha.QuestionAnsweringResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmQuestionAnswering.defaultExpectation != nil {
		mmQuestionAnswering.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.QuestionAnswering method")
	}

	if len(mmQuestionAnswering.expectations) > 0 {
		mmQuestionAnswering.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.QuestionAnswering method")
	}

	mmQuestionAnswering.mock.funcQuestionAnswering = f
	return mmQuestionAnswering.mock
}

// When sets expectation for the ArtifactPublicServiceClient.QuestionAnswering which will trigger the result defined by the following
// Then helper
func (mmQuestionAnswering *mArtifactPublicServiceClientMockQuestionAnswering) When(ctx context.Context, in *mm_artifactv1alpha.QuestionAnsweringRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockQuestionAnsweringExpectation {
	if mmQuestionAnswering.mock.funcQuestionAnswering != nil {
		mmQuestionAnswering.mock.t.Fatalf("ArtifactPublicServiceClientMock.QuestionAnswering mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockQuestionAnsweringExpectation{
		mock:   mmQuestionAnswering.mock,
		params: &ArtifactPublicServiceClientMockQuestionAnsweringParams{ctx, in, opts},
	}
	mmQuestionAnswering.expectations = append(mmQuestionAnswering.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.QuestionAnswering return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockQuestionAnsweringExpectation) Then(qp1 *mm_artifactv1alpha.QuestionAnsweringResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockQuestionAnsweringResults{qp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.QuestionAnswering should be invoked
func (mmQuestionAnswering *mArtifactPublicServiceClientMockQuestionAnswering) Times(n uint64) *mArtifactPublicServiceClientMockQuestionAnswering {
	if n == 0 {
		mmQuestionAnswering.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.QuestionAnswering mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmQuestionAnswering.expectedInvocations, n)
	return mmQuestionAnswering
}

func (mmQuestionAnswering *mArtifactPublicServiceClientMockQuestionAnswering) invocationsDone() bool {
	if len(mmQuestionAnswering.expectations) == 0 && mmQuestionAnswering.defaultExpectation == nil && mmQuestionAnswering.mock.funcQuestionAnswering == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmQuestionAnswering.mock.afterQuestionAnsweringCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmQuestionAnswering.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// QuestionAnswering implements artifactv1alpha.ArtifactPublicServiceClient
func (mmQuestionAnswering *ArtifactPublicServiceClientMock) QuestionAnswering(ctx context.Context, in *mm_artifactv1alpha.QuestionAnsweringRequest, opts ...grpc.CallOption) (qp1 *mm_artifactv1alpha.QuestionAnsweringResponse, err error) {
	mm_atomic.AddUint64(&mmQuestionAnswering.beforeQuestionAnsweringCounter, 1)
	defer mm_atomic.AddUint64(&mmQuestionAnswering.afterQuestionAnsweringCounter, 1)

	if mmQuestionAnswering.inspectFuncQuestionAnswering != nil {
		mmQuestionAnswering.inspectFuncQuestionAnswering(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockQuestionAnsweringParams{ctx, in, opts}

	// Record call args
	mmQuestionAnswering.QuestionAnsweringMock.mutex.Lock()
	mmQuestionAnswering.QuestionAnsweringMock.callArgs = append(mmQuestionAnswering.QuestionAnsweringMock.callArgs, &mm_params)
	mmQuestionAnswering.QuestionAnsweringMock.mutex.Unlock()

	for _, e := range mmQuestionAnswering.QuestionAnsweringMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.qp1, e.results.err
		}
	}

	if mmQuestionAnswering.QuestionAnsweringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQuestionAnswering.QuestionAnsweringMock.defaultExpectation.Counter, 1)
		mm_want := mmQuestionAnswering.QuestionAnsweringMock.defaultExpectation.params
		mm_want_ptrs := mmQuestionAnswering.QuestionAnsweringMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockQuestionAnsweringParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmQuestionAnswering.t.Errorf("ArtifactPublicServiceClientMock.QuestionAnswering got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmQuestionAnswering.t.Errorf("ArtifactPublicServiceClientMock.QuestionAnswering got unexpected parameter in, want: %#v, got: %#v%s\n", *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmQuestionAnswering.t.Errorf("ArtifactPublicServiceClientMock.QuestionAnswering got unexpected parameter opts, want: %#v, got: %#v%s\n", *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQuestionAnswering.t.Errorf("ArtifactPublicServiceClientMock.QuestionAnswering got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQuestionAnswering.QuestionAnsweringMock.defaultExpectation.results
		if mm_results == nil {
			mmQuestionAnswering.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.QuestionAnswering")
		}
		return (*mm_results).qp1, (*mm_results).err
	}
	if mmQuestionAnswering.funcQuestionAnswering != nil {
		return mmQuestionAnswering.funcQuestionAnswering(ctx, in, opts...)
	}
	mmQuestionAnswering.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.QuestionAnswering. %v %v %v", ctx, in, opts)
	return
}

// QuestionAnsweringAfterCounter returns a count of finished ArtifactPublicServiceClientMock.QuestionAnswering invocations
func (mmQuestionAnswering *ArtifactPublicServiceClientMock) QuestionAnsweringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQuestionAnswering.afterQuestionAnsweringCounter)
}

// QuestionAnsweringBeforeCounter returns a count of ArtifactPublicServiceClientMock.QuestionAnswering invocations
func (mmQuestionAnswering *ArtifactPublicServiceClientMock) QuestionAnsweringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQuestionAnswering.beforeQuestionAnsweringCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.QuestionAnswering.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQuestionAnswering *mArtifactPublicServiceClientMockQuestionAnswering) Calls() []*ArtifactPublicServiceClientMockQuestionAnsweringParams {
	mmQuestionAnswering.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockQuestionAnsweringParams, len(mmQuestionAnswering.callArgs))
	copy(argCopy, mmQuestionAnswering.callArgs)

	mmQuestionAnswering.mutex.RUnlock()

	return argCopy
}

// MinimockQuestionAnsweringDone returns true if the count of the QuestionAnswering invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockQuestionAnsweringDone() bool {
	if m.QuestionAnsweringMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.QuestionAnsweringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.QuestionAnsweringMock.invocationsDone()
}

// MinimockQuestionAnsweringInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockQuestionAnsweringInspect() {
	for _, e := range m.QuestionAnsweringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.QuestionAnswering with params: %#v", *e.params)
		}
	}

	afterQuestionAnsweringCounter := mm_atomic.LoadUint64(&m.afterQuestionAnsweringCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.QuestionAnsweringMock.defaultExpectation != nil && afterQuestionAnsweringCounter < 1 {
		if m.QuestionAnsweringMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ArtifactPublicServiceClientMock.QuestionAnswering")
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.QuestionAnswering with params: %#v", *m.QuestionAnsweringMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQuestionAnswering != nil && afterQuestionAnsweringCounter < 1 {
		m.t.Error("Expected call to ArtifactPublicServiceClientMock.QuestionAnswering")
	}

	if !m.QuestionAnsweringMock.invocationsDone() && afterQuestionAnsweringCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.QuestionAnswering but found %d calls",
			mm_atomic.LoadUint64(&m.QuestionAnsweringMock.expectedInvocations), afterQuestionAnsweringCounter)
	}
}

type mArtifactPublicServiceClientMockReadiness struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockReadinessExpectation
	expectations       []*ArtifactPublicServiceClientMockReadinessExpectation

	callArgs []*ArtifactPublicServiceClientMockReadinessParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ArtifactPublicServiceClientMockReadinessExpectation specifies expectation struct of the ArtifactPublicServiceClient.Readiness
type ArtifactPublicServiceClientMockReadinessExpectation struct {
	mock      *ArtifactPublicServiceClientMock
	params    *ArtifactPublicServiceClientMockReadinessParams
	paramPtrs *ArtifactPublicServiceClientMockReadinessParamPtrs
	results   *ArtifactPublicServiceClientMockReadinessResults
	Counter   uint64
}

// ArtifactPublicServiceClientMockReadinessParams contains parameters of the ArtifactPublicServiceClient.Readiness
type ArtifactPublicServiceClientMockReadinessParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.ReadinessRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockReadinessParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.Readiness
type ArtifactPublicServiceClientMockReadinessParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.ReadinessRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockReadinessResults contains results of the ArtifactPublicServiceClient.Readiness
type ArtifactPublicServiceClientMockReadinessResults struct {
	rp1 *mm_artifactv1alpha.ReadinessResponse
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReadiness *mArtifactPublicServiceClientMockReadiness) Optional() *mArtifactPublicServiceClientMockReadiness {
	mmReadiness.optional = true
	return mmReadiness
}

// Expect sets up expected params for ArtifactPublicServiceClient.Readiness
func (mmReadiness *mArtifactPublicServiceClientMockReadiness) Expect(ctx context.Context, in *mm_artifactv1alpha.ReadinessRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockReadiness {
	if mmReadiness.mock.funcReadiness != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Readiness mock is already set by Set")
	}

	if mmReadiness.defaultExpectation == nil {
		mmReadiness.defaultExpectation = &ArtifactPublicServiceClientMockReadinessExpectation{}
	}

	if mmReadiness.defaultExpectation.paramPtrs != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Readiness mock is already set by ExpectParams functions")
	}

	mmReadiness.defaultExpectation.params = &ArtifactPublicServiceClientMockReadinessParams{ctx, in, opts}
	for _, e := range mmReadiness.expectations {
		if minimock.Equal(e.params, mmReadiness.defaultExpectation.params) {
			mmReadiness.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReadiness.defaultExpectation.params)
		}
	}

	return mmReadiness
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.Readiness
func (mmReadiness *mArtifactPublicServiceClientMockReadiness) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockReadiness {
	if mmReadiness.mock.funcReadiness != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Readiness mock is already set by Set")
	}

	if mmReadiness.defaultExpectation == nil {
		mmReadiness.defaultExpectation = &ArtifactPublicServiceClientMockReadinessExpectation{}
	}

	if mmReadiness.defaultExpectation.params != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Readiness mock is already set by Expect")
	}

	if mmReadiness.defaultExpectation.paramPtrs == nil {
		mmReadiness.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockReadinessParamPtrs{}
	}
	mmReadiness.defaultExpectation.paramPtrs.ctx = &ctx

	return mmReadiness
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.Readiness
func (mmReadiness *mArtifactPublicServiceClientMockReadiness) ExpectInParam2(in *mm_artifactv1alpha.ReadinessRequest) *mArtifactPublicServiceClientMockReadiness {
	if mmReadiness.mock.funcReadiness != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Readiness mock is already set by Set")
	}

	if mmReadiness.defaultExpectation == nil {
		mmReadiness.defaultExpectation = &ArtifactPublicServiceClientMockReadinessExpectation{}
	}

	if mmReadiness.defaultExpectation.params != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Readiness mock is already set by Expect")
	}

	if mmReadiness.defaultExpectation.paramPtrs == nil {
		mmReadiness.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockReadinessParamPtrs{}
	}
	mmReadiness.defaultExpectation.paramPtrs.in = &in

	return mmReadiness
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.Readiness
func (mmReadiness *mArtifactPublicServiceClientMockReadiness) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockReadiness {
	if mmReadiness.mock.funcReadiness != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Readiness mock is already set by Set")
	}

	if mmReadiness.defaultExpectation == nil {
		mmReadiness.defaultExpectation = &ArtifactPublicServiceClientMockReadinessExpectation{}
	}

	if mmReadiness.defaultExpectation.params != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Readiness mock is already set by Expect")
	}

	if mmReadiness.defaultExpectation.paramPtrs == nil {
		mmReadiness.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockReadinessParamPtrs{}
	}
	mmReadiness.defaultExpectation.paramPtrs.opts = &opts

	return mmReadiness
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.Readiness
func (mmReadiness *mArtifactPublicServiceClientMockReadiness) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.ReadinessRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockReadiness {
	if mmReadiness.mock.inspectFuncReadiness != nil {
		mmReadiness.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.Readiness")
	}

	mmReadiness.mock.inspectFuncReadiness = f

	return mmReadiness
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.Readiness
func (mmReadiness *mArtifactPublicServiceClientMockReadiness) Return(rp1 *mm_artifactv1alpha.ReadinessResponse, err error) *ArtifactPublicServiceClientMock {
	if mmReadiness.mock.funcReadiness != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Readiness mock is already set by Set")
	}

	if mmReadiness.defaultExpectation == nil {
		mmReadiness.defaultExpectation = &ArtifactPublicServiceClientMockReadinessExpectation{mock: mmReadiness.mock}
	}
	mmReadiness.defaultExpectation.results = &ArtifactPublicServiceClientMockReadinessResults{rp1, err}
	return mmReadiness.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.Readiness method
func (mmReadiness *mArtifactPublicServiceClientMockReadiness) Set(f func(ctx context.Context, in *mm_artifactv1alpha.ReadinessRequest, opts ...grpc.CallOption) (rp1 *mm_artifactv1alpha.ReadinessResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmReadiness.defaultExpectation != nil {
		mmReadiness.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.Readiness method")
	}

	if len(mmReadiness.expectations) > 0 {
		mmReadiness.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.Readiness method")
	}

	mmReadiness.mock.funcReadiness = f
	return mmReadiness.mock
}

// When sets expectation for the ArtifactPublicServiceClient.Readiness which will trigger the result defined by the following
// Then helper
func (mmReadiness *mArtifactPublicServiceClientMockReadiness) When(ctx context.Context, in *mm_artifactv1alpha.ReadinessRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockReadinessExpectation {
	if mmReadiness.mock.funcReadiness != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Readiness mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockReadinessExpectation{
		mock:   mmReadiness.mock,
		params: &ArtifactPublicServiceClientMockReadinessParams{ctx, in, opts},
	}
	mmReadiness.expectations = append(mmReadiness.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.Readiness return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockReadinessExpectation) Then(rp1 *mm_artifactv1alpha.ReadinessResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockReadinessResults{rp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.Readiness should be invoked
func (mmReadiness *mArtifactPublicServiceClientMockReadiness) Times(n uint64) *mArtifactPublicServiceClientMockReadiness {
	if n == 0 {
		mmReadiness.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.Readiness mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReadiness.expectedInvocations, n)
	return mmReadiness
}

func (mmReadiness *mArtifactPublicServiceClientMockReadiness) invocationsDone() bool {
	if len(mmReadiness.expectations) == 0 && mmReadiness.defaultExpectation == nil && mmReadiness.mock.funcReadiness == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReadiness.mock.afterReadinessCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReadiness.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Readiness implements artifactv1alpha.ArtifactPublicServiceClient
func (mmReadiness *ArtifactPublicServiceClientMock) Readiness(ctx context.Context, in *mm_artifactv1alpha.ReadinessRequest, opts ...grpc.CallOption) (rp1 *mm_artifactv1alpha.ReadinessResponse, err error) {
	mm_atomic.AddUint64(&mmReadiness.beforeReadinessCounter, 1)
	defer mm_atomic.AddUint64(&mmReadiness.afterReadinessCounter, 1)

	if mmReadiness.inspectFuncReadiness != nil {
		mmReadiness.inspectFuncReadiness(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockReadinessParams{ctx, in, opts}

	// Record call args
	mmReadiness.ReadinessMock.mutex.Lock()
	mmReadiness.ReadinessMock.callArgs = append(mmReadiness.ReadinessMock.callArgs, &mm_params)
	mmReadiness.ReadinessMock.mutex.Unlock()

	for _, e := range mmReadiness.ReadinessMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmReadiness.ReadinessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadiness.ReadinessMock.defaultExpectation.Counter, 1)
		mm_want := mmReadiness.ReadinessMock.defaultExpectation.params
		mm_want_ptrs := mmReadiness.ReadinessMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockReadinessParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReadiness.t.Errorf("ArtifactPublicServiceClientMock.Readiness got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmReadiness.t.Errorf("ArtifactPublicServiceClientMock.Readiness got unexpected parameter in, want: %#v, got: %#v%s\n", *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmReadiness.t.Errorf("ArtifactPublicServiceClientMock.Readiness got unexpected parameter opts, want: %#v, got: %#v%s\n", *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReadiness.t.Errorf("ArtifactPublicServiceClientMock.Readiness got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReadiness.ReadinessMock.defaultExpectation.results
		if mm_results == nil {
			mmReadiness.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.Readiness")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmReadiness.funcReadiness != nil {
		return mmReadiness.funcReadiness(ctx, in, opts...)
	}
	mmReadiness.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.Readiness. %v %v %v", ctx, in, opts)
	return
}

// ReadinessAfterCounter returns a count of finished ArtifactPublicServiceClientMock.Readiness invocations
func (mmReadiness *ArtifactPublicServiceClientMock) ReadinessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadiness.afterReadinessCounter)
}

// ReadinessBeforeCounter returns a count of ArtifactPublicServiceClientMock.Readiness invocations
func (mmReadiness *ArtifactPublicServiceClientMock) ReadinessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadiness.beforeReadinessCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.Readiness.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReadiness *mArtifactPublicServiceClientMockReadiness) Calls() []*ArtifactPublicServiceClientMockReadinessParams {
	mmReadiness.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockReadinessParams, len(mmReadiness.callArgs))
	copy(argCopy, mmReadiness.callArgs)

	mmReadiness.mutex.RUnlock()

	return argCopy
}

// MinimockReadinessDone returns true if the count of the Readiness invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockReadinessDone() bool {
	if m.ReadinessMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReadinessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReadinessMock.invocationsDone()
}

// MinimockReadinessInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockReadinessInspect() {
	for _, e := range m.ReadinessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.Readiness with params: %#v", *e.params)
		}
	}

	afterReadinessCounter := mm_atomic.LoadUint64(&m.afterReadinessCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReadinessMock.defaultExpectation != nil && afterReadinessCounter < 1 {
		if m.ReadinessMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ArtifactPublicServiceClientMock.Readiness")
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.Readiness with params: %#v", *m.ReadinessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadiness != nil && afterReadinessCounter < 1 {
		m.t.Error("Expected call to ArtifactPublicServiceClientMock.Readiness")
	}

	if !m.ReadinessMock.invocationsDone() && afterReadinessCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.Readiness but found %d calls",
			mm_atomic.LoadUint64(&m.ReadinessMock.expectedInvocations), afterReadinessCounter)
	}
}

type mArtifactPublicServiceClientMockSimilarityChunksSearch struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockSimilarityChunksSearchExpectation
	expectations       []*ArtifactPublicServiceClientMockSimilarityChunksSearchExpectation

	callArgs []*ArtifactPublicServiceClientMockSimilarityChunksSearchParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ArtifactPublicServiceClientMockSimilarityChunksSearchExpectation specifies expectation struct of the ArtifactPublicServiceClient.SimilarityChunksSearch
type ArtifactPublicServiceClientMockSimilarityChunksSearchExpectation struct {
	mock      *ArtifactPublicServiceClientMock
	params    *ArtifactPublicServiceClientMockSimilarityChunksSearchParams
	paramPtrs *ArtifactPublicServiceClientMockSimilarityChunksSearchParamPtrs
	results   *ArtifactPublicServiceClientMockSimilarityChunksSearchResults
	Counter   uint64
}

// ArtifactPublicServiceClientMockSimilarityChunksSearchParams contains parameters of the ArtifactPublicServiceClient.SimilarityChunksSearch
type ArtifactPublicServiceClientMockSimilarityChunksSearchParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.SimilarityChunksSearchRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockSimilarityChunksSearchParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.SimilarityChunksSearch
type ArtifactPublicServiceClientMockSimilarityChunksSearchParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.SimilarityChunksSearchRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockSimilarityChunksSearchResults contains results of the ArtifactPublicServiceClient.SimilarityChunksSearch
type ArtifactPublicServiceClientMockSimilarityChunksSearchResults struct {
	sp1 *mm_artifactv1alpha.SimilarityChunksSearchResponse
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSimilarityChunksSearch *mArtifactPublicServiceClientMockSimilarityChunksSearch) Optional() *mArtifactPublicServiceClientMockSimilarityChunksSearch {
	mmSimilarityChunksSearch.optional = true
	return mmSimilarityChunksSearch
}

// Expect sets up expected params for ArtifactPublicServiceClient.SimilarityChunksSearch
func (mmSimilarityChunksSearch *mArtifactPublicServiceClientMockSimilarityChunksSearch) Expect(ctx context.Context, in *mm_artifactv1alpha.SimilarityChunksSearchRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockSimilarityChunksSearch {
	if mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ArtifactPublicServiceClientMock.SimilarityChunksSearch mock is already set by Set")
	}

	if mmSimilarityChunksSearch.defaultExpectation == nil {
		mmSimilarityChunksSearch.defaultExpectation = &ArtifactPublicServiceClientMockSimilarityChunksSearchExpectation{}
	}

	if mmSimilarityChunksSearch.defaultExpectation.paramPtrs != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ArtifactPublicServiceClientMock.SimilarityChunksSearch mock is already set by ExpectParams functions")
	}

	mmSimilarityChunksSearch.defaultExpectation.params = &ArtifactPublicServiceClientMockSimilarityChunksSearchParams{ctx, in, opts}
	for _, e := range mmSimilarityChunksSearch.expectations {
		if minimock.Equal(e.params, mmSimilarityChunksSearch.defaultExpectation.params) {
			mmSimilarityChunksSearch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSimilarityChunksSearch.defaultExpectation.params)
		}
	}

	return mmSimilarityChunksSearch
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.SimilarityChunksSearch
func (mmSimilarityChunksSearch *mArtifactPublicServiceClientMockSimilarityChunksSearch) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockSimilarityChunksSearch {
	if mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ArtifactPublicServiceClientMock.SimilarityChunksSearch mock is already set by Set")
	}

	if mmSimilarityChunksSearch.defaultExpectation == nil {
		mmSimilarityChunksSearch.defaultExpectation = &ArtifactPublicServiceClientMockSimilarityChunksSearchExpectation{}
	}

	if mmSimilarityChunksSearch.defaultExpectation.params != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ArtifactPublicServiceClientMock.SimilarityChunksSearch mock is already set by Expect")
	}

	if mmSimilarityChunksSearch.defaultExpectation.paramPtrs == nil {
		mmSimilarityChunksSearch.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockSimilarityChunksSearchParamPtrs{}
	}
	mmSimilarityChunksSearch.defaultExpectation.paramPtrs.ctx = &ctx

	return mmSimilarityChunksSearch
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.SimilarityChunksSearch
func (mmSimilarityChunksSearch *mArtifactPublicServiceClientMockSimilarityChunksSearch) ExpectInParam2(in *mm_artifactv1alpha.SimilarityChunksSearchRequest) *mArtifactPublicServiceClientMockSimilarityChunksSearch {
	if mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ArtifactPublicServiceClientMock.SimilarityChunksSearch mock is already set by Set")
	}

	if mmSimilarityChunksSearch.defaultExpectation == nil {
		mmSimilarityChunksSearch.defaultExpectation = &ArtifactPublicServiceClientMockSimilarityChunksSearchExpectation{}
	}

	if mmSimilarityChunksSearch.defaultExpectation.params != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ArtifactPublicServiceClientMock.SimilarityChunksSearch mock is already set by Expect")
	}

	if mmSimilarityChunksSearch.defaultExpectation.paramPtrs == nil {
		mmSimilarityChunksSearch.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockSimilarityChunksSearchParamPtrs{}
	}
	mmSimilarityChunksSearch.defaultExpectation.paramPtrs.in = &in

	return mmSimilarityChunksSearch
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.SimilarityChunksSearch
func (mmSimilarityChunksSearch *mArtifactPublicServiceClientMockSimilarityChunksSearch) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockSimilarityChunksSearch {
	if mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ArtifactPublicServiceClientMock.SimilarityChunksSearch mock is already set by Set")
	}

	if mmSimilarityChunksSearch.defaultExpectation == nil {
		mmSimilarityChunksSearch.defaultExpectation = &ArtifactPublicServiceClientMockSimilarityChunksSearchExpectation{}
	}

	if mmSimilarityChunksSearch.defaultExpectation.params != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ArtifactPublicServiceClientMock.SimilarityChunksSearch mock is already set by Expect")
	}

	if mmSimilarityChunksSearch.defaultExpectation.paramPtrs == nil {
		mmSimilarityChunksSearch.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockSimilarityChunksSearchParamPtrs{}
	}
	mmSimilarityChunksSearch.defaultExpectation.paramPtrs.opts = &opts

	return mmSimilarityChunksSearch
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.SimilarityChunksSearch
func (mmSimilarityChunksSearch *mArtifactPublicServiceClientMockSimilarityChunksSearch) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.SimilarityChunksSearchRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockSimilarityChunksSearch {
	if mmSimilarityChunksSearch.mock.inspectFuncSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.SimilarityChunksSearch")
	}

	mmSimilarityChunksSearch.mock.inspectFuncSimilarityChunksSearch = f

	return mmSimilarityChunksSearch
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.SimilarityChunksSearch
func (mmSimilarityChunksSearch *mArtifactPublicServiceClientMockSimilarityChunksSearch) Return(sp1 *mm_artifactv1alpha.SimilarityChunksSearchResponse, err error) *ArtifactPublicServiceClientMock {
	if mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ArtifactPublicServiceClientMock.SimilarityChunksSearch mock is already set by Set")
	}

	if mmSimilarityChunksSearch.defaultExpectation == nil {
		mmSimilarityChunksSearch.defaultExpectation = &ArtifactPublicServiceClientMockSimilarityChunksSearchExpectation{mock: mmSimilarityChunksSearch.mock}
	}
	mmSimilarityChunksSearch.defaultExpectation.results = &ArtifactPublicServiceClientMockSimilarityChunksSearchResults{sp1, err}
	return mmSimilarityChunksSearch.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.SimilarityChunksSearch method
func (mmSimilarityChunksSearch *mArtifactPublicServiceClientMockSimilarityChunksSearch) Set(f func(ctx context.Context, in *mm_artifactv1alpha.SimilarityChunksSearchRequest, opts ...grpc.CallOption) (sp1 *mm_artifactv1alpha.SimilarityChunksSearchResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmSimilarityChunksSearch.defaultExpectation != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.SimilarityChunksSearch method")
	}

	if len(mmSimilarityChunksSearch.expectations) > 0 {
		mmSimilarityChunksSearch.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.SimilarityChunksSearch method")
	}

	mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch = f
	return mmSimilarityChunksSearch.mock
}

// When sets expectation for the ArtifactPublicServiceClient.SimilarityChunksSearch which will trigger the result defined by the following
// Then helper
func (mmSimilarityChunksSearch *mArtifactPublicServiceClientMockSimilarityChunksSearch) When(ctx context.Context, in *mm_artifactv1alpha.SimilarityChunksSearchRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockSimilarityChunksSearchExpectation {
	if mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ArtifactPublicServiceClientMock.SimilarityChunksSearch mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockSimilarityChunksSearchExpectation{
		mock:   mmSimilarityChunksSearch.mock,
		params: &ArtifactPublicServiceClientMockSimilarityChunksSearchParams{ctx, in, opts},
	}
	mmSimilarityChunksSearch.expectations = append(mmSimilarityChunksSearch.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.SimilarityChunksSearch return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockSimilarityChunksSearchExpectation) Then(sp1 *mm_artifactv1alpha.SimilarityChunksSearchResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockSimilarityChunksSearchResults{sp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.SimilarityChunksSearch should be invoked
func (mmSimilarityChunksSearch *mArtifactPublicServiceClientMockSimilarityChunksSearch) Times(n uint64) *mArtifactPublicServiceClientMockSimilarityChunksSearch {
	if n == 0 {
		mmSimilarityChunksSearch.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.SimilarityChunksSearch mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSimilarityChunksSearch.expectedInvocations, n)
	return mmSimilarityChunksSearch
}

func (mmSimilarityChunksSearch *mArtifactPublicServiceClientMockSimilarityChunksSearch) invocationsDone() bool {
	if len(mmSimilarityChunksSearch.expectations) == 0 && mmSimilarityChunksSearch.defaultExpectation == nil && mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSimilarityChunksSearch.mock.afterSimilarityChunksSearchCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSimilarityChunksSearch.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SimilarityChunksSearch implements artifactv1alpha.ArtifactPublicServiceClient
func (mmSimilarityChunksSearch *ArtifactPublicServiceClientMock) SimilarityChunksSearch(ctx context.Context, in *mm_artifactv1alpha.SimilarityChunksSearchRequest, opts ...grpc.CallOption) (sp1 *mm_artifactv1alpha.SimilarityChunksSearchResponse, err error) {
	mm_atomic.AddUint64(&mmSimilarityChunksSearch.beforeSimilarityChunksSearchCounter, 1)
	defer mm_atomic.AddUint64(&mmSimilarityChunksSearch.afterSimilarityChunksSearchCounter, 1)

	if mmSimilarityChunksSearch.inspectFuncSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.inspectFuncSimilarityChunksSearch(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockSimilarityChunksSearchParams{ctx, in, opts}

	// Record call args
	mmSimilarityChunksSearch.SimilarityChunksSearchMock.mutex.Lock()
	mmSimilarityChunksSearch.SimilarityChunksSearchMock.callArgs = append(mmSimilarityChunksSearch.SimilarityChunksSearchMock.callArgs, &mm_params)
	mmSimilarityChunksSearch.SimilarityChunksSearchMock.mutex.Unlock()

	for _, e := range mmSimilarityChunksSearch.SimilarityChunksSearchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.Counter, 1)
		mm_want := mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.params
		mm_want_ptrs := mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockSimilarityChunksSearchParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSimilarityChunksSearch.t.Errorf("ArtifactPublicServiceClientMock.SimilarityChunksSearch got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmSimilarityChunksSearch.t.Errorf("ArtifactPublicServiceClientMock.SimilarityChunksSearch got unexpected parameter in, want: %#v, got: %#v%s\n", *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmSimilarityChunksSearch.t.Errorf("ArtifactPublicServiceClientMock.SimilarityChunksSearch got unexpected parameter opts, want: %#v, got: %#v%s\n", *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSimilarityChunksSearch.t.Errorf("ArtifactPublicServiceClientMock.SimilarityChunksSearch got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.results
		if mm_results == nil {
			mmSimilarityChunksSearch.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.SimilarityChunksSearch")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmSimilarityChunksSearch.funcSimilarityChunksSearch != nil {
		return mmSimilarityChunksSearch.funcSimilarityChunksSearch(ctx, in, opts...)
	}
	mmSimilarityChunksSearch.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.SimilarityChunksSearch. %v %v %v", ctx, in, opts)
	return
}

// SimilarityChunksSearchAfterCounter returns a count of finished ArtifactPublicServiceClientMock.SimilarityChunksSearch invocations
func (mmSimilarityChunksSearch *ArtifactPublicServiceClientMock) SimilarityChunksSearchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSimilarityChunksSearch.afterSimilarityChunksSearchCounter)
}

// SimilarityChunksSearchBeforeCounter returns a count of ArtifactPublicServiceClientMock.SimilarityChunksSearch invocations
func (mmSimilarityChunksSearch *ArtifactPublicServiceClientMock) SimilarityChunksSearchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSimilarityChunksSearch.beforeSimilarityChunksSearchCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.SimilarityChunksSearch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSimilarityChunksSearch *mArtifactPublicServiceClientMockSimilarityChunksSearch) Calls() []*ArtifactPublicServiceClientMockSimilarityChunksSearchParams {
	mmSimilarityChunksSearch.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockSimilarityChunksSearchParams, len(mmSimilarityChunksSearch.callArgs))
	copy(argCopy, mmSimilarityChunksSearch.callArgs)

	mmSimilarityChunksSearch.mutex.RUnlock()

	return argCopy
}

// MinimockSimilarityChunksSearchDone returns true if the count of the SimilarityChunksSearch invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockSimilarityChunksSearchDone() bool {
	if m.SimilarityChunksSearchMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SimilarityChunksSearchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SimilarityChunksSearchMock.invocationsDone()
}

// MinimockSimilarityChunksSearchInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockSimilarityChunksSearchInspect() {
	for _, e := range m.SimilarityChunksSearchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.SimilarityChunksSearch with params: %#v", *e.params)
		}
	}

	afterSimilarityChunksSearchCounter := mm_atomic.LoadUint64(&m.afterSimilarityChunksSearchCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SimilarityChunksSearchMock.defaultExpectation != nil && afterSimilarityChunksSearchCounter < 1 {
		if m.SimilarityChunksSearchMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ArtifactPublicServiceClientMock.SimilarityChunksSearch")
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.SimilarityChunksSearch with params: %#v", *m.SimilarityChunksSearchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSimilarityChunksSearch != nil && afterSimilarityChunksSearchCounter < 1 {
		m.t.Error("Expected call to ArtifactPublicServiceClientMock.SimilarityChunksSearch")
	}

	if !m.SimilarityChunksSearchMock.invocationsDone() && afterSimilarityChunksSearchCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.SimilarityChunksSearch but found %d calls",
			mm_atomic.LoadUint64(&m.SimilarityChunksSearchMock.expectedInvocations), afterSimilarityChunksSearchCounter)
	}
}

type mArtifactPublicServiceClientMockUpdateCatalog struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockUpdateCatalogExpectation
	expectations       []*ArtifactPublicServiceClientMockUpdateCatalogExpectation

	callArgs []*ArtifactPublicServiceClientMockUpdateCatalogParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ArtifactPublicServiceClientMockUpdateCatalogExpectation specifies expectation struct of the ArtifactPublicServiceClient.UpdateCatalog
type ArtifactPublicServiceClientMockUpdateCatalogExpectation struct {
	mock      *ArtifactPublicServiceClientMock
	params    *ArtifactPublicServiceClientMockUpdateCatalogParams
	paramPtrs *ArtifactPublicServiceClientMockUpdateCatalogParamPtrs
	results   *ArtifactPublicServiceClientMockUpdateCatalogResults
	Counter   uint64
}

// ArtifactPublicServiceClientMockUpdateCatalogParams contains parameters of the ArtifactPublicServiceClient.UpdateCatalog
type ArtifactPublicServiceClientMockUpdateCatalogParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.UpdateCatalogRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockUpdateCatalogParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.UpdateCatalog
type ArtifactPublicServiceClientMockUpdateCatalogParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.UpdateCatalogRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockUpdateCatalogResults contains results of the ArtifactPublicServiceClient.UpdateCatalog
type ArtifactPublicServiceClientMockUpdateCatalogResults struct {
	up1 *mm_artifactv1alpha.UpdateCatalogResponse
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateCatalog *mArtifactPublicServiceClientMockUpdateCatalog) Optional() *mArtifactPublicServiceClientMockUpdateCatalog {
	mmUpdateCatalog.optional = true
	return mmUpdateCatalog
}

// Expect sets up expected params for ArtifactPublicServiceClient.UpdateCatalog
func (mmUpdateCatalog *mArtifactPublicServiceClientMockUpdateCatalog) Expect(ctx context.Context, in *mm_artifactv1alpha.UpdateCatalogRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockUpdateCatalog {
	if mmUpdateCatalog.mock.funcUpdateCatalog != nil {
		mmUpdateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateCatalog mock is already set by Set")
	}

	if mmUpdateCatalog.defaultExpectation == nil {
		mmUpdateCatalog.defaultExpectation = &ArtifactPublicServiceClientMockUpdateCatalogExpectation{}
	}

	if mmUpdateCatalog.defaultExpectation.paramPtrs != nil {
		mmUpdateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateCatalog mock is already set by ExpectParams functions")
	}

	mmUpdateCatalog.defaultExpectation.params = &ArtifactPublicServiceClientMockUpdateCatalogParams{ctx, in, opts}
	for _, e := range mmUpdateCatalog.expectations {
		if minimock.Equal(e.params, mmUpdateCatalog.defaultExpectation.params) {
			mmUpdateCatalog.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateCatalog.defaultExpectation.params)
		}
	}

	return mmUpdateCatalog
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.UpdateCatalog
func (mmUpdateCatalog *mArtifactPublicServiceClientMockUpdateCatalog) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockUpdateCatalog {
	if mmUpdateCatalog.mock.funcUpdateCatalog != nil {
		mmUpdateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateCatalog mock is already set by Set")
	}

	if mmUpdateCatalog.defaultExpectation == nil {
		mmUpdateCatalog.defaultExpectation = &ArtifactPublicServiceClientMockUpdateCatalogExpectation{}
	}

	if mmUpdateCatalog.defaultExpectation.params != nil {
		mmUpdateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateCatalog mock is already set by Expect")
	}

	if mmUpdateCatalog.defaultExpectation.paramPtrs == nil {
		mmUpdateCatalog.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockUpdateCatalogParamPtrs{}
	}
	mmUpdateCatalog.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateCatalog
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.UpdateCatalog
func (mmUpdateCatalog *mArtifactPublicServiceClientMockUpdateCatalog) ExpectInParam2(in *mm_artifactv1alpha.UpdateCatalogRequest) *mArtifactPublicServiceClientMockUpdateCatalog {
	if mmUpdateCatalog.mock.funcUpdateCatalog != nil {
		mmUpdateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateCatalog mock is already set by Set")
	}

	if mmUpdateCatalog.defaultExpectation == nil {
		mmUpdateCatalog.defaultExpectation = &ArtifactPublicServiceClientMockUpdateCatalogExpectation{}
	}

	if mmUpdateCatalog.defaultExpectation.params != nil {
		mmUpdateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateCatalog mock is already set by Expect")
	}

	if mmUpdateCatalog.defaultExpectation.paramPtrs == nil {
		mmUpdateCatalog.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockUpdateCatalogParamPtrs{}
	}
	mmUpdateCatalog.defaultExpectation.paramPtrs.in = &in

	return mmUpdateCatalog
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.UpdateCatalog
func (mmUpdateCatalog *mArtifactPublicServiceClientMockUpdateCatalog) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockUpdateCatalog {
	if mmUpdateCatalog.mock.funcUpdateCatalog != nil {
		mmUpdateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateCatalog mock is already set by Set")
	}

	if mmUpdateCatalog.defaultExpectation == nil {
		mmUpdateCatalog.defaultExpectation = &ArtifactPublicServiceClientMockUpdateCatalogExpectation{}
	}

	if mmUpdateCatalog.defaultExpectation.params != nil {
		mmUpdateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateCatalog mock is already set by Expect")
	}

	if mmUpdateCatalog.defaultExpectation.paramPtrs == nil {
		mmUpdateCatalog.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockUpdateCatalogParamPtrs{}
	}
	mmUpdateCatalog.defaultExpectation.paramPtrs.opts = &opts

	return mmUpdateCatalog
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.UpdateCatalog
func (mmUpdateCatalog *mArtifactPublicServiceClientMockUpdateCatalog) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.UpdateCatalogRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockUpdateCatalog {
	if mmUpdateCatalog.mock.inspectFuncUpdateCatalog != nil {
		mmUpdateCatalog.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.UpdateCatalog")
	}

	mmUpdateCatalog.mock.inspectFuncUpdateCatalog = f

	return mmUpdateCatalog
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.UpdateCatalog
func (mmUpdateCatalog *mArtifactPublicServiceClientMockUpdateCatalog) Return(up1 *mm_artifactv1alpha.UpdateCatalogResponse, err error) *ArtifactPublicServiceClientMock {
	if mmUpdateCatalog.mock.funcUpdateCatalog != nil {
		mmUpdateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateCatalog mock is already set by Set")
	}

	if mmUpdateCatalog.defaultExpectation == nil {
		mmUpdateCatalog.defaultExpectation = &ArtifactPublicServiceClientMockUpdateCatalogExpectation{mock: mmUpdateCatalog.mock}
	}
	mmUpdateCatalog.defaultExpectation.results = &ArtifactPublicServiceClientMockUpdateCatalogResults{up1, err}
	return mmUpdateCatalog.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.UpdateCatalog method
func (mmUpdateCatalog *mArtifactPublicServiceClientMockUpdateCatalog) Set(f func(ctx context.Context, in *mm_artifactv1alpha.UpdateCatalogRequest, opts ...grpc.CallOption) (up1 *mm_artifactv1alpha.UpdateCatalogResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmUpdateCatalog.defaultExpectation != nil {
		mmUpdateCatalog.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.UpdateCatalog method")
	}

	if len(mmUpdateCatalog.expectations) > 0 {
		mmUpdateCatalog.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.UpdateCatalog method")
	}

	mmUpdateCatalog.mock.funcUpdateCatalog = f
	return mmUpdateCatalog.mock
}

// When sets expectation for the ArtifactPublicServiceClient.UpdateCatalog which will trigger the result defined by the following
// Then helper
func (mmUpdateCatalog *mArtifactPublicServiceClientMockUpdateCatalog) When(ctx context.Context, in *mm_artifactv1alpha.UpdateCatalogRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockUpdateCatalogExpectation {
	if mmUpdateCatalog.mock.funcUpdateCatalog != nil {
		mmUpdateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateCatalog mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockUpdateCatalogExpectation{
		mock:   mmUpdateCatalog.mock,
		params: &ArtifactPublicServiceClientMockUpdateCatalogParams{ctx, in, opts},
	}
	mmUpdateCatalog.expectations = append(mmUpdateCatalog.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.UpdateCatalog return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockUpdateCatalogExpectation) Then(up1 *mm_artifactv1alpha.UpdateCatalogResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockUpdateCatalogResults{up1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.UpdateCatalog should be invoked
func (mmUpdateCatalog *mArtifactPublicServiceClientMockUpdateCatalog) Times(n uint64) *mArtifactPublicServiceClientMockUpdateCatalog {
	if n == 0 {
		mmUpdateCatalog.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.UpdateCatalog mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateCatalog.expectedInvocations, n)
	return mmUpdateCatalog
}

func (mmUpdateCatalog *mArtifactPublicServiceClientMockUpdateCatalog) invocationsDone() bool {
	if len(mmUpdateCatalog.expectations) == 0 && mmUpdateCatalog.defaultExpectation == nil && mmUpdateCatalog.mock.funcUpdateCatalog == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateCatalog.mock.afterUpdateCatalogCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateCatalog.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateCatalog implements artifactv1alpha.ArtifactPublicServiceClient
func (mmUpdateCatalog *ArtifactPublicServiceClientMock) UpdateCatalog(ctx context.Context, in *mm_artifactv1alpha.UpdateCatalogRequest, opts ...grpc.CallOption) (up1 *mm_artifactv1alpha.UpdateCatalogResponse, err error) {
	mm_atomic.AddUint64(&mmUpdateCatalog.beforeUpdateCatalogCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateCatalog.afterUpdateCatalogCounter, 1)

	if mmUpdateCatalog.inspectFuncUpdateCatalog != nil {
		mmUpdateCatalog.inspectFuncUpdateCatalog(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockUpdateCatalogParams{ctx, in, opts}

	// Record call args
	mmUpdateCatalog.UpdateCatalogMock.mutex.Lock()
	mmUpdateCatalog.UpdateCatalogMock.callArgs = append(mmUpdateCatalog.UpdateCatalogMock.callArgs, &mm_params)
	mmUpdateCatalog.UpdateCatalogMock.mutex.Unlock()

	for _, e := range mmUpdateCatalog.UpdateCatalogMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmUpdateCatalog.UpdateCatalogMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateCatalog.UpdateCatalogMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateCatalog.UpdateCatalogMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateCatalog.UpdateCatalogMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockUpdateCatalogParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateCatalog.t.Errorf("ArtifactPublicServiceClientMock.UpdateCatalog got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmUpdateCatalog.t.Errorf("ArtifactPublicServiceClientMock.UpdateCatalog got unexpected parameter in, want: %#v, got: %#v%s\n", *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmUpdateCatalog.t.Errorf("ArtifactPublicServiceClientMock.UpdateCatalog got unexpected parameter opts, want: %#v, got: %#v%s\n", *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateCatalog.t.Errorf("ArtifactPublicServiceClientMock.UpdateCatalog got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateCatalog.UpdateCatalogMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateCatalog.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.UpdateCatalog")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmUpdateCatalog.funcUpdateCatalog != nil {
		return mmUpdateCatalog.funcUpdateCatalog(ctx, in, opts...)
	}
	mmUpdateCatalog.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.UpdateCatalog. %v %v %v", ctx, in, opts)
	return
}

// UpdateCatalogAfterCounter returns a count of finished ArtifactPublicServiceClientMock.UpdateCatalog invocations
func (mmUpdateCatalog *ArtifactPublicServiceClientMock) UpdateCatalogAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCatalog.afterUpdateCatalogCounter)
}

// UpdateCatalogBeforeCounter returns a count of ArtifactPublicServiceClientMock.UpdateCatalog invocations
func (mmUpdateCatalog *ArtifactPublicServiceClientMock) UpdateCatalogBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCatalog.beforeUpdateCatalogCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.UpdateCatalog.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateCatalog *mArtifactPublicServiceClientMockUpdateCatalog) Calls() []*ArtifactPublicServiceClientMockUpdateCatalogParams {
	mmUpdateCatalog.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockUpdateCatalogParams, len(mmUpdateCatalog.callArgs))
	copy(argCopy, mmUpdateCatalog.callArgs)

	mmUpdateCatalog.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateCatalogDone returns true if the count of the UpdateCatalog invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockUpdateCatalogDone() bool {
	if m.UpdateCatalogMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateCatalogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateCatalogMock.invocationsDone()
}

// MinimockUpdateCatalogInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockUpdateCatalogInspect() {
	for _, e := range m.UpdateCatalogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.UpdateCatalog with params: %#v", *e.params)
		}
	}

	afterUpdateCatalogCounter := mm_atomic.LoadUint64(&m.afterUpdateCatalogCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateCatalogMock.defaultExpectation != nil && afterUpdateCatalogCounter < 1 {
		if m.UpdateCatalogMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ArtifactPublicServiceClientMock.UpdateCatalog")
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.UpdateCatalog with params: %#v", *m.UpdateCatalogMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateCatalog != nil && afterUpdateCatalogCounter < 1 {
		m.t.Error("Expected call to ArtifactPublicServiceClientMock.UpdateCatalog")
	}

	if !m.UpdateCatalogMock.invocationsDone() && afterUpdateCatalogCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.UpdateCatalog but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateCatalogMock.expectedInvocations), afterUpdateCatalogCounter)
	}
}

type mArtifactPublicServiceClientMockUpdateChunk struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockUpdateChunkExpectation
	expectations       []*ArtifactPublicServiceClientMockUpdateChunkExpectation

	callArgs []*ArtifactPublicServiceClientMockUpdateChunkParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ArtifactPublicServiceClientMockUpdateChunkExpectation specifies expectation struct of the ArtifactPublicServiceClient.UpdateChunk
type ArtifactPublicServiceClientMockUpdateChunkExpectation struct {
	mock      *ArtifactPublicServiceClientMock
	params    *ArtifactPublicServiceClientMockUpdateChunkParams
	paramPtrs *ArtifactPublicServiceClientMockUpdateChunkParamPtrs
	results   *ArtifactPublicServiceClientMockUpdateChunkResults
	Counter   uint64
}

// ArtifactPublicServiceClientMockUpdateChunkParams contains parameters of the ArtifactPublicServiceClient.UpdateChunk
type ArtifactPublicServiceClientMockUpdateChunkParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.UpdateChunkRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockUpdateChunkParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.UpdateChunk
type ArtifactPublicServiceClientMockUpdateChunkParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.UpdateChunkRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockUpdateChunkResults contains results of the ArtifactPublicServiceClient.UpdateChunk
type ArtifactPublicServiceClientMockUpdateChunkResults struct {
	up1 *mm_artifactv1alpha.UpdateChunkResponse
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateChunk *mArtifactPublicServiceClientMockUpdateChunk) Optional() *mArtifactPublicServiceClientMockUpdateChunk {
	mmUpdateChunk.optional = true
	return mmUpdateChunk
}

// Expect sets up expected params for ArtifactPublicServiceClient.UpdateChunk
func (mmUpdateChunk *mArtifactPublicServiceClientMockUpdateChunk) Expect(ctx context.Context, in *mm_artifactv1alpha.UpdateChunkRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockUpdateChunk {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateChunk mock is already set by Set")
	}

	if mmUpdateChunk.defaultExpectation == nil {
		mmUpdateChunk.defaultExpectation = &ArtifactPublicServiceClientMockUpdateChunkExpectation{}
	}

	if mmUpdateChunk.defaultExpectation.paramPtrs != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateChunk mock is already set by ExpectParams functions")
	}

	mmUpdateChunk.defaultExpectation.params = &ArtifactPublicServiceClientMockUpdateChunkParams{ctx, in, opts}
	for _, e := range mmUpdateChunk.expectations {
		if minimock.Equal(e.params, mmUpdateChunk.defaultExpectation.params) {
			mmUpdateChunk.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateChunk.defaultExpectation.params)
		}
	}

	return mmUpdateChunk
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.UpdateChunk
func (mmUpdateChunk *mArtifactPublicServiceClientMockUpdateChunk) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockUpdateChunk {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateChunk mock is already set by Set")
	}

	if mmUpdateChunk.defaultExpectation == nil {
		mmUpdateChunk.defaultExpectation = &ArtifactPublicServiceClientMockUpdateChunkExpectation{}
	}

	if mmUpdateChunk.defaultExpectation.params != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateChunk mock is already set by Expect")
	}

	if mmUpdateChunk.defaultExpectation.paramPtrs == nil {
		mmUpdateChunk.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockUpdateChunkParamPtrs{}
	}
	mmUpdateChunk.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateChunk
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.UpdateChunk
func (mmUpdateChunk *mArtifactPublicServiceClientMockUpdateChunk) ExpectInParam2(in *mm_artifactv1alpha.UpdateChunkRequest) *mArtifactPublicServiceClientMockUpdateChunk {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateChunk mock is already set by Set")
	}

	if mmUpdateChunk.defaultExpectation == nil {
		mmUpdateChunk.defaultExpectation = &ArtifactPublicServiceClientMockUpdateChunkExpectation{}
	}

	if mmUpdateChunk.defaultExpectation.params != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateChunk mock is already set by Expect")
	}

	if mmUpdateChunk.defaultExpectation.paramPtrs == nil {
		mmUpdateChunk.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockUpdateChunkParamPtrs{}
	}
	mmUpdateChunk.defaultExpectation.paramPtrs.in = &in

	return mmUpdateChunk
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.UpdateChunk
func (mmUpdateChunk *mArtifactPublicServiceClientMockUpdateChunk) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockUpdateChunk {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateChunk mock is already set by Set")
	}

	if mmUpdateChunk.defaultExpectation == nil {
		mmUpdateChunk.defaultExpectation = &ArtifactPublicServiceClientMockUpdateChunkExpectation{}
	}

	if mmUpdateChunk.defaultExpectation.params != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateChunk mock is already set by Expect")
	}

	if mmUpdateChunk.defaultExpectation.paramPtrs == nil {
		mmUpdateChunk.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockUpdateChunkParamPtrs{}
	}
	mmUpdateChunk.defaultExpectation.paramPtrs.opts = &opts

	return mmUpdateChunk
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.UpdateChunk
func (mmUpdateChunk *mArtifactPublicServiceClientMockUpdateChunk) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.UpdateChunkRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockUpdateChunk {
	if mmUpdateChunk.mock.inspectFuncUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.UpdateChunk")
	}

	mmUpdateChunk.mock.inspectFuncUpdateChunk = f

	return mmUpdateChunk
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.UpdateChunk
func (mmUpdateChunk *mArtifactPublicServiceClientMockUpdateChunk) Return(up1 *mm_artifactv1alpha.UpdateChunkResponse, err error) *ArtifactPublicServiceClientMock {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateChunk mock is already set by Set")
	}

	if mmUpdateChunk.defaultExpectation == nil {
		mmUpdateChunk.defaultExpectation = &ArtifactPublicServiceClientMockUpdateChunkExpectation{mock: mmUpdateChunk.mock}
	}
	mmUpdateChunk.defaultExpectation.results = &ArtifactPublicServiceClientMockUpdateChunkResults{up1, err}
	return mmUpdateChunk.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.UpdateChunk method
func (mmUpdateChunk *mArtifactPublicServiceClientMockUpdateChunk) Set(f func(ctx context.Context, in *mm_artifactv1alpha.UpdateChunkRequest, opts ...grpc.CallOption) (up1 *mm_artifactv1alpha.UpdateChunkResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmUpdateChunk.defaultExpectation != nil {
		mmUpdateChunk.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.UpdateChunk method")
	}

	if len(mmUpdateChunk.expectations) > 0 {
		mmUpdateChunk.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.UpdateChunk method")
	}

	mmUpdateChunk.mock.funcUpdateChunk = f
	return mmUpdateChunk.mock
}

// When sets expectation for the ArtifactPublicServiceClient.UpdateChunk which will trigger the result defined by the following
// Then helper
func (mmUpdateChunk *mArtifactPublicServiceClientMockUpdateChunk) When(ctx context.Context, in *mm_artifactv1alpha.UpdateChunkRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockUpdateChunkExpectation {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateChunk mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockUpdateChunkExpectation{
		mock:   mmUpdateChunk.mock,
		params: &ArtifactPublicServiceClientMockUpdateChunkParams{ctx, in, opts},
	}
	mmUpdateChunk.expectations = append(mmUpdateChunk.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.UpdateChunk return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockUpdateChunkExpectation) Then(up1 *mm_artifactv1alpha.UpdateChunkResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockUpdateChunkResults{up1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.UpdateChunk should be invoked
func (mmUpdateChunk *mArtifactPublicServiceClientMockUpdateChunk) Times(n uint64) *mArtifactPublicServiceClientMockUpdateChunk {
	if n == 0 {
		mmUpdateChunk.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.UpdateChunk mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateChunk.expectedInvocations, n)
	return mmUpdateChunk
}

func (mmUpdateChunk *mArtifactPublicServiceClientMockUpdateChunk) invocationsDone() bool {
	if len(mmUpdateChunk.expectations) == 0 && mmUpdateChunk.defaultExpectation == nil && mmUpdateChunk.mock.funcUpdateChunk == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateChunk.mock.afterUpdateChunkCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateChunk.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateChunk implements artifactv1alpha.ArtifactPublicServiceClient
func (mmUpdateChunk *ArtifactPublicServiceClientMock) UpdateChunk(ctx context.Context, in *mm_artifactv1alpha.UpdateChunkRequest, opts ...grpc.CallOption) (up1 *mm_artifactv1alpha.UpdateChunkResponse, err error) {
	mm_atomic.AddUint64(&mmUpdateChunk.beforeUpdateChunkCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateChunk.afterUpdateChunkCounter, 1)

	if mmUpdateChunk.inspectFuncUpdateChunk != nil {
		mmUpdateChunk.inspectFuncUpdateChunk(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockUpdateChunkParams{ctx, in, opts}

	// Record call args
	mmUpdateChunk.UpdateChunkMock.mutex.Lock()
	mmUpdateChunk.UpdateChunkMock.callArgs = append(mmUpdateChunk.UpdateChunkMock.callArgs, &mm_params)
	mmUpdateChunk.UpdateChunkMock.mutex.Unlock()

	for _, e := range mmUpdateChunk.UpdateChunkMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmUpdateChunk.UpdateChunkMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateChunk.UpdateChunkMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateChunk.UpdateChunkMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateChunk.UpdateChunkMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockUpdateChunkParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateChunk.t.Errorf("ArtifactPublicServiceClientMock.UpdateChunk got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmUpdateChunk.t.Errorf("ArtifactPublicServiceClientMock.UpdateChunk got unexpected parameter in, want: %#v, got: %#v%s\n", *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmUpdateChunk.t.Errorf("ArtifactPublicServiceClientMock.UpdateChunk got unexpected parameter opts, want: %#v, got: %#v%s\n", *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateChunk.t.Errorf("ArtifactPublicServiceClientMock.UpdateChunk got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateChunk.UpdateChunkMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateChunk.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.UpdateChunk")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmUpdateChunk.funcUpdateChunk != nil {
		return mmUpdateChunk.funcUpdateChunk(ctx, in, opts...)
	}
	mmUpdateChunk.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.UpdateChunk. %v %v %v", ctx, in, opts)
	return
}

// UpdateChunkAfterCounter returns a count of finished ArtifactPublicServiceClientMock.UpdateChunk invocations
func (mmUpdateChunk *ArtifactPublicServiceClientMock) UpdateChunkAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateChunk.afterUpdateChunkCounter)
}

// UpdateChunkBeforeCounter returns a count of ArtifactPublicServiceClientMock.UpdateChunk invocations
func (mmUpdateChunk *ArtifactPublicServiceClientMock) UpdateChunkBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateChunk.beforeUpdateChunkCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.UpdateChunk.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateChunk *mArtifactPublicServiceClientMockUpdateChunk) Calls() []*ArtifactPublicServiceClientMockUpdateChunkParams {
	mmUpdateChunk.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockUpdateChunkParams, len(mmUpdateChunk.callArgs))
	copy(argCopy, mmUpdateChunk.callArgs)

	mmUpdateChunk.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateChunkDone returns true if the count of the UpdateChunk invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockUpdateChunkDone() bool {
	if m.UpdateChunkMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateChunkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateChunkMock.invocationsDone()
}

// MinimockUpdateChunkInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockUpdateChunkInspect() {
	for _, e := range m.UpdateChunkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.UpdateChunk with params: %#v", *e.params)
		}
	}

	afterUpdateChunkCounter := mm_atomic.LoadUint64(&m.afterUpdateChunkCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateChunkMock.defaultExpectation != nil && afterUpdateChunkCounter < 1 {
		if m.UpdateChunkMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ArtifactPublicServiceClientMock.UpdateChunk")
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.UpdateChunk with params: %#v", *m.UpdateChunkMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateChunk != nil && afterUpdateChunkCounter < 1 {
		m.t.Error("Expected call to ArtifactPublicServiceClientMock.UpdateChunk")
	}

	if !m.UpdateChunkMock.invocationsDone() && afterUpdateChunkCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.UpdateChunk but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateChunkMock.expectedInvocations), afterUpdateChunkCounter)
	}
}

type mArtifactPublicServiceClientMockUpdateConversation struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockUpdateConversationExpectation
	expectations       []*ArtifactPublicServiceClientMockUpdateConversationExpectation

	callArgs []*ArtifactPublicServiceClientMockUpdateConversationParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ArtifactPublicServiceClientMockUpdateConversationExpectation specifies expectation struct of the ArtifactPublicServiceClient.UpdateConversation
type ArtifactPublicServiceClientMockUpdateConversationExpectation struct {
	mock      *ArtifactPublicServiceClientMock
	params    *ArtifactPublicServiceClientMockUpdateConversationParams
	paramPtrs *ArtifactPublicServiceClientMockUpdateConversationParamPtrs
	results   *ArtifactPublicServiceClientMockUpdateConversationResults
	Counter   uint64
}

// ArtifactPublicServiceClientMockUpdateConversationParams contains parameters of the ArtifactPublicServiceClient.UpdateConversation
type ArtifactPublicServiceClientMockUpdateConversationParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.UpdateConversationRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockUpdateConversationParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.UpdateConversation
type ArtifactPublicServiceClientMockUpdateConversationParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.UpdateConversationRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockUpdateConversationResults contains results of the ArtifactPublicServiceClient.UpdateConversation
type ArtifactPublicServiceClientMockUpdateConversationResults struct {
	up1 *mm_artifactv1alpha.UpdateConversationResponse
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateConversation *mArtifactPublicServiceClientMockUpdateConversation) Optional() *mArtifactPublicServiceClientMockUpdateConversation {
	mmUpdateConversation.optional = true
	return mmUpdateConversation
}

// Expect sets up expected params for ArtifactPublicServiceClient.UpdateConversation
func (mmUpdateConversation *mArtifactPublicServiceClientMockUpdateConversation) Expect(ctx context.Context, in *mm_artifactv1alpha.UpdateConversationRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockUpdateConversation {
	if mmUpdateConversation.mock.funcUpdateConversation != nil {
		mmUpdateConversation.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateConversation mock is already set by Set")
	}

	if mmUpdateConversation.defaultExpectation == nil {
		mmUpdateConversation.defaultExpectation = &ArtifactPublicServiceClientMockUpdateConversationExpectation{}
	}

	if mmUpdateConversation.defaultExpectation.paramPtrs != nil {
		mmUpdateConversation.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateConversation mock is already set by ExpectParams functions")
	}

	mmUpdateConversation.defaultExpectation.params = &ArtifactPublicServiceClientMockUpdateConversationParams{ctx, in, opts}
	for _, e := range mmUpdateConversation.expectations {
		if minimock.Equal(e.params, mmUpdateConversation.defaultExpectation.params) {
			mmUpdateConversation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateConversation.defaultExpectation.params)
		}
	}

	return mmUpdateConversation
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.UpdateConversation
func (mmUpdateConversation *mArtifactPublicServiceClientMockUpdateConversation) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockUpdateConversation {
	if mmUpdateConversation.mock.funcUpdateConversation != nil {
		mmUpdateConversation.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateConversation mock is already set by Set")
	}

	if mmUpdateConversation.defaultExpectation == nil {
		mmUpdateConversation.defaultExpectation = &ArtifactPublicServiceClientMockUpdateConversationExpectation{}
	}

	if mmUpdateConversation.defaultExpectation.params != nil {
		mmUpdateConversation.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateConversation mock is already set by Expect")
	}

	if mmUpdateConversation.defaultExpectation.paramPtrs == nil {
		mmUpdateConversation.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockUpdateConversationParamPtrs{}
	}
	mmUpdateConversation.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateConversation
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.UpdateConversation
func (mmUpdateConversation *mArtifactPublicServiceClientMockUpdateConversation) ExpectInParam2(in *mm_artifactv1alpha.UpdateConversationRequest) *mArtifactPublicServiceClientMockUpdateConversation {
	if mmUpdateConversation.mock.funcUpdateConversation != nil {
		mmUpdateConversation.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateConversation mock is already set by Set")
	}

	if mmUpdateConversation.defaultExpectation == nil {
		mmUpdateConversation.defaultExpectation = &ArtifactPublicServiceClientMockUpdateConversationExpectation{}
	}

	if mmUpdateConversation.defaultExpectation.params != nil {
		mmUpdateConversation.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateConversation mock is already set by Expect")
	}

	if mmUpdateConversation.defaultExpectation.paramPtrs == nil {
		mmUpdateConversation.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockUpdateConversationParamPtrs{}
	}
	mmUpdateConversation.defaultExpectation.paramPtrs.in = &in

	return mmUpdateConversation
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.UpdateConversation
func (mmUpdateConversation *mArtifactPublicServiceClientMockUpdateConversation) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockUpdateConversation {
	if mmUpdateConversation.mock.funcUpdateConversation != nil {
		mmUpdateConversation.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateConversation mock is already set by Set")
	}

	if mmUpdateConversation.defaultExpectation == nil {
		mmUpdateConversation.defaultExpectation = &ArtifactPublicServiceClientMockUpdateConversationExpectation{}
	}

	if mmUpdateConversation.defaultExpectation.params != nil {
		mmUpdateConversation.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateConversation mock is already set by Expect")
	}

	if mmUpdateConversation.defaultExpectation.paramPtrs == nil {
		mmUpdateConversation.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockUpdateConversationParamPtrs{}
	}
	mmUpdateConversation.defaultExpectation.paramPtrs.opts = &opts

	return mmUpdateConversation
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.UpdateConversation
func (mmUpdateConversation *mArtifactPublicServiceClientMockUpdateConversation) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.UpdateConversationRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockUpdateConversation {
	if mmUpdateConversation.mock.inspectFuncUpdateConversation != nil {
		mmUpdateConversation.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.UpdateConversation")
	}

	mmUpdateConversation.mock.inspectFuncUpdateConversation = f

	return mmUpdateConversation
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.UpdateConversation
func (mmUpdateConversation *mArtifactPublicServiceClientMockUpdateConversation) Return(up1 *mm_artifactv1alpha.UpdateConversationResponse, err error) *ArtifactPublicServiceClientMock {
	if mmUpdateConversation.mock.funcUpdateConversation != nil {
		mmUpdateConversation.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateConversation mock is already set by Set")
	}

	if mmUpdateConversation.defaultExpectation == nil {
		mmUpdateConversation.defaultExpectation = &ArtifactPublicServiceClientMockUpdateConversationExpectation{mock: mmUpdateConversation.mock}
	}
	mmUpdateConversation.defaultExpectation.results = &ArtifactPublicServiceClientMockUpdateConversationResults{up1, err}
	return mmUpdateConversation.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.UpdateConversation method
func (mmUpdateConversation *mArtifactPublicServiceClientMockUpdateConversation) Set(f func(ctx context.Context, in *mm_artifactv1alpha.UpdateConversationRequest, opts ...grpc.CallOption) (up1 *mm_artifactv1alpha.UpdateConversationResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmUpdateConversation.defaultExpectation != nil {
		mmUpdateConversation.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.UpdateConversation method")
	}

	if len(mmUpdateConversation.expectations) > 0 {
		mmUpdateConversation.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.UpdateConversation method")
	}

	mmUpdateConversation.mock.funcUpdateConversation = f
	return mmUpdateConversation.mock
}

// When sets expectation for the ArtifactPublicServiceClient.UpdateConversation which will trigger the result defined by the following
// Then helper
func (mmUpdateConversation *mArtifactPublicServiceClientMockUpdateConversation) When(ctx context.Context, in *mm_artifactv1alpha.UpdateConversationRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockUpdateConversationExpectation {
	if mmUpdateConversation.mock.funcUpdateConversation != nil {
		mmUpdateConversation.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateConversation mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockUpdateConversationExpectation{
		mock:   mmUpdateConversation.mock,
		params: &ArtifactPublicServiceClientMockUpdateConversationParams{ctx, in, opts},
	}
	mmUpdateConversation.expectations = append(mmUpdateConversation.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.UpdateConversation return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockUpdateConversationExpectation) Then(up1 *mm_artifactv1alpha.UpdateConversationResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockUpdateConversationResults{up1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.UpdateConversation should be invoked
func (mmUpdateConversation *mArtifactPublicServiceClientMockUpdateConversation) Times(n uint64) *mArtifactPublicServiceClientMockUpdateConversation {
	if n == 0 {
		mmUpdateConversation.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.UpdateConversation mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateConversation.expectedInvocations, n)
	return mmUpdateConversation
}

func (mmUpdateConversation *mArtifactPublicServiceClientMockUpdateConversation) invocationsDone() bool {
	if len(mmUpdateConversation.expectations) == 0 && mmUpdateConversation.defaultExpectation == nil && mmUpdateConversation.mock.funcUpdateConversation == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateConversation.mock.afterUpdateConversationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateConversation.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateConversation implements artifactv1alpha.ArtifactPublicServiceClient
func (mmUpdateConversation *ArtifactPublicServiceClientMock) UpdateConversation(ctx context.Context, in *mm_artifactv1alpha.UpdateConversationRequest, opts ...grpc.CallOption) (up1 *mm_artifactv1alpha.UpdateConversationResponse, err error) {
	mm_atomic.AddUint64(&mmUpdateConversation.beforeUpdateConversationCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateConversation.afterUpdateConversationCounter, 1)

	if mmUpdateConversation.inspectFuncUpdateConversation != nil {
		mmUpdateConversation.inspectFuncUpdateConversation(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockUpdateConversationParams{ctx, in, opts}

	// Record call args
	mmUpdateConversation.UpdateConversationMock.mutex.Lock()
	mmUpdateConversation.UpdateConversationMock.callArgs = append(mmUpdateConversation.UpdateConversationMock.callArgs, &mm_params)
	mmUpdateConversation.UpdateConversationMock.mutex.Unlock()

	for _, e := range mmUpdateConversation.UpdateConversationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmUpdateConversation.UpdateConversationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateConversation.UpdateConversationMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateConversation.UpdateConversationMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateConversation.UpdateConversationMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockUpdateConversationParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateConversation.t.Errorf("ArtifactPublicServiceClientMock.UpdateConversation got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmUpdateConversation.t.Errorf("ArtifactPublicServiceClientMock.UpdateConversation got unexpected parameter in, want: %#v, got: %#v%s\n", *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmUpdateConversation.t.Errorf("ArtifactPublicServiceClientMock.UpdateConversation got unexpected parameter opts, want: %#v, got: %#v%s\n", *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateConversation.t.Errorf("ArtifactPublicServiceClientMock.UpdateConversation got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateConversation.UpdateConversationMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateConversation.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.UpdateConversation")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmUpdateConversation.funcUpdateConversation != nil {
		return mmUpdateConversation.funcUpdateConversation(ctx, in, opts...)
	}
	mmUpdateConversation.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.UpdateConversation. %v %v %v", ctx, in, opts)
	return
}

// UpdateConversationAfterCounter returns a count of finished ArtifactPublicServiceClientMock.UpdateConversation invocations
func (mmUpdateConversation *ArtifactPublicServiceClientMock) UpdateConversationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateConversation.afterUpdateConversationCounter)
}

// UpdateConversationBeforeCounter returns a count of ArtifactPublicServiceClientMock.UpdateConversation invocations
func (mmUpdateConversation *ArtifactPublicServiceClientMock) UpdateConversationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateConversation.beforeUpdateConversationCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.UpdateConversation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateConversation *mArtifactPublicServiceClientMockUpdateConversation) Calls() []*ArtifactPublicServiceClientMockUpdateConversationParams {
	mmUpdateConversation.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockUpdateConversationParams, len(mmUpdateConversation.callArgs))
	copy(argCopy, mmUpdateConversation.callArgs)

	mmUpdateConversation.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateConversationDone returns true if the count of the UpdateConversation invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockUpdateConversationDone() bool {
	if m.UpdateConversationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateConversationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateConversationMock.invocationsDone()
}

// MinimockUpdateConversationInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockUpdateConversationInspect() {
	for _, e := range m.UpdateConversationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.UpdateConversation with params: %#v", *e.params)
		}
	}

	afterUpdateConversationCounter := mm_atomic.LoadUint64(&m.afterUpdateConversationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateConversationMock.defaultExpectation != nil && afterUpdateConversationCounter < 1 {
		if m.UpdateConversationMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ArtifactPublicServiceClientMock.UpdateConversation")
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.UpdateConversation with params: %#v", *m.UpdateConversationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateConversation != nil && afterUpdateConversationCounter < 1 {
		m.t.Error("Expected call to ArtifactPublicServiceClientMock.UpdateConversation")
	}

	if !m.UpdateConversationMock.invocationsDone() && afterUpdateConversationCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.UpdateConversation but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateConversationMock.expectedInvocations), afterUpdateConversationCounter)
	}
}

type mArtifactPublicServiceClientMockUpdateMessage struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockUpdateMessageExpectation
	expectations       []*ArtifactPublicServiceClientMockUpdateMessageExpectation

	callArgs []*ArtifactPublicServiceClientMockUpdateMessageParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ArtifactPublicServiceClientMockUpdateMessageExpectation specifies expectation struct of the ArtifactPublicServiceClient.UpdateMessage
type ArtifactPublicServiceClientMockUpdateMessageExpectation struct {
	mock      *ArtifactPublicServiceClientMock
	params    *ArtifactPublicServiceClientMockUpdateMessageParams
	paramPtrs *ArtifactPublicServiceClientMockUpdateMessageParamPtrs
	results   *ArtifactPublicServiceClientMockUpdateMessageResults
	Counter   uint64
}

// ArtifactPublicServiceClientMockUpdateMessageParams contains parameters of the ArtifactPublicServiceClient.UpdateMessage
type ArtifactPublicServiceClientMockUpdateMessageParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.UpdateMessageRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockUpdateMessageParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.UpdateMessage
type ArtifactPublicServiceClientMockUpdateMessageParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.UpdateMessageRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockUpdateMessageResults contains results of the ArtifactPublicServiceClient.UpdateMessage
type ArtifactPublicServiceClientMockUpdateMessageResults struct {
	up1 *mm_artifactv1alpha.UpdateMessageResponse
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateMessage *mArtifactPublicServiceClientMockUpdateMessage) Optional() *mArtifactPublicServiceClientMockUpdateMessage {
	mmUpdateMessage.optional = true
	return mmUpdateMessage
}

// Expect sets up expected params for ArtifactPublicServiceClient.UpdateMessage
func (mmUpdateMessage *mArtifactPublicServiceClientMockUpdateMessage) Expect(ctx context.Context, in *mm_artifactv1alpha.UpdateMessageRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockUpdateMessage {
	if mmUpdateMessage.mock.funcUpdateMessage != nil {
		mmUpdateMessage.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateMessage mock is already set by Set")
	}

	if mmUpdateMessage.defaultExpectation == nil {
		mmUpdateMessage.defaultExpectation = &ArtifactPublicServiceClientMockUpdateMessageExpectation{}
	}

	if mmUpdateMessage.defaultExpectation.paramPtrs != nil {
		mmUpdateMessage.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateMessage mock is already set by ExpectParams functions")
	}

	mmUpdateMessage.defaultExpectation.params = &ArtifactPublicServiceClientMockUpdateMessageParams{ctx, in, opts}
	for _, e := range mmUpdateMessage.expectations {
		if minimock.Equal(e.params, mmUpdateMessage.defaultExpectation.params) {
			mmUpdateMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateMessage.defaultExpectation.params)
		}
	}

	return mmUpdateMessage
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.UpdateMessage
func (mmUpdateMessage *mArtifactPublicServiceClientMockUpdateMessage) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockUpdateMessage {
	if mmUpdateMessage.mock.funcUpdateMessage != nil {
		mmUpdateMessage.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateMessage mock is already set by Set")
	}

	if mmUpdateMessage.defaultExpectation == nil {
		mmUpdateMessage.defaultExpectation = &ArtifactPublicServiceClientMockUpdateMessageExpectation{}
	}

	if mmUpdateMessage.defaultExpectation.params != nil {
		mmUpdateMessage.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateMessage mock is already set by Expect")
	}

	if mmUpdateMessage.defaultExpectation.paramPtrs == nil {
		mmUpdateMessage.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockUpdateMessageParamPtrs{}
	}
	mmUpdateMessage.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateMessage
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.UpdateMessage
func (mmUpdateMessage *mArtifactPublicServiceClientMockUpdateMessage) ExpectInParam2(in *mm_artifactv1alpha.UpdateMessageRequest) *mArtifactPublicServiceClientMockUpdateMessage {
	if mmUpdateMessage.mock.funcUpdateMessage != nil {
		mmUpdateMessage.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateMessage mock is already set by Set")
	}

	if mmUpdateMessage.defaultExpectation == nil {
		mmUpdateMessage.defaultExpectation = &ArtifactPublicServiceClientMockUpdateMessageExpectation{}
	}

	if mmUpdateMessage.defaultExpectation.params != nil {
		mmUpdateMessage.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateMessage mock is already set by Expect")
	}

	if mmUpdateMessage.defaultExpectation.paramPtrs == nil {
		mmUpdateMessage.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockUpdateMessageParamPtrs{}
	}
	mmUpdateMessage.defaultExpectation.paramPtrs.in = &in

	return mmUpdateMessage
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.UpdateMessage
func (mmUpdateMessage *mArtifactPublicServiceClientMockUpdateMessage) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockUpdateMessage {
	if mmUpdateMessage.mock.funcUpdateMessage != nil {
		mmUpdateMessage.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateMessage mock is already set by Set")
	}

	if mmUpdateMessage.defaultExpectation == nil {
		mmUpdateMessage.defaultExpectation = &ArtifactPublicServiceClientMockUpdateMessageExpectation{}
	}

	if mmUpdateMessage.defaultExpectation.params != nil {
		mmUpdateMessage.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateMessage mock is already set by Expect")
	}

	if mmUpdateMessage.defaultExpectation.paramPtrs == nil {
		mmUpdateMessage.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockUpdateMessageParamPtrs{}
	}
	mmUpdateMessage.defaultExpectation.paramPtrs.opts = &opts

	return mmUpdateMessage
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.UpdateMessage
func (mmUpdateMessage *mArtifactPublicServiceClientMockUpdateMessage) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.UpdateMessageRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockUpdateMessage {
	if mmUpdateMessage.mock.inspectFuncUpdateMessage != nil {
		mmUpdateMessage.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.UpdateMessage")
	}

	mmUpdateMessage.mock.inspectFuncUpdateMessage = f

	return mmUpdateMessage
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.UpdateMessage
func (mmUpdateMessage *mArtifactPublicServiceClientMockUpdateMessage) Return(up1 *mm_artifactv1alpha.UpdateMessageResponse, err error) *ArtifactPublicServiceClientMock {
	if mmUpdateMessage.mock.funcUpdateMessage != nil {
		mmUpdateMessage.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateMessage mock is already set by Set")
	}

	if mmUpdateMessage.defaultExpectation == nil {
		mmUpdateMessage.defaultExpectation = &ArtifactPublicServiceClientMockUpdateMessageExpectation{mock: mmUpdateMessage.mock}
	}
	mmUpdateMessage.defaultExpectation.results = &ArtifactPublicServiceClientMockUpdateMessageResults{up1, err}
	return mmUpdateMessage.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.UpdateMessage method
func (mmUpdateMessage *mArtifactPublicServiceClientMockUpdateMessage) Set(f func(ctx context.Context, in *mm_artifactv1alpha.UpdateMessageRequest, opts ...grpc.CallOption) (up1 *mm_artifactv1alpha.UpdateMessageResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmUpdateMessage.defaultExpectation != nil {
		mmUpdateMessage.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.UpdateMessage method")
	}

	if len(mmUpdateMessage.expectations) > 0 {
		mmUpdateMessage.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.UpdateMessage method")
	}

	mmUpdateMessage.mock.funcUpdateMessage = f
	return mmUpdateMessage.mock
}

// When sets expectation for the ArtifactPublicServiceClient.UpdateMessage which will trigger the result defined by the following
// Then helper
func (mmUpdateMessage *mArtifactPublicServiceClientMockUpdateMessage) When(ctx context.Context, in *mm_artifactv1alpha.UpdateMessageRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockUpdateMessageExpectation {
	if mmUpdateMessage.mock.funcUpdateMessage != nil {
		mmUpdateMessage.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateMessage mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockUpdateMessageExpectation{
		mock:   mmUpdateMessage.mock,
		params: &ArtifactPublicServiceClientMockUpdateMessageParams{ctx, in, opts},
	}
	mmUpdateMessage.expectations = append(mmUpdateMessage.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.UpdateMessage return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockUpdateMessageExpectation) Then(up1 *mm_artifactv1alpha.UpdateMessageResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockUpdateMessageResults{up1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.UpdateMessage should be invoked
func (mmUpdateMessage *mArtifactPublicServiceClientMockUpdateMessage) Times(n uint64) *mArtifactPublicServiceClientMockUpdateMessage {
	if n == 0 {
		mmUpdateMessage.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.UpdateMessage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateMessage.expectedInvocations, n)
	return mmUpdateMessage
}

func (mmUpdateMessage *mArtifactPublicServiceClientMockUpdateMessage) invocationsDone() bool {
	if len(mmUpdateMessage.expectations) == 0 && mmUpdateMessage.defaultExpectation == nil && mmUpdateMessage.mock.funcUpdateMessage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateMessage.mock.afterUpdateMessageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateMessage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateMessage implements artifactv1alpha.ArtifactPublicServiceClient
func (mmUpdateMessage *ArtifactPublicServiceClientMock) UpdateMessage(ctx context.Context, in *mm_artifactv1alpha.UpdateMessageRequest, opts ...grpc.CallOption) (up1 *mm_artifactv1alpha.UpdateMessageResponse, err error) {
	mm_atomic.AddUint64(&mmUpdateMessage.beforeUpdateMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateMessage.afterUpdateMessageCounter, 1)

	if mmUpdateMessage.inspectFuncUpdateMessage != nil {
		mmUpdateMessage.inspectFuncUpdateMessage(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockUpdateMessageParams{ctx, in, opts}

	// Record call args
	mmUpdateMessage.UpdateMessageMock.mutex.Lock()
	mmUpdateMessage.UpdateMessageMock.callArgs = append(mmUpdateMessage.UpdateMessageMock.callArgs, &mm_params)
	mmUpdateMessage.UpdateMessageMock.mutex.Unlock()

	for _, e := range mmUpdateMessage.UpdateMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmUpdateMessage.UpdateMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateMessage.UpdateMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateMessage.UpdateMessageMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateMessage.UpdateMessageMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockUpdateMessageParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateMessage.t.Errorf("ArtifactPublicServiceClientMock.UpdateMessage got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmUpdateMessage.t.Errorf("ArtifactPublicServiceClientMock.UpdateMessage got unexpected parameter in, want: %#v, got: %#v%s\n", *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmUpdateMessage.t.Errorf("ArtifactPublicServiceClientMock.UpdateMessage got unexpected parameter opts, want: %#v, got: %#v%s\n", *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateMessage.t.Errorf("ArtifactPublicServiceClientMock.UpdateMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateMessage.UpdateMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateMessage.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.UpdateMessage")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmUpdateMessage.funcUpdateMessage != nil {
		return mmUpdateMessage.funcUpdateMessage(ctx, in, opts...)
	}
	mmUpdateMessage.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.UpdateMessage. %v %v %v", ctx, in, opts)
	return
}

// UpdateMessageAfterCounter returns a count of finished ArtifactPublicServiceClientMock.UpdateMessage invocations
func (mmUpdateMessage *ArtifactPublicServiceClientMock) UpdateMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateMessage.afterUpdateMessageCounter)
}

// UpdateMessageBeforeCounter returns a count of ArtifactPublicServiceClientMock.UpdateMessage invocations
func (mmUpdateMessage *ArtifactPublicServiceClientMock) UpdateMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateMessage.beforeUpdateMessageCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.UpdateMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateMessage *mArtifactPublicServiceClientMockUpdateMessage) Calls() []*ArtifactPublicServiceClientMockUpdateMessageParams {
	mmUpdateMessage.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockUpdateMessageParams, len(mmUpdateMessage.callArgs))
	copy(argCopy, mmUpdateMessage.callArgs)

	mmUpdateMessage.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateMessageDone returns true if the count of the UpdateMessage invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockUpdateMessageDone() bool {
	if m.UpdateMessageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMessageMock.invocationsDone()
}

// MinimockUpdateMessageInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockUpdateMessageInspect() {
	for _, e := range m.UpdateMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.UpdateMessage with params: %#v", *e.params)
		}
	}

	afterUpdateMessageCounter := mm_atomic.LoadUint64(&m.afterUpdateMessageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMessageMock.defaultExpectation != nil && afterUpdateMessageCounter < 1 {
		if m.UpdateMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ArtifactPublicServiceClientMock.UpdateMessage")
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.UpdateMessage with params: %#v", *m.UpdateMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateMessage != nil && afterUpdateMessageCounter < 1 {
		m.t.Error("Expected call to ArtifactPublicServiceClientMock.UpdateMessage")
	}

	if !m.UpdateMessageMock.invocationsDone() && afterUpdateMessageCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.UpdateMessage but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMessageMock.expectedInvocations), afterUpdateMessageCounter)
	}
}

type mArtifactPublicServiceClientMockUploadCatalogFile struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockUploadCatalogFileExpectation
	expectations       []*ArtifactPublicServiceClientMockUploadCatalogFileExpectation

	callArgs []*ArtifactPublicServiceClientMockUploadCatalogFileParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ArtifactPublicServiceClientMockUploadCatalogFileExpectation specifies expectation struct of the ArtifactPublicServiceClient.UploadCatalogFile
type ArtifactPublicServiceClientMockUploadCatalogFileExpectation struct {
	mock      *ArtifactPublicServiceClientMock
	params    *ArtifactPublicServiceClientMockUploadCatalogFileParams
	paramPtrs *ArtifactPublicServiceClientMockUploadCatalogFileParamPtrs
	results   *ArtifactPublicServiceClientMockUploadCatalogFileResults
	Counter   uint64
}

// ArtifactPublicServiceClientMockUploadCatalogFileParams contains parameters of the ArtifactPublicServiceClient.UploadCatalogFile
type ArtifactPublicServiceClientMockUploadCatalogFileParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.UploadCatalogFileRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockUploadCatalogFileParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.UploadCatalogFile
type ArtifactPublicServiceClientMockUploadCatalogFileParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.UploadCatalogFileRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockUploadCatalogFileResults contains results of the ArtifactPublicServiceClient.UploadCatalogFile
type ArtifactPublicServiceClientMockUploadCatalogFileResults struct {
	up1 *mm_artifactv1alpha.UploadCatalogFileResponse
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUploadCatalogFile *mArtifactPublicServiceClientMockUploadCatalogFile) Optional() *mArtifactPublicServiceClientMockUploadCatalogFile {
	mmUploadCatalogFile.optional = true
	return mmUploadCatalogFile
}

// Expect sets up expected params for ArtifactPublicServiceClient.UploadCatalogFile
func (mmUploadCatalogFile *mArtifactPublicServiceClientMockUploadCatalogFile) Expect(ctx context.Context, in *mm_artifactv1alpha.UploadCatalogFileRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockUploadCatalogFile {
	if mmUploadCatalogFile.mock.funcUploadCatalogFile != nil {
		mmUploadCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.UploadCatalogFile mock is already set by Set")
	}

	if mmUploadCatalogFile.defaultExpectation == nil {
		mmUploadCatalogFile.defaultExpectation = &ArtifactPublicServiceClientMockUploadCatalogFileExpectation{}
	}

	if mmUploadCatalogFile.defaultExpectation.paramPtrs != nil {
		mmUploadCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.UploadCatalogFile mock is already set by ExpectParams functions")
	}

	mmUploadCatalogFile.defaultExpectation.params = &ArtifactPublicServiceClientMockUploadCatalogFileParams{ctx, in, opts}
	for _, e := range mmUploadCatalogFile.expectations {
		if minimock.Equal(e.params, mmUploadCatalogFile.defaultExpectation.params) {
			mmUploadCatalogFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUploadCatalogFile.defaultExpectation.params)
		}
	}

	return mmUploadCatalogFile
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.UploadCatalogFile
func (mmUploadCatalogFile *mArtifactPublicServiceClientMockUploadCatalogFile) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockUploadCatalogFile {
	if mmUploadCatalogFile.mock.funcUploadCatalogFile != nil {
		mmUploadCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.UploadCatalogFile mock is already set by Set")
	}

	if mmUploadCatalogFile.defaultExpectation == nil {
		mmUploadCatalogFile.defaultExpectation = &ArtifactPublicServiceClientMockUploadCatalogFileExpectation{}
	}

	if mmUploadCatalogFile.defaultExpectation.params != nil {
		mmUploadCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.UploadCatalogFile mock is already set by Expect")
	}

	if mmUploadCatalogFile.defaultExpectation.paramPtrs == nil {
		mmUploadCatalogFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockUploadCatalogFileParamPtrs{}
	}
	mmUploadCatalogFile.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUploadCatalogFile
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.UploadCatalogFile
func (mmUploadCatalogFile *mArtifactPublicServiceClientMockUploadCatalogFile) ExpectInParam2(in *mm_artifactv1alpha.UploadCatalogFileRequest) *mArtifactPublicServiceClientMockUploadCatalogFile {
	if mmUploadCatalogFile.mock.funcUploadCatalogFile != nil {
		mmUploadCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.UploadCatalogFile mock is already set by Set")
	}

	if mmUploadCatalogFile.defaultExpectation == nil {
		mmUploadCatalogFile.defaultExpectation = &ArtifactPublicServiceClientMockUploadCatalogFileExpectation{}
	}

	if mmUploadCatalogFile.defaultExpectation.params != nil {
		mmUploadCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.UploadCatalogFile mock is already set by Expect")
	}

	if mmUploadCatalogFile.defaultExpectation.paramPtrs == nil {
		mmUploadCatalogFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockUploadCatalogFileParamPtrs{}
	}
	mmUploadCatalogFile.defaultExpectation.paramPtrs.in = &in

	return mmUploadCatalogFile
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.UploadCatalogFile
func (mmUploadCatalogFile *mArtifactPublicServiceClientMockUploadCatalogFile) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockUploadCatalogFile {
	if mmUploadCatalogFile.mock.funcUploadCatalogFile != nil {
		mmUploadCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.UploadCatalogFile mock is already set by Set")
	}

	if mmUploadCatalogFile.defaultExpectation == nil {
		mmUploadCatalogFile.defaultExpectation = &ArtifactPublicServiceClientMockUploadCatalogFileExpectation{}
	}

	if mmUploadCatalogFile.defaultExpectation.params != nil {
		mmUploadCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.UploadCatalogFile mock is already set by Expect")
	}

	if mmUploadCatalogFile.defaultExpectation.paramPtrs == nil {
		mmUploadCatalogFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockUploadCatalogFileParamPtrs{}
	}
	mmUploadCatalogFile.defaultExpectation.paramPtrs.opts = &opts

	return mmUploadCatalogFile
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.UploadCatalogFile
func (mmUploadCatalogFile *mArtifactPublicServiceClientMockUploadCatalogFile) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.UploadCatalogFileRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockUploadCatalogFile {
	if mmUploadCatalogFile.mock.inspectFuncUploadCatalogFile != nil {
		mmUploadCatalogFile.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.UploadCatalogFile")
	}

	mmUploadCatalogFile.mock.inspectFuncUploadCatalogFile = f

	return mmUploadCatalogFile
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.UploadCatalogFile
func (mmUploadCatalogFile *mArtifactPublicServiceClientMockUploadCatalogFile) Return(up1 *mm_artifactv1alpha.UploadCatalogFileResponse, err error) *ArtifactPublicServiceClientMock {
	if mmUploadCatalogFile.mock.funcUploadCatalogFile != nil {
		mmUploadCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.UploadCatalogFile mock is already set by Set")
	}

	if mmUploadCatalogFile.defaultExpectation == nil {
		mmUploadCatalogFile.defaultExpectation = &ArtifactPublicServiceClientMockUploadCatalogFileExpectation{mock: mmUploadCatalogFile.mock}
	}
	mmUploadCatalogFile.defaultExpectation.results = &ArtifactPublicServiceClientMockUploadCatalogFileResults{up1, err}
	return mmUploadCatalogFile.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.UploadCatalogFile method
func (mmUploadCatalogFile *mArtifactPublicServiceClientMockUploadCatalogFile) Set(f func(ctx context.Context, in *mm_artifactv1alpha.UploadCatalogFileRequest, opts ...grpc.CallOption) (up1 *mm_artifactv1alpha.UploadCatalogFileResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmUploadCatalogFile.defaultExpectation != nil {
		mmUploadCatalogFile.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.UploadCatalogFile method")
	}

	if len(mmUploadCatalogFile.expectations) > 0 {
		mmUploadCatalogFile.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.UploadCatalogFile method")
	}

	mmUploadCatalogFile.mock.funcUploadCatalogFile = f
	return mmUploadCatalogFile.mock
}

// When sets expectation for the ArtifactPublicServiceClient.UploadCatalogFile which will trigger the result defined by the following
// Then helper
func (mmUploadCatalogFile *mArtifactPublicServiceClientMockUploadCatalogFile) When(ctx context.Context, in *mm_artifactv1alpha.UploadCatalogFileRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockUploadCatalogFileExpectation {
	if mmUploadCatalogFile.mock.funcUploadCatalogFile != nil {
		mmUploadCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.UploadCatalogFile mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockUploadCatalogFileExpectation{
		mock:   mmUploadCatalogFile.mock,
		params: &ArtifactPublicServiceClientMockUploadCatalogFileParams{ctx, in, opts},
	}
	mmUploadCatalogFile.expectations = append(mmUploadCatalogFile.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.UploadCatalogFile return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockUploadCatalogFileExpectation) Then(up1 *mm_artifactv1alpha.UploadCatalogFileResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockUploadCatalogFileResults{up1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.UploadCatalogFile should be invoked
func (mmUploadCatalogFile *mArtifactPublicServiceClientMockUploadCatalogFile) Times(n uint64) *mArtifactPublicServiceClientMockUploadCatalogFile {
	if n == 0 {
		mmUploadCatalogFile.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.UploadCatalogFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUploadCatalogFile.expectedInvocations, n)
	return mmUploadCatalogFile
}

func (mmUploadCatalogFile *mArtifactPublicServiceClientMockUploadCatalogFile) invocationsDone() bool {
	if len(mmUploadCatalogFile.expectations) == 0 && mmUploadCatalogFile.defaultExpectation == nil && mmUploadCatalogFile.mock.funcUploadCatalogFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUploadCatalogFile.mock.afterUploadCatalogFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUploadCatalogFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UploadCatalogFile implements artifactv1alpha.ArtifactPublicServiceClient
func (mmUploadCatalogFile *ArtifactPublicServiceClientMock) UploadCatalogFile(ctx context.Context, in *mm_artifactv1alpha.UploadCatalogFileRequest, opts ...grpc.CallOption) (up1 *mm_artifactv1alpha.UploadCatalogFileResponse, err error) {
	mm_atomic.AddUint64(&mmUploadCatalogFile.beforeUploadCatalogFileCounter, 1)
	defer mm_atomic.AddUint64(&mmUploadCatalogFile.afterUploadCatalogFileCounter, 1)

	if mmUploadCatalogFile.inspectFuncUploadCatalogFile != nil {
		mmUploadCatalogFile.inspectFuncUploadCatalogFile(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockUploadCatalogFileParams{ctx, in, opts}

	// Record call args
	mmUploadCatalogFile.UploadCatalogFileMock.mutex.Lock()
	mmUploadCatalogFile.UploadCatalogFileMock.callArgs = append(mmUploadCatalogFile.UploadCatalogFileMock.callArgs, &mm_params)
	mmUploadCatalogFile.UploadCatalogFileMock.mutex.Unlock()

	for _, e := range mmUploadCatalogFile.UploadCatalogFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmUploadCatalogFile.UploadCatalogFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUploadCatalogFile.UploadCatalogFileMock.defaultExpectation.Counter, 1)
		mm_want := mmUploadCatalogFile.UploadCatalogFileMock.defaultExpectation.params
		mm_want_ptrs := mmUploadCatalogFile.UploadCatalogFileMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockUploadCatalogFileParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUploadCatalogFile.t.Errorf("ArtifactPublicServiceClientMock.UploadCatalogFile got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmUploadCatalogFile.t.Errorf("ArtifactPublicServiceClientMock.UploadCatalogFile got unexpected parameter in, want: %#v, got: %#v%s\n", *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmUploadCatalogFile.t.Errorf("ArtifactPublicServiceClientMock.UploadCatalogFile got unexpected parameter opts, want: %#v, got: %#v%s\n", *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUploadCatalogFile.t.Errorf("ArtifactPublicServiceClientMock.UploadCatalogFile got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUploadCatalogFile.UploadCatalogFileMock.defaultExpectation.results
		if mm_results == nil {
			mmUploadCatalogFile.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.UploadCatalogFile")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmUploadCatalogFile.funcUploadCatalogFile != nil {
		return mmUploadCatalogFile.funcUploadCatalogFile(ctx, in, opts...)
	}
	mmUploadCatalogFile.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.UploadCatalogFile. %v %v %v", ctx, in, opts)
	return
}

// UploadCatalogFileAfterCounter returns a count of finished ArtifactPublicServiceClientMock.UploadCatalogFile invocations
func (mmUploadCatalogFile *ArtifactPublicServiceClientMock) UploadCatalogFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUploadCatalogFile.afterUploadCatalogFileCounter)
}

// UploadCatalogFileBeforeCounter returns a count of ArtifactPublicServiceClientMock.UploadCatalogFile invocations
func (mmUploadCatalogFile *ArtifactPublicServiceClientMock) UploadCatalogFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUploadCatalogFile.beforeUploadCatalogFileCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.UploadCatalogFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUploadCatalogFile *mArtifactPublicServiceClientMockUploadCatalogFile) Calls() []*ArtifactPublicServiceClientMockUploadCatalogFileParams {
	mmUploadCatalogFile.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockUploadCatalogFileParams, len(mmUploadCatalogFile.callArgs))
	copy(argCopy, mmUploadCatalogFile.callArgs)

	mmUploadCatalogFile.mutex.RUnlock()

	return argCopy
}

// MinimockUploadCatalogFileDone returns true if the count of the UploadCatalogFile invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockUploadCatalogFileDone() bool {
	if m.UploadCatalogFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UploadCatalogFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UploadCatalogFileMock.invocationsDone()
}

// MinimockUploadCatalogFileInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockUploadCatalogFileInspect() {
	for _, e := range m.UploadCatalogFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.UploadCatalogFile with params: %#v", *e.params)
		}
	}

	afterUploadCatalogFileCounter := mm_atomic.LoadUint64(&m.afterUploadCatalogFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UploadCatalogFileMock.defaultExpectation != nil && afterUploadCatalogFileCounter < 1 {
		if m.UploadCatalogFileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ArtifactPublicServiceClientMock.UploadCatalogFile")
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.UploadCatalogFile with params: %#v", *m.UploadCatalogFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUploadCatalogFile != nil && afterUploadCatalogFileCounter < 1 {
		m.t.Error("Expected call to ArtifactPublicServiceClientMock.UploadCatalogFile")
	}

	if !m.UploadCatalogFileMock.invocationsDone() && afterUploadCatalogFileCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.UploadCatalogFile but found %d calls",
			mm_atomic.LoadUint64(&m.UploadCatalogFileMock.expectedInvocations), afterUploadCatalogFileCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ArtifactPublicServiceClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateCatalogInspect()

			m.MinimockCreateConversationInspect()

			m.MinimockCreateMessageInspect()

			m.MinimockDeleteCatalogInspect()

			m.MinimockDeleteCatalogFileInspect()

			m.MinimockDeleteConversationInspect()

			m.MinimockDeleteMessageInspect()

			m.MinimockGetFileCatalogInspect()

			m.MinimockGetSourceFileInspect()

			m.MinimockListCatalogFilesInspect()

			m.MinimockListCatalogsInspect()

			m.MinimockListChunksInspect()

			m.MinimockListConversationsInspect()

			m.MinimockListMessagesInspect()

			m.MinimockLivenessInspect()

			m.MinimockProcessCatalogFilesInspect()

			m.MinimockQuestionAnsweringInspect()

			m.MinimockReadinessInspect()

			m.MinimockSimilarityChunksSearchInspect()

			m.MinimockUpdateCatalogInspect()

			m.MinimockUpdateChunkInspect()

			m.MinimockUpdateConversationInspect()

			m.MinimockUpdateMessageInspect()

			m.MinimockUploadCatalogFileInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ArtifactPublicServiceClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ArtifactPublicServiceClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateCatalogDone() &&
		m.MinimockCreateConversationDone() &&
		m.MinimockCreateMessageDone() &&
		m.MinimockDeleteCatalogDone() &&
		m.MinimockDeleteCatalogFileDone() &&
		m.MinimockDeleteConversationDone() &&
		m.MinimockDeleteMessageDone() &&
		m.MinimockGetFileCatalogDone() &&
		m.MinimockGetSourceFileDone() &&
		m.MinimockListCatalogFilesDone() &&
		m.MinimockListCatalogsDone() &&
		m.MinimockListChunksDone() &&
		m.MinimockListConversationsDone() &&
		m.MinimockListMessagesDone() &&
		m.MinimockLivenessDone() &&
		m.MinimockProcessCatalogFilesDone() &&
		m.MinimockQuestionAnsweringDone() &&
		m.MinimockReadinessDone() &&
		m.MinimockSimilarityChunksSearchDone() &&
		m.MinimockUpdateCatalogDone() &&
		m.MinimockUpdateChunkDone() &&
		m.MinimockUpdateConversationDone() &&
		m.MinimockUpdateMessageDone() &&
		m.MinimockUploadCatalogFileDone()
}
